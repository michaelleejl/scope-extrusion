\newcommand{\scoped}[2][\Theta]{\textsf{Scoped}_{{#1}, {#2}}}

\chapter{Scope Extrusion}\label{chapter:scope-extrusion}
This chapter uses \calculusName{} to formulate precise definitions of scope extrusion, and additionally evaluates four scope extrusion checks: 
\begin{enumerate}
  \item The lazy dynamic check, first described by \citet{kiselyov-14} (\Cref{section:lazy-dynamic-check-formal}).
  \item The eager dynamic check, which to the best of my knowledge is a faithful description of the current MetaOCaml check \citep{kiselyov-16} (\Cref{section:eager-dynamic-check-formal}).
  \item A novel best-effort dynamic check, which I argue occupies a goldilocks zone between expressiveness and efficiency (\Cref{section:best-effort-check}).
  \item Refined environment classifiers, a static approach first described by \citet{kiselyov-16}, and considered in the context of effect handlers by \citet{isoda-24} (\Cref{section:refined-environment-classifiers-formal}).
\end{enumerate}
I have implemented the three dynamic checks in MacoCaml. The implementations closely mirror the descriptions in this chapter, and were useful for building an understanding of the correctness and expressiveness of the various checks. 

\Cref{section:evaluation} evaluates \calculusName{}'s ability to facilitate comparative evaluation of different scope extrusion checks. 
\section{Properties of Dynamic Scope Extrusion Checks}
This chapter refers to the correctness and permissiveness of dynamic scope extrusion checks. Since dynamic checks are defined as term elaborations, I use $\elaborate{-}^{\textbf{Check}}$ to indicate an arbitrary dynamic check. I refer to the term elaboration in \Cref{section:elaboration} as naïve elaboration.

Given a definition of scope extrusion $\Phi$ (a predicate on configurations), a dynamic check is correct if, for all well-typed \sourceLang{} expressions $e$, if elaborating $e$ with the check ($\elaborate{e}^{\textbf{Check}}$) would detect scope extrusion (transition to $\err{}$), assuming naïvely elaborating $e$ ($\elaborate{e}$) reduces to a configuration exhibiting scope extrusion ($\Phi(\langle t;E;U;M;I\rangle)$).

\begin{definition}[Correctness of a Dynamic Scope Extrusion Check]{sourceHighlight}
 Given a predicate on configurations $\Phi$, a dynamic scope extrusion check $\elaborate{-}^{\textbf{Check}}$ is correct with respect to $\Phi$ if for all closed, well-type \sourceLang{} expressions $e$,
 \[\begin{array}{c} \langle \elaborate{e} ; [-]; \emptyset;\emptyset; \top \rangle \to^{*} \langle t;E;U;M;I \rangle \land \Phi(\langle t;E;U;M;I \rangle)
\\ \implies \\
\langle \elaborate{e}^{\textbf{Check}} ; [-]; \emptyset;\emptyset; \top \rangle  \to^{*} \; \langle \textbf{\texttt{err}};E';U';M';I' \rangle
 \end{array}
 \]
 for some $E', U', M', I'$. 
\end{definition}

One has to consider naïve elaboration, because some checks (\Cref{section:best-effort-check}) can transform a program that exhibits scope extrusion to one that terminates early with an $\err{}$.

The permissiveness of a scope extrusion check refers to the set of well-typed closed \sourceLang{} expressions that, when elaborated, do not transition to \textbf{\texttt{err}} (even if they exhibit scope extrusion).

\begin{definition}[Permissiveness of a Dynamic Scope Extrusion Check]{sourceHighlight}
 Let \textsf{WellTyped} be the set of closed, well-typed, \sourceLang{} expressions.
 The permissiveness of a dynamic scope extrusion check is defined as 
 \[\{ e \in \textsf{WellTyped}\, \mid \langle \elaborate{e}^{\textbf{Check}};[-];\emptyset;\emptyset;\top \rangle \not\to^{*} \langle \err ; E ; U ; M ; I \rangle \} \]
\end{definition}

\section{Lazy Dynamic Check}\label{section:lazy-dynamic-check-formal}
Scope extrusion can be defined as a predicate on \coreLang{} configurations ($\langle t;E;U;M;I\rangle$). Lazy scope extrusion, for example, occurs when the \textit{result} of compile-time execution ($E = E'[\tls{[-]}]$) is improperly scoped ($t = \return{n}$, $\freevars{n} \not\subseteq \projfvs{E}$). Lazy scope extrusion formalises the definition by \citet{kiselyov-14}.

% In the words of \citet{kiselyov-14} (emphasis mine),

% \begin{quote}
%   \textit{Detection of scope extrusion may appear straightforward: traverse the \textbf{result of a generator} looking for unbound identifiers.}
% \end{quote}

% I call this lazy scope extrusion: 

\begin{definition}[Lazy Scope Extrusion]{coreHighlight}\label[definition]{def:lazy-scope-extrusion} A \coreLang{} configuration of the form 
\[\langle t;E;U;M;I\rangle\]  
exhibits lazy scope extrusion if all of the following hold:
  \begin{enumerate}
    \item $t = \return{n}$ for some $n$ of \textsf{AST} type
    \item $E = E'[\tls{[-]}]$ for some $E'$
    \item $\freevars{n} \not\subseteq \projfvs{E}$
  \end{enumerate}
\end{definition}

The lazy dynamic check, ${\elaborate{-}}^{\textbf{Lazy}}$, augments the naïve elaboration in two ways. First, \textbf{\texttt{check}}s are performed after top-level splices:
\[\elaborate{\splice[e]}_{\compilemode{}}^{\textbf{Lazy}} \triangleq {\checkfv{(\tls{\elaborate{e}_{\splicemode{}}^{\textbf{Lazy}}})}}\]
Second, \textbf{\texttt{dlet}}s are inserted to ensure variables bound outside top-level splices are declared safe (\Cref{dfn:declared-safe}), and thus do not cause the \textbf{\texttt{check}} to fail. For example, in $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$, $x$ should be declared safe, and thus allowed to be free, but $y$ should not. Thus, elaboration of formal parameters in \compilemode{}-mode (but not \quotemode{}-mode) should insert \textbf{\texttt{dlet}}s:
{
  \footnotesize
\[\elaborate{\lambda x: T^0. \, e}_{\compilemode{}}^{\textbf{Lazy}} = \bind{x}{\gensym{\erase{T^0}}}{ \dlet{x}{\bind{\texttt{body}}{\elaborate{e}_{\compilemode{}}^\textbf{Lazy}}{\return{\Lam{x}{\texttt{body}}}}}}\]
}
\newcommand{\indentone}{\quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\;\;\;}
    \newcommand{\indenttwo}{\quad\quad\quad\quad\quad\;\,\,}
    \newcommand{\indentthree}{\quad\quad\quad\quad}
For example, $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$ elaborates into (changes from the naïve elaboration are \hl{highlighted}):
{
\[\begin{array}{@{}l}
  \bind{x}{\gensym{\mathbb{N}}}{} \\
  \hl{\textbf{\texttt{dlet}}(}\, {x}, \textbf{\texttt{do}} \; {\texttt{body}_1} \leftarrow \hl{\textbf{\texttt{check}}(}\,\textbf{\texttt{tls}}({\bind{y}{\gensym{\mathbb{N}}}{}} \\
    \indentone
    \textbf{\texttt{do}}\;{\texttt{body}_2} \leftarrow {(\bind{a}{{\varToAST{x}}}{}}\\
    \indentone\indenttwo
    \bind{b}{{\varToAST{y}}}{}\\
    \indentone\indenttwo
    \return{\texttt{Plus}(a, b)}) \, \textbf{\texttt{in}}\\
    \indentone
    \return{\Lam{y}{\texttt{body}_2}})\,\hl{)}\,\textbf{\texttt{in}}\\
  \indentthree{\return{\Lam{x}{\texttt{body}_1}}}\,\hl{)}
\end{array}\]
}
% Second, I perform a check after a top-level splice:
% \[\elaborate{\splice[e]}_{\compilemode{}}^{\textbf{Lazy}} \triangleq \bind{\texttt{res}}{\tls{\elaborate{e}_{\splicemode{}}^{\textbf{Lazy}}}}{\checkfv{\texttt{res}}}\]

Due to the simplicity of the algorithm, verifying the correctness (with respect to lazy scope extrusion) and permissiveness of the check is trivial: the lazy dynamic check detects scope extrusion if, and only if, naïve elaboration would exhibit lazy scope extrusion after reduction.

\begin{theorem}[Correctness and Permissiveness of the Lazy Dynamic Check]{sourceHighlight}
Assuming $\cdot \vdash_{\compilemode{}} e: T^0 \, ! \, \emptyset;\emptyset$, and $\elaborate{e}_{\compilemode{}}^{\textbf{Lazy}} = t$, 
\[\begin{array}{c}
\langle t; [-]; \emptyset; \emptyset; \top \rangle \to^{*} \langle \err; E; U; M; I \rangle \\
\iff \\
\text{For some $E', U', M', I'$, }\\
\langle \elaborate{e}; [-]; \emptyset; \emptyset; \top \rangle \to^{*} \langle \return{n}; E'; U'; M'; I' \rangle\text{, and}\\
\langle \return{n}; E'; U'; M'; I' \rangle \text{ exhibits lazy scope extrusion}
\end{array}
\]
\end{theorem}

The lazy scope extrusion check thus acts as a baseline, characterising the set of \sourceLang{} programs that it is ``safe'' to permit. This is used to define the \textit{expressiveness} of a check, where the lazy dynamic check is \textit{maximally} expressive:

\begin{definition}[Expressiveness of a Dynamic Scope Extrusion Check]{sourceHighlight}
Let the set \textsf{Safe} be defined as 
\[\textsf{Safe} \triangleq \{ e \in \textsf{WellTyped} \mid \langle \elaborate{e}^{\textbf{Lazy}}; [-]; \emptyset ; \emptyset ; \top \rangle \not\to^{*} \langle \err ; E ; U ; M ; I \rangle \}\]
The permissiveness of a dynamic scope extrusion check is defined as 
 \[\{ e \in \textsf{Safe}\, \mid \langle \elaborate{e}^{\textbf{Check}};[-];\emptyset;\emptyset;\top \rangle \not\to^{*} \langle \err ; E ; U ; M ; I \rangle \} \]
\end{definition}

Given a scope extrusion check, every rejected program that would be permitted by the lazy dynamic check is considered a false positive:
\begin{definition}[False Positives of a Dynamic Scope Extrusion Check]{sourceHighlight}
The false positives of a dynamic scope extrusion check are defined as 
 \[\{ e \in \textsf{Safe}\, \mid \langle \elaborate{e}^{\textbf{Check}};[-];\emptyset;\emptyset;\top \rangle \to^{*} \langle \err ; E ; U ; M ; I \rangle \} \]
\end{definition}

However, due again to its simplicity, the lazy dynamic check is inefficient and uninformative, and therefore not suitable for practical use \citep{kiselyov-14} (\Cref{subsubsection:lazy-dynamic-check}, \Cpageref{subsubsection:lazy-dynamic-check}).

\section{Eager Dynamic Check}\label{section:eager-dynamic-check-formal}
Eager scope extrusion extends lazy scope extrusion, considering configurations representing \textit{intermediate results} of compile-time execution (\Cref{subsubsection:eager-dynamic-check}, \Cpageref{subsubsection:eager-dynamic-check}). Notice that the definition drops the requirement that $E = E'[\tls{[-]}]$, but is otherwise identical to \Cref{def:lazy-scope-extrusion}. 

\begin{definition}[Eager Scope Extrusion]{coreHighlight}\label[definition]{dfn:eager-scope-extrusion} A \coreLang{} configuration of the form 
\[\langle t;E;U;M;I\rangle\]  
exhibits eager scope extrusion if all of the following hold:
  \begin{enumerate}
    \item $t = \return{n}$ for some $n$ of \textsf{AST} type
    % \item $E = E' :: \tls{[-]}$ for some $E'$
    \item $\freevars{n} \not\subseteq \projfvs{E}$
  \end{enumerate}
\end{definition}


\Cref{dfn:eager-scope-extrusion} formalises the definition by \citet{kiselyov-14}:
\begin{quote}
  \textit{At \textbf{any point during the evaluation}, an occurrence of an open-code value with a free variable whose name is not dynamically bound.}
\end{quote}
The third clause, $\freevars{n} \not\subseteq \projfvs{E}$, formally describes free variables whose ``[names are] not dynamically bound''.

It is possible to define an eager dynamic check by extending the lazy dynamic check. In addition to the top-level splice $\textbf{\texttt{check}}$, and the \compilemode{}-mode \textbf{\texttt{dlet}}s, the eager dynamic check adds \textbf{\texttt{check}}s for ASTs constructed in \quotemode{}-mode, for example 
\[\elaborate{v_1 v_2}_{\quotemode{}}^{\textbf{Eager}} = \bind{f}{\elaborate{v_1}_{\quotemode{}}^{\textbf{Eager}}}{\bind{a}{\elaborate{v_2}_{\quotemode{}}^{\textbf{Eager}}}{\checkfv{\App{f}{a}}}}\]
notice how $\return{\App{f}{a}}$ is replaced by $\checkfv{\App{f}{a}}$. 

Consequently, to prevent false positives, variables bound in \quotemode{}-mode must also be declared safe via \textbf{\texttt{dlet}}:
{
  \footnotesize
\[
\begin{array}{rcl}
\elaborate{\lambda x: T^0. \, e}_{\quotemode{}}^{\textbf{Eager}} = \bind{x}{\gensym{\erase{T^0}}}{\checkfv{(\dlet{x}{\bind{\texttt{body}}{\elaborate{e}_{\quotemode{}}^\textbf{Eager}}{\return{\Lam{x}{\texttt{body}}}}})}}
\end{array}\]
}

The elaboration of $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$ thus changes to (changes from the lazy dynamic check are \textbf{\hl{highlighted}}):
{
  \renewcommand{\varToAST}[1]{\hl{\textbf{\texttt{check}}}\, \texttt{Var}(#1)}
\[\begin{array}{@{}l}
  \bind{x}{\gensym{\mathbb{N}}}{} \\
  {\textbf{\texttt{dlet}}(}{x}, \textbf{\texttt{do}} \; {\texttt{body}_1} \leftarrow {\textbf{\texttt{check}}(}\textbf{\texttt{tls}}({\bind{y}{\gensym{\mathbb{N}}}{\hl{\textbf{\texttt{check}}(\textbf{\texttt{dlet}}($y$,}}} \\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \textbf{\texttt{do}}\;{\texttt{body}_2} \leftarrow {(\bind{a}{{\varToAST{x}}}{}}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \bind{b}{{\varToAST{y}}}{}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \textbf{\texttt{\hl{check}}}\;{\texttt{Plus}(a, b)}) \, \textbf{\texttt{in}}\\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \return{\Lam{y}{\texttt{body}_2}}{\hl{))}\,})) \, \textbf{\texttt{in}}\\
  \quad\quad\quad\;\, {\return{\Lam{x}{\texttt{body}_1}}})
\end{array}\]
}

If \textbf{\texttt{dlet}}s were not inserted for binders in \quotemode{}-mode (e.g. $y$), then $\textbf{\texttt{check}}\; \texttt{Plus}(a, b)$ would fail, as $y$ would not be declared safe. 

Intuitively, the eager dynamic check performs a check whenever an AST is built. Hence, assume that evaluation reduces to a configuration that exhibits eager scope extrusion. Let the offending AST be $n$. The error is detected and reported when, in some evaluation context $E$, $n$ is used to build a bigger AST $n'$, and not all free variables in $n'$ are declared safe in $E$. 

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{do}} \, z \leftarrow (\textbf{\texttt{handle}} \; \equote[{\, \lambda x. \,\splice[({{\, \textbf{\texttt{extrude}}(\equote[x]) \,}})]\,}] \\
      \quad\quad\quad\quad\,\; \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\return{y}}\})\\
      \quad \textbf{\texttt{in}} \, \equote[{\splice[z] + 1}])
    \end{array}$
 \end{source}
 \captionof{listing}{Illustrating the eager dynamic check: eager scope extrusion is caused by the $\return{y}$ expression. Scope extrusion is not immediately detected. Rather, $z$ is bound to $\Var{x}{\mathbb{N}}$. Scope extrusion is reported when $z$ is used to build a larger AST $\equote[{\splice[z]} + 1]$, in a context where $\Var{x}{\mathbb{N}}$ is not declared safe}%
 \label{listing:eager-scope-extrusion-check-eg}
\end{code}

As an example, consider \Cref{listing:eager-scope-extrusion-check-eg}. Eager scope extrusion is caused by the $\return{y}$ program fragment, where $y$ refers to the unbound variable $\Var{x}{\mathbb{N}}$\footnote{For clarity, I do not rename the variables in this example}. Eager scope extrusion is not caught immediately. Rather, $z$ is bound to $\Var{x}{\mathbb{N}}$, and scope extrusion is caught when $z$ is used to build a larger AST, $\equote[{\splice[z]+1}]$, where $\Var{x}{\mathbb{N}}$ is not declared safe in the evaluation context. 

The eager dynamic check also checks at top-level splices, like the lazy dynamic check (\Cref{listing:eager-scope-extrusion-check-eg-tls}). Conceptually, a top-level splice builds a larger, ambient and inert, AST (in \Cref{listing:eager-scope-extrusion-check-eg-tls}, $\texttt{Do}(z_\mathbb{N}, [-], \texttt{Plus}(z_\mathbb{N}, \texttt{Nat}(\texttt{1})))$):

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \textbf{\texttt{do}} \, z \leftarrow \$(\textbf{\texttt{handle}} \; \equote[{\, \lambda x. \,\splice[(\,{{ \textbf{\texttt{extrude}}(\equote[x])}}\,)] \,}] \\
      \quad\quad\quad\quad\,\textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\return{y}}\})\\
      \textbf{\texttt{in}} \, z + 1
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check additionally checks at top-level splices.}%
 \label{listing:eager-scope-extrusion-check-eg-tls}
\end{code}

To the best of my knowledge, the eager dynamic check is a faithful model of the MetaOCaml check, as described by \citet{kiselyov-24}. The model was verified by executing translations of \Cref{listing:eager-scope-extrusion-check-eg,listing:eager-scope-extrusion-check-eg-tls,listing:eager-scope-extrusion-unsafe-no-use,listing:eager-scope-extrusion-unsafe-continue} in BER MetaOCaml N153 (\Cref{section:metaocaml-litmustests}). 

\subsection{Correctness of the Eager Dynamic Check}\label{subsection:eager-dynamic-correctness}
The eager dynamic check is incorrect with respect to eager scope extrusion. Evaluation may result in eager scope extrusion, but the offending AST $n$ may never be used in an unsafe way. Thus, eager scope extrusion goes undetected. 

For example, recall that \sourceLang{} permits non-terminating programs. Consider the \sourceLang{} program in \Cref{listing:eager-scope-extrusion-unsafe}, where $\Omega$ is some non-terminating program that never refers to $z$. After translation, the program reduces to a configuration that exhibits eager scope extrusion ($\return{y}$). However, the program immediately enters into a non-terminating loop, and scope extrusion is never reported.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{do}} \, z \leftarrow (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \,\splice[(\,{{\textbf{\texttt{extrude}}(\equote[x])}}\,)]} \,] \\
      \quad\quad\quad\quad\,\; \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\return{y}}\})\\
      \quad \textbf{\texttt{in}} \, \Omega)
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check does not detect scope extrusion, since $\return{y}$ is followed by a non-terminating loop which never refers to $z$.}%
 \label{listing:eager-scope-extrusion-unsafe}
\end{code}


Non-termination is not the only case in which the eager check does not detect eager scope extrusion. For example, the offending AST could be discarded (\Cref{listing:eager-scope-extrusion-unsafe-no-use}), and therefore never trigger the check.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{handle}} \; \equote[\,{\lambda x. \,\splice[(\,{{\textbf{\texttt{extrude}}(\equote[x])}}\,)]}\,] \\
      \;\;\,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\return{y}}{\equote[\texttt{0}]}}\})
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check additionally does not report eager scope extrusion in the case where the offending AST is discarded.}%
 \label{listing:eager-scope-extrusion-unsafe-no-use}
\end{code}

Finally, the program may recover from scope extrusion by \textit{resuming} a continuation. In \Cref{listing:eager-scope-extrusion-unsafe-continue}, by resuming the continuation, the program restores the captured evaluation context, thus declaring $\Var{x}{\mathbb{N}}$ safe. Only then is $\Var{x}{\mathbb{N}}$ used to build an AST, so the checks pass.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$ (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \,\return{\splice[( \, {{\textbf{\texttt{extrude}}(\equote[x])}} \,)]}} \,] \\
      \;\;\,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {{\continue{k}{y}}}\})
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check additionally does not report cases where the offending AST is used, but only in safe ways. In this case, the continuation restores the context that permits $\Var{x}{\mathbb{N}}$ to be used.}%
 \label{listing:eager-scope-extrusion-unsafe-continue}
\end{code}

% Expanding on \Cref{listing:eager-scope-extrusion-unsafe-continue}, \textbf{\texttt{continue}} returns the AST $\Var{x}{\mathbb{N}}$ to the point where the \textbf{\texttt{extrude}} effect was performed, constructing the well-scoped AST: $\Lam{\Binder{x}{\mathbb{N}}}{\Var{x}{\mathbb{N}}}$.

\citet{kiselyov-14} acknowledges that the eager dynamic check does not catch every instance of eager scope extrusion, but observes that it makes the check more permissive. Since \Cref{listing:eager-scope-extrusion-unsafe,listing:eager-scope-extrusion-unsafe-no-use,listing:eager-scope-extrusion-unsafe-continue} are allowed by the lazy dynamic check, permissiveness makes the eager dynamic check more expressive. 

\subsection{Expressiveness of the Eager Dynamic Check}\label{subsection:eager-dynamic-expressiveness}
The eager dynamic check, however, is not maximally expressive. It reports false positives (e.g.\ \Cref{listing:eager-scope-extrusion-looks-unsafe}).

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$ (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \, {\splice[(\, {{\textbf{\texttt{extrude}}(\equote[x])}} \, )]}}\,] \\
      \;\;\,\,\textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {{\continue{k}{\equote[{\splice[y]} + \texttt{0}]}}}\})
    \end{array}$
 \end{source}
 \captionof{listing}{A program which fails the eager dynamic check. The offending AST ($\Var{x}{\mathbb{N}}$) is used to construct a larger AST in a way that appears to be unsafe $\equote[{\splice[y]+\texttt{0}}]$, but the unsafe AST is then only used in a safe way.}%
 \label{listing:eager-scope-extrusion-looks-unsafe}
\end{code}

In \Cref{listing:eager-scope-extrusion-looks-unsafe}, the offending AST ($\Var{x}{\mathbb{N}}$, bound to $y$) is used in a context where $\Var{x}{\mathbb{N}}$ is not declared safe ($\equote[{\splice[y]} + \texttt{0}]$), and thus the eager dynamic check reports an error. However, if evaluation had been allowed to proceed, the evaluation context binding $\Var{x}{\mathbb{N}}$ (and additionally declaring it safe) would have been restored ($\continue{k}{w}$), and all variables would have been properly scoped. The program \textit{recovers} from a state of eager scope extrusion, and does not exhibit lazy scope extrusion. The eager dynamic check is thus not as expressive as the lazy dynamic check.

More concerningly, the eager dynamic check is unpredictable: it is difficult to characterise its expressiveness without referring to the operational semantics. Compare the program in \Cref{listing:eager-scope-extrusion-unsafe-continue}, which passes the check, and \Cref{listing:eager-scope-extrusion-looks-unsafe}, which \textit{fails} the check. Unfortunately, the following inequation holds:
\[\equote[\splice[e]] \neq_{\splicemode{}} \equote[{\splice[e] + \texttt{0}}]\]
More generally, for program fragments $P$ and $P'$:
\[P[e] =_{\splicemode{}} P'[e] \centernot\implies \equote[{P[\splice[{\equote[e]}]]}] =_{\splicemode{}} \equote[{P'[\splice[{\equote[e]}]]}]\]
% where $E$ is some source-level context (not necessarily an evaluation context). 

One has to appeal to the operational behaviour of the eager dynamic check to explain why these equations do not hold. In my opinion, this exposes too much of the internal operation of the check. 

One possible attempt to make the eager dynamic check more predictable is to change the \splicemode{}-mode elaboration of \textbf{\texttt{return}}, such that each \textbf{\texttt{return}} elaborates into a \textbf{\texttt{check}}:
\[\elaborate{\return{v}}_{\splicemode{}} = \checkfv{\elaborate{v}_{\splicemode{}}}\]
While this restores certain equations (for example, \Cref{listing:eager-scope-extrusion-unsafe-no-use} now reports a scope extrusion error), it breaks others. For example, the following equation (\citep{levy-2003}, Fig.\ 1) no longer holds:
\[\bind{\_}{\return{v}}{e} =_{\splicemode{}} e\]
since the \textbf{\texttt{return}} is elaborated into a \textbf{\texttt{check}}, which $v$ may fail.

\subsection{Efficiency of the Eager Dynamic Check}\label{subsection:eager-dynamic-efficiency}
Additionally, the eager dynamic check is not, in the worst case, more efficient than the lazy dynamic check, since there exist pathological examples, such as when the offending AST is not used to construct a larger AST, but returned at the top-level splice (\Cref{listing:eager-scope-extrusion-check-eg-tls}). However, I hypothesise that in the \textit{common case}, the eager dynamic check detects scope extrusion sufficiently early as to outweigh the checking overhead. This question is an empirical one, and would require further research, outside the scope of the dissertation, to resolve. 

\section{Best-Effort Dynamic Check}\label{section:best-effort-check}
If the lazy dynamic check is too inefficient, and the eager dynamic check too unpredictable, might it be possible to find a ``goldilocks'' solution? Such a check should allow the program in \Cref{listing:eager-scope-extrusion-looks-unsafe}, and be permissive in a predictable way. For example, a check that eagerly detects programs that \textit{must} cause lazy scope extrusion. I call this best-effort scope extrusion:

\begin{definition}[Best-Effort Scope Extrusion]{coreHighlight} A \coreLang{} configuration of the form 
\[\langle t;E;U;M;I\rangle\]  
exhibits best-effort scope extrusion if 
\[ \langle t;E;U;M;I\rangle \to^{*} \langle t';E';U';M';I'\rangle\]
and $\langle t';E';U';M';I'\rangle$ exhibits lazy scope extrusion.
\end{definition}

This section describes a best-effort dynamic check that approximates best-effort scope extrusion, though with false positives. 

The best-effort dynamic check is simple: change all \textbf{\texttt{check}}s to $\textbf{\texttt{check}}_M$s. For example, 
{
  \footnotesize
\[
\begin{array}{rcl}
\elaborate{\lambda x: T^0. \, e}_{\quotemode{}}^{\textbf{BE}} = \bind{x}{\gensym{\erase{T^0}}}{\checkm{(\dlet{x}{\bind{\texttt{body}}{\elaborate{e}_{\quotemode{}}^\textbf{BE}}{\return{\Lam{x}{\texttt{body}}}}})}}
\end{array}\]
}
The $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$ program elaborates into (changes from the eager dynamic check are\textbf{\hl{highlighted}}):
{
  \renewcommand{\varToAST}[1]{\hl{$\textbf{\texttt{check}}_{M}$}\, \texttt{Var}(#1)}
\[\begin{array}{@{}l}
  \bind{x}{\gensym{\mathbb{N}}}{} \\
  {\textbf{\texttt{dlet}}(}{x}, \textbf{\texttt{do}} \; {\texttt{body}_1} \leftarrow {{\hl{\textbf{{\texttt{check}$_M$}}}}}\,(\textbf{\texttt{tls}}({\bind{y}{\gensym{\mathbb{N}}}{{\hl{\textbf{{\texttt{check}$_M$}}}\,(\textbf{\texttt{dlet}}(y,}}} \\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\;\;\,\,
    \textbf{\texttt{do}}\;{\texttt{body}_2} \leftarrow {(\bind{a}{{\varToAST{x}}}{}}\\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,\,
    \bind{b}{{\varToAST{y}}}{}\\
     \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,\,
    \hl{\textbf{\texttt{check}$_M$}}\;{\texttt{Plus}(a, b)}) \, \textbf{\texttt{in}}\\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\;\;\,\,
    \return{\Lam{y}{\texttt{body}_2}}{{))}})) \, \textbf{\texttt{in}}\\
  \quad\quad\quad\;\, {\return{\Lam{x}{\texttt{body}_1}}})
\end{array}\]
}

To understand the best-effort dynamic check, consider \Cref{fig:core-eager-looks-unsafe}, where \Cref{listing:eager-scope-extrusion-looks-unsafe} is elaborated using the eager check into \coreLang{} and simplified for readability (e.g. $\checkfv{t}$ rather than $\bind{x}{t}{\checkfv{x}}$). The failing check is \colorwave[quote]{underlined}. 
\begin{figure}[H]
\begin{center}
  \begin{tikzpicture}
  \begin{scope}[every node/.style={font=\ttfamily\footnotesize}]
    \node[align=left] (example) {$\begin{array}{l}
      \textbf{\texttt{handle}}\\
      \quad \textbf{\texttt{do}} \, x \leftarrow \gensym{\mathbb{N}}  \, \textbf{\texttt{in}} \\ 
       \quad \textbf{\texttt{check}}(\textbf{\texttt{dlet}}({x}, \, \textbf{\texttt{do}} \, {\texttt{body}} \leftarrow \, (\bind{a}{{\varToAST{x}}}{\textbf{\texttt{extrude}}}(a)) \; \textbf{\texttt{in}}\\ 
       \quad\quad\quad\quad\quad\quad\quad\;\, \, {\return{\Lam{x}{\texttt{body}} }}) \\
      \textbf{\texttt{with}} \\ 
      \quad \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \\ 
      \quad\;\, \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\checkfv{\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}}\}
    \end{array}$};
    % (-8,example.south) -- (-2,example.south) -- (2,0) -- (4,0);
  \end{scope}

   \path [draw=quote,snake it, thick]
    ($(example.south) + (-0.8, 0)$) -- ($(example.south) + (2.4, 0)$);

  \begin{scope}[every node/.style={font=\scriptsize}]
    \node[anchor = north, text=quote, align = left] (check-fail) at ($(example.south) + (1, -0.2)$) {\textbf{\texttt{check}} fails, transitioning to $\err$,\\ since $y$ is bound to $\Var{x}{\mathbb{N}}$,\\ which is not declared via \textbf{\texttt{dlet}}};

    \node[anchor = west, align = left, text=comment] at ($(example.east) + (-0.5cm, -0.45cm)$) {However, $w$ is only \\ used in a context \\
    where $\Var{x}{\mathbb{N}}$ is \\declared safe};
  \end{scope}

  \draw[draw=comment, line width = 0.3mm] ($(example.south east) + (-1cm, 0.36cm)$) circle[radius=2mm] node (annote-1) {};

  \begin{scope}[->,>=stealth']
  \draw[line width = 0.3mm, dashed, draw=comment] ($(annote-1.north) + (0cm, 0.1cm)$) -- ($(annote-1.north) + (-0.7cm, 1.4cm)$);
  \end{scope}

  \end{tikzpicture}

\end{center}
\caption{The result of elaborating \Cref{listing:eager-scope-extrusion-looks-unsafe} using the eager check}
\label{fig:core-eager-looks-unsafe}
\end{figure}

The check fails because when $\textbf{\texttt{extrude}}$ performed, the variable $\Var{x}{\mathbb{N}}$ is no longer declared safe in the new evaluation context. Since $y$ is bound to $\Var{x}{\mathbb{N}}$, checking $\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))$ reports an error. The problem is that the continuation $k$ can be used to bind $\Var{x}{\mathbb{N}}$. It is not clear, when the \texttt{Plus} AST is constructed and checked, that eager scope extrusion \textit{must} lead to lazy scope extrusion. 

To make the check more expressive, therefore, it may be useful to temporarily allow $\Var{x}{\mathbb{N}}$ to extrude its scope, delaying error detection until one \textit{must} have lazy scope extrusion. 

The $\textbf{\texttt{check}}_M$ primitive allows $\Var{x}{\mathbb{N}}$ to temporarily extrude its scope. $\textbf{\texttt{check}}_M$ checks for scope extrusion, but turns a blind eye to some set of muted variables $M$. It thus suffices to mute $\Var{x}{\mathbb{N}}$, by adding it to $M$. The \coreLang{} operational semantics mutes and unmutes variables, like $\Var{x}{\mathbb{N}}$, at key points (\Cref{fig:corelang-opsem}, \Cpageref{fig:corelang-opsem}). 

When effects are performed, the variables which are no longer declared safe in the new evaluation context (like $\Var{x}{\mathbb{N}}$) are added to the set of muted variables (\textsc{Eff-Op}):
\[\coreConfiguration{\op{v}}{E_1[\handleWith{E_2}{h}]}{U}{M}{I} \to \coreConfiguration{c[v/x, \text{cont}/ k]}{E_1}{U}{\textcolor{coreHighlight}{M \cup \projfvs{E_2}}}{I'}\]
As an example, consider the reduction of \Cref{fig:core-eager-looks-unsafe}, but where \textbf{\texttt{check}} has been replaced with a $\textbf{\texttt{check}}_M$ (\Cref{fig:core-eager-looks-unsafe-M}).
\begin{figure}[H]
\[\begin{array}{l}
  \textbf{\texttt{handle}} \\
  \quad {\dlet{\Binder{x}{\mathbb{N}}}{
  \bind{\texttt{body}}{\textbf{\texttt{extrude}}(\Var{x}{\mathbb{N}})}{\Lam{\Binder{x}{\mathbb{N}}}{\texttt{body}}}}} \\ 
  \textbf{\texttt{with}} \\ 
  \quad \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \\ 
      \quad\;\, \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\checkm{\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}}\}
\end{array}\]
\caption{\Cref{fig:core-eager-looks-unsafe}, but with $\textbf{\texttt{check}}_M$ in place of $\textbf{\texttt{check}}$}
\label{fig:core-eager-looks-unsafe-M}
\end{figure}
The first reduction step performs the operation, and the configuration steps to the term:
\[\begin{array}{l}
  \bind{w}{\checkm{\texttt{Plus}(\Var{x}{\mathbb{N}}, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}
\end{array}\]
Since the $\dlet{\Binder{x}{\mathbb{N}}}{[-]}$ frame is no longer on the stack, $\checkfv{\texttt{Plus}(\Var{x}{\mathbb{N}}, \texttt{Nat}(\texttt{0}))}$ would throw an error. However, performing the \textbf{\texttt{extrude}} operation additionally \textit{mutes} $\Var{x}{\mathbb{N}}$, and hence $\checkm{\texttt{Plus}(\Var{x}{\mathbb{N}}, \texttt{Nat}(\texttt{0}))}$  would not throw an error. 

When should a variable like $\Var{x}{\mathbb{N}}$ be \textit{unmuted}? When there \textbf{cannot be} any way to resume a continuation $k$ that could bind $\Var{x}{\mathbb{N}}$. A safe approximation is the point where there cannot be \textit{any} bound continuations $k$. This point is identified by tracking the maximal length $I$ of the stack $E$ that was never captured by the handling of an effect (\Cref{fig:unmute-variables-algo}). 

\begin{figure}[t]
  \begin{center}
  \begin{tikzpicture}[square/.style={regular polygon,regular polygon sides=4}]
    \begin{scope}[every node/.style={draw, square, minimum size = 1cm, anchor = west}]
          \node (1) {};
          \node (2) at ($(1.east) - (0.01cm, 0cm)$) {};
          \node (3) at ($(2.east) - (0.01cm, 0cm)$) {};
          \node[fill=comment] (4) at ($(3.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (5) at ($(4.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (6) at ($(5.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (7) at ($(6.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (8) at ($(7.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (9) at ($(8.east) - (0.01cm, 0cm)$) {};
    \end{scope}

 \begin{scope}[->,>=stealth']
  \draw[line width = 0.3mm, draw] ($(8.south) + (1cm, -0.6cm)$) -- ($(4.south) + (0cm, -0.6cm)$) -- ($(4.south) + (0cm, -0.1cm)$);

  \draw[line width = 0.3mm, draw=comment] ($(9.east) + (0.1cm, 0cm)$) -- ($(9.east) + (0.5cm, 0cm)$);
  \end{scope}

  \begin{scope}[every node/.style={font=\ttfamily\bfseries}]
  \node[anchor=west] (op) at ($(8.south) + (1cm, -0.65cm)$) {\textcolor{selected}{op}};
  \node[anchor=west, text=comment, font=\ttfamily\bfseries\footnotesize] (comment) at ($(9.east) + (0.5cm, -0.02cm)$) {stack grows rightwards};

  % \node[anchor=south] (hdl) at ($(5.north) + (0cm, 0.3cm)$) {$E$};
  \end{scope}
  \draw [decorate,decoration={brace,amplitude=5pt,raise=1ex}]
  ($(1.north west)$) -- ($(9.north east)$) node[midway,yshift=2em]{$E$};

  \draw [decorate,decoration={brace,mirror,amplitude=5pt,raise=2ex}]
  ($(1.south west)$) -- ($(3.south east)$) node[midway,yshift=-2em]{$I = 3$};
  \end{tikzpicture}
\end{center}
\caption{An illustration of when variables are unmuted. The stack, $E$, grows rightwards. Effects (e.g. \textbf{\texttt{op}}, in \textbf{\textcolor{selected}{blue}}) are caught by a handler (\textbf{\textcolor{darkgrey}{dark grey}}), capturing a portion of the stack (\textbf{\textcolor{lightgrey}{light grey}}). We track the length of the stack, in \textbf{white}, that is never captured by an operation in this fashion. Frames in \textbf{white} are never able to resume a continuation.}
\label{fig:unmute-variables-algo}
\end{figure}

As an example, consider the program in \Cref{fig:core-unmute-example}, which builds the AST of $\lambda z. \, (\lambda x. \, x + \texttt{0}) (\texttt{1})$.
\begin{figure}
\[\begin{array}{l}
  \textbf{\texttt{check}}_M(\textbf{\texttt{dlet}}(\Binder{z}{\mathbb{N}}, \textbf{\texttt{do}} \; b \leftarrow \, \\ 
  \quad (\textbf{\texttt{do}} \; f \leftarrow \, \textcolor{darkgrey}{\textbf{\texttt{handle}}} \\
  \textcolor{lightgrey}{\;\;\;\,\quad \quad \quad\quad\quad {\dlet{\Binder{x}{\mathbb{N}}}{
  \bind{\texttt{body}}{\textcolor{selected}{\textbf{\texttt{extrude}}(\Var{x}{\mathbb{N}})}}{\Lam{\Binder{x}{\mathbb{N}}}{\texttt{body}}}}}} \\ 
  \textcolor{darkgrey}{\;\;\;\,\quad \quad\quad\quad \textbf{\texttt{with}}} \\ 
  \textcolor{darkgrey}{\;\;\;\,\quad \quad\quad\quad \quad \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}};} \\ 
  \textcolor{darkgrey}{\;\;\;\, \quad \quad\quad\quad \quad \;\, \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\checkm{\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}}\}} \\ 
  \, \quad \textbf{\texttt{in}} \; \textbf{\texttt{do}} \; {a}\leftarrow {\return{\texttt{Nat}(\texttt{1})}}\\
  \, \quad \textbf{\texttt{in}} \, {\checkm{\texttt{App}(f, a)}})\; \\
  \textbf{\texttt{in}} \; \return{\Lam{\Var{z}{\mathbb{N}}}{b}})) 
\end{array}\]
\caption{A \coreLang{} program that generates the AST of $\lambda z. \, (\lambda x. \, x + \texttt{0}) (\texttt{1})$. It is coloured using the convention of \Cref{fig:unmute-variables-algo}.}
\label{fig:core-unmute-example}
\end{figure}
Note that the body of $f$ is the simplified version of \Cref{listing:eager-scope-extrusion-looks-unsafe}. It is coloured using the convention of \Cref{fig:unmute-variables-algo}: \textbf{\textcolor{lightgrey}{light grey}} for the captured stack, \textbf{\textcolor{darkgrey}{dark grey}} for the handler, and \textbf{\textcolor{selected}{blue}} for the effect. The surrounding context (in \textbf{black}) is never captured by the handling of any effect. This context must have no references to the captured continuation $k$, and is identified by $I$.

If the stack was never captured by the handling of an effect (for example, no operations were performed), then $I$ is set to $\top$, $\forall n \in \mathbb{N}, \top \geq n$. Performing an effect can thus \textit{decrease} $I$, but never increase it. This is the side condition on \textsc{Eff-Op}.
\[\begin{array}{ll}\coreConfiguration{\op{v}}{E_1[\handleWith{E_2}{h}]}{U}{M}{I} \to & \coreConfiguration{c[v/x, \text{cont}/ k]}{E_1}{U}{{M \cup \projfvs{E_2}}}{\textcolor{coreHighlight}{I'}} \\ &\textcolor{coreHighlight}{(I' = \textsf{min}(\textsf{len}(E_1), I)} \end{array}\]

During reduction, when the length of the stack is less than, or equals to, $I$, there must not be any remaining references to any continuations $k$, and thus $I$ may be reset to $\top$, and all muted variables may be unmuted. The program in \Cref{fig:core-unmute-example} eventually reduces to the term in \Cref{fig:core-unmute-example-result}. $\hl{[}-\hl{]}$ separates the evaluation context (outside) and the term (inside). At this point, the length of the stack is less than or equals to $I$. It is safe to unmute all muted variables. When there are no muted variables, $\textbf{\texttt{check}}_M$ and \textbf{\texttt{check}} have the same behaviour.
\begin{figure}[H]
\[\begin{array}{l}
  \textbf{\texttt{check}}_M(\textbf{\texttt{dlet}}(\Binder{z}{\mathbb{N}}, \textbf{\texttt{do}} \; b \leftarrow \, \\ 
  \quad (\textbf{\texttt{do}} \; f \leftarrow \hl{[}\; \return{\Lam{\Binder{x}{\mathbb{N}}}{\texttt{Plus}(\Var{x}{\mathbb{N}}, \Nat{\texttt{0}})}}\; \hl{]} \\ 
  \, \quad \textbf{\texttt{in}} \; \textbf{\texttt{do}} \; {a}\leftarrow {\return{\texttt{Nat}(\texttt{1})}}\\
  \, \quad \textbf{\texttt{in}} \, {\checkm{\texttt{App}(f, a)}})\; \\
  \textbf{\texttt{in}} \; \return{\Lam{\Var{z}{\mathbb{N}}}{b}})) 
\end{array}\]
\caption{The result of reducing \Cref{fig:core-unmute-example}. It is now safe to unmute variables.}
\label{fig:core-unmute-example-result}
\end{figure}

However, altering the semantics in such a manner means that any transition could potentially have a side effect: unmuting variables. To keep the semantics standard, and to more closely model the implementation of the check, I associate the act of unmuting with \textbf{\texttt{dlet}} and \textbf{\texttt{tls}}. A transition from \textbf{\texttt{dlet}} conditionally unmutes variables (\textsc{Sec-Dlt} rule, \Cref{fig:corelang-opsem}): 
\[\begin{array}{@{}ll}
  \langle \dlet{\Binder{\alpha}{R}}{\return{n}}; E; U; M; I \rangle \to \langle \return{n}; E; U; \textcolor{coreHighlight}{\emptyset}; \textcolor{coreHighlight}{\top}\rangle & \text{if} \; \textcolor{coreHighlight}{\textsf{len}(E) \leq I}\\
  \langle \dlet{\Binder{\alpha}{R}}{\return{n}}; E; U; M; I \rangle \to \langle \return{n}; E; U; M; I \rangle & \text{if} \; \textcolor{coreHighlight}{\textsf{len}(E) > I}
\end{array}\] 
In \Cref{fig:core-unmute-example-result}, the transition from $\dlet{\Binder{z}{\mathbb{N}}}{\return{n}}$ unmutes variables. Hence, $\Var{x}{\mathbb{N}}$ is still muted when the \texttt{App} constructor is checked, but unmuted when the outer \texttt{Lam} constructor is checked. 

Additionally, transitions from \textbf{\texttt{tls}} \textit{unconditionally} unmute variables, since the evaluation context beyond \textbf{\texttt{tls}} must be inert, and thus can never be captured by a handler (\textsc{Sec-Tls}):
\[\langle \tls{\return{n}}; E; U; M; I \rangle \to \langle {\return{n}}; E; U; \textcolor{coreHighlight}{\emptyset}; \textcolor{coreHighlight}{\top} \rangle\]

Since $\textbf{\texttt{check}}_M$s are at least as permissive as \textbf{\texttt{check}}s, the best-effort dynamic check is at least as expressive as the eager dynamic check.

\subsection{Correctness of the Best-Effort Dynamic Check}\label{subsection:best-effort-correct}
The best-effort dynamic check is correct with respect to  best-effort scope extrusion. The proof is simple: either one of the the non-top-level splice $\textbf{\texttt{check}}_M$s reports an error, or none do. The latter case degenerates to the lazy dynamic check, where the top-level splice $\textbf{\texttt{check}}_M$ must report an error. 

\begin{theorem}[Correctness of the Best-Effort Check]{sourceHighlight} Given a closed, well-typed \sourceLang{} expression $e$, if  $\langle \elaborate{e}; [-]; \emptyset; \emptyset; \top \rangle$ exhibits best-effort scope extrusion 
then there exists $E$, $U$, $M$, $I$ such that \[\langle \elaborate{e}^{\textbf{BE}}; [-]; \emptyset; \emptyset; \top \rangle \to^{*}\langle \err{}; E; U; M; I \rangle\]
\end{theorem}

\subsection{Expressiveness of the Best-Effort Dynamic Check}\label{subsection:best-effort-expressive}
The best-effort dynamic check is not maximally expressive. In particular, it does not allow the program in \Cref{listing:best-effort-imperfect}. 

\begin{code}
  \begin{source}
    $
    \begin{array}{l}
      \$(\langle \langle \lambda x. \$ (\textbf{\texttt{handle}} \, \equote[{\lambda y. \$(\textbf{\texttt{op}}(y); \return{y})}]\\
      \quad\quad\quad\quad\textbf{\texttt{with}} \, \{ \returnHandler{u}{\return{\equote[\texttt{0}]}}; \opHandler{z}{k}{\return{z}}\})\rangle\rangle;\\
      \;\, \equote[{\texttt{1}}])
    \end{array}
    $
  \end{source}
  \captionof{listing}{The best-effort scope extrusion check reports false positives. This program attempts to build the AST $\lambda x.\return{y}$, where $y$ has extruded its scope, but then throws it away, returning the AST of $\texttt{1}$.}%
  \label{listing:best-effort-imperfect}
\end{code}

The program in \Cref{listing:best-effort-imperfect} attempts to build the AST $\lambda x.\return{y}$, where $y$ has extruded its scope, but then throws it away, returning the AST of \texttt{1}. Critically, the constructor of the outer lambda, $\lambda x. [-]$, is never captured by any effect. Hence, the program eventually reduces to a configuration: 
\[\langle \dlet{\Binder{x}{\mathbb{N}}}{\return{\Lam{\Binder{x}{\mathbb{N}}}{\Var{y}{\mathbb{N}}}}}; E[\textbf{\texttt{check}}[-]]; U; \{\Var{y}{\mathbb{N}}\} ; I \rangle\]
where $\textsf{len}(E[\checkm{[-]}]) < I$. The transition from this configuration unmutes $\Var{y}{\mathbb{N}}$, and the surrounding $\textbf{\texttt{check}}_M$ fails, as $\Var{y}{\mathbb{N}}$ is free, unmuted, and not declared safe in $E$.

It is possible to characterise the expressiveness of the best-effort check, via a ``Cause for Concern'' property. Informally, assume the best-effort check reports an error, and let the offending AST be $n$. Now re-wind to the point of the failing check, and consider an alternative execution where all the $\textbf{\texttt{check}}_M$s are erased (turned into $\textbf{\texttt{return}}$s). In this counter-factual execution, all ASTs $m$ that are constructed from $n$ have at least one variable that is not declared safe in its evaluation context. Consequently, in \Cref{listing:best-effort-imperfect}, the only way to safely use $\lambda x.\return{y}$ is to throw it away. 

\begin{theorem}[Cause for Concern Property]{sourceHighlight}\label{thm:best-effort-cause-for-concern} Assuming a closed,well-typed \sourceLang{} expression $e$, if
  \begin{enumerate}
    \item $\exists.$ $E$, $U$, $M$, $I$ such that $\langle \elaborate{e}^{\textbf{BE}}; [-];\emptyset; \emptyset; \top \rangle \to^{*}\langle \checkm{n}; E; U; M; I \rangle$,
    and \\$\langle \checkm{n}; E; U; M; I \rangle \to \langle \err{}; E; U; M; I \rangle$
  \end{enumerate}
Then for all $i \in \mathbb{N}$, if 
\begin{enumerate}
  \item[2.] $\langle \return{n}; \textsf{erase-checks}(E); U; M; I \rangle \to^{i} \langle \return{m}; E'; U'; M'; I' \rangle$
  \item[3.] and $n$ a subtree of $m$,  
\end{enumerate}
then $\freevars{m} \not\subseteq \projfvs{E'}$  
\end{theorem}

The proof of \Cref{thm:best-effort-cause-for-concern} is by contradiction. By assumption (1) there must be at least one variable, call it $\Var{x}{R}$, that is free in $n$ and not declared safe in $E$. Assume for the sake of contradiction that $\freevars{m} \subseteq \projfvs{E'}$. Then, by assumption (3), the frame $\dlet{\Binder{x}{R}}{[-]}$ must be in $E'$. Note that we only have to consider terms reachable via elaboration. By definition of elaboration, the only way to push the frame $\dlet{\Binder{x}{R}}{[-]}$ on $E'$ is by resuming a continuation containing $\dlet{\Binder{x}{R}}{[-]}$. But then we must have had access to the resumed continuation in $E$. In turn, this implies $I < \textsf{len}(E)$, and thus $\Var{x}{R}$ would not have been unmuted. Consequently, $\checkm{n}$ would not have failed because of $\Var{x}{R}$. This contradicts assumption (1). 

The expressiveness of the eager dynamic check cannot be characterised by the Cause for Concern property, with \Cref{listing:eager-scope-extrusion-looks-unsafe} being a counter-example. Hence, the best-effort dynamic check is \textbf{more} expressive, and more \textbf{predictably} expressive, than the eager dynamic check. 

\subsection{Efficiency of the Best-Effort Dynamic Check}\label{subsection:best-effort-efficient}
The best-effort dynamic check is no more efficient than the eager dynamic check: whenever a $\textbf{\texttt{check}}_M$ reports an error, so too must a $\textbf{\texttt{check}}$, and both elaborations insert checks in the same positions. Like the eager dynamic check, I hypothesise that the best-effort check is more efficient in the common case than the lazy check.

% While I do not justify that the Eager and Best-Effort checks are more efficient than the Lazy check, the calculus \textit{does} give a mechanism for quantifying 

\section{Refined Environment Classifiers}\label{section:refined-environment-classifiers-formal}
% Recall the objective of this chapter: to evaluate \calculusName{} as a common language for encoding, and evaluating, different policies for moderating scope extrusion. I have encoded three dynamic checks into \calculusName{}, and considered their correctness, expressiveness, and efficiency. The evaluation was comparative: I was able to conclude that the best-effort check was more expressive than the eager dynamic check, but less expressive than the lazy dynamic check. The comparative evaluation was facilitated by \sourceLang{}. 

The method of refined environment classifiers (\Cref{subsubsection:refined-environment-classifiers}, \Cpageref{subsubsection:refined-environment-classifiers}) presents a static approach to preventing scope extrusion.\ \citet{isoda-24} introduce a calculus with code combinators (rather than quotes and splices) and algebraic effects, whose interaction is moderated via refined environment classifiers. This section demonstrates that refined environment classifiers may be added to \sourceLang{}, creating a new language, \recLang{}. 

\recLang{} shares a syntax with \sourceLang{}, but augments the \sourceLang{} type system with a \textbf{simplified} version of \citeauthor{isoda-24}'s type system:

\begin{enumerate} 
  \item \sourceLang{} types are straightforwardly extended, by annotating all level $-1$ \textsf{Code} types with a classifier (\Cref{fig:rec-source-types}).
  \item Similarly, level $0$ types are associated with a classifier. However, following \citet{isoda-24}, this association is indirect: for level $0$ types, classifiers are associated with the judgement rather than annotated onto the type (\Cref{fig:refined-env-classifiers-source-typing-rules}). 
\end{enumerate}
\newcommand{\recCoreLang}{\coreLang{}$^\gamma$}
\recLang{} elaborates into \recCoreLang{}, which is a simple extension of \coreLang{}. Classifiers show up in the syntax, not the types:
\begin{enumerate}
  \item \recCoreLang{} formal parameters are annotated with classifiers $\alpha_R^{\gamma}$ 
  \item Since elaboration does not require any dynamic scope extrusion checking machinery, \recCoreLang{} does not have \textbf{\texttt{check}} (and $\textbf{\texttt{check}}_M$), \textbf{\texttt{dlet}}, \textbf{\texttt{tls}}, and \textbf{\texttt{err}}.\ Consequently, \recCoreLang{} configurations are of the form $\langle t;E;U\rangle$.
\end{enumerate}

For ease of reasoning, it is helpful to define the notion of an \textbf{extended} \recLang{} type.
\begin{definition}[Extended \recLang{} type]{recHighlight}\label[definition]{dfn:extended-source-type}
An \textbf{extended} source type is either:
  \begin{enumerate}
    \item A level $-1$ type, for example, $(\textsf{Code}(\mathbb{N}^{0})^{\gamma})^{-1}$ or 
    \item A level $0$ type annotated with a classifier, for example, $\mathbb{N}^{0} (\gamma)$. 
    \item A level $0$ formal parameter type, which is a level $0$ value type (like $\mathbb{N}^{0} (\gamma)$) annotated with an \underline{underline} to indicate that it is elaborated into an \textsf{FParam} type, (\underline{$\mathbb{N}^{0} (\gamma)$})
  \end{enumerate}
\end{definition}

\begin{figure}
  \begin{rec-desc}
    % $\begin{array}{lllr}
    % {\textbf{\large {Effects Row}}}\\\\
    % % \textbf{Run-Time} & \xi ::= \cdot \mid \xi \cup \{ \textsf{op}_i^{0}\} \\
    % \textbf{Compile-Time} & \Delta ::= \cdot \mid \Delta \cup \{ \textsf{op}_i^{-1}\} \\\\
    % \end{array}$

% \vspace{5mm}
{\textbf{\large {Types (Refined Environment Classifiers)}}}\\

  $\begin{array}{@{}lllr}
    % \textbf{Level 0} & \text{Values} & T^0 ::= \mathbb{N}^0 & \text{\footnotesize{naturals}} \\ \vspace{0.4mm}
    % && \quad\quad\,\, \mid {(\functionType[\xi]{S^0}{T^{0}})}^{0} & \text{\footnotesize{functions}} \\ \vspace{0.4mm}
    % && \quad\quad\,\, \mid {(\continuationType[\xi]{S^0}{T^{0}})}^{0} & \text{\footnotesize{continuations}} \\\vspace{0.4mm}
    % & \text{Computations} & T^0 \, ! \, \xi \\\vspace{0.8mm}
    %  && \mid T^0 \, ! \,  \Delta;\xi & \\\vspace{0.8mm}
    % & \text{Handlers} & (\handlerType{S^{0} \, ! \, \xi}{T^{0} \, ! \, \xi'})\, !\, \Delta\\ \\

    \textbf{Level $-$1} & \text{Values} & T^{-1} ::= 
    % \mathbb{N}^{-1} & \text{\footnotesize{naturals}} \\ \vspace{0.4mm}
    % && \quad\quad\quad \mid {(\functionType{S^{-1}}{T^{-1}})}^{-1} & \text{\footnotesize{functions}} \\\vspace{0.4mm}
    % && \quad\quad\quad \mid {(\continuationType{S^{-1}}{T^{-1}})}^{-1} & \text{\footnotesize{continuations}} \\\vspace{0.4mm}
    \ldots \mid {({\textsf{Code}({T^{0} \, ! \, \xi})}^{\textbf{\hl{$\gamma$}}})}^{-1} \\
    % \vspace{0.8mm}
    % & \text{Computations} & T^{-1} \, ! \, \Delta \\\vspace{0.8mm}
    % & \text{Handlers} & \handlerType{S^{-1} \, ! \, \Delta}{T^{-1} \, ! \, \Delta'}
  \end{array}$
  \end{rec-desc}
  \caption{\recLang{} types. The only change from \sourceLang{} is that \textsf{Code} types are now annotated with an environment classifier $\gamma$, which is \textbf{\hl{highlighted}}.}
  \label{fig:rec-source-types}
\end{figure}

Contexts $\Gamma$ must be well-formed (\citep{isoda-24}, Fig. 8), and a well-formed context must contain the least classifier $\gamma_{\bot}$. The definition of closed well-typed expression is adapted to reflect this:

\begin{definition}[Well-typed closed expression]{recHighlight}\label[definition]{dfn:well-typed-exp-rec}
  $e$ is a well-typed expression if $\gamma_{\bot} \vdash_{\compilemode}^{\gamma_{\bot}} e : T^{0} \, ! \, \emptyset; \emptyset$
\end{definition}

Most typing rules are straightforwardly adapted, with key rules listed in \Cref{fig:refined-env-classifiers-source-typing-rules}. 

The \compilemode{}$\mid$\quotemode{}-\textsc{Lambda} rule corresponds to \textsc{C-Abs} in the refined environment classifier literature. Recall that classifiers formalise the notion of scope (\Cref{section:refined-environment-classifiers-formal}) The $\gamma' \notin \Gamma$ constraint ensures that introducing a binder $\lambda x.\_$ introduces a new scope, via a \textbf{fresh} classifier. This is necessary for correctness. The \compilemode{}$\mid$\quotemode{}\textsc{-Sub} and $\splicemode{}\textsc{-Sub}$ subtyping rules capture the intuition that, to show a term is well-scoped in some nested scope ($\gamma$, where $\gamma' \sqsubseteq \gamma$), it suffices to show that it is well-scoped in any of its parents ($\gamma'$), see \Cref{fig:refined-enviroment-classifiers-basic}, \Cpageref{fig:refined-env-classifiers-source-typing-rules}.

Following \citeauthor{isoda-24}, handlers and continuations are restricted to \textsf{Code} types; However, types and typing rules are further simplified by eliminating polymorphism. 

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{handle}} \, {\bind{x}{\textbf{\texttt{genlet}}(\equote[e])}{\equote[{\splice[x]} + {\splice[x]}]}} \\
      \quad \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {u}; \textbf{\texttt{genlet}}(y, k) \mapsto {\equote[\; (\lambda z. \, \$(\continue{k}{\equote[z]})) \; y \;]}\})
    \end{array}$
 \end{source}
 \captionof{listing}{The program uses handlers to perform let-insertion, generating $(\lambda z. z + z)(e)$ rather than $e + e$. It is hard to type this in \recLang{} without polymorphism.}%
 \label{listing:refined-environment-classifiers-let-insertion}
\end{code}

\citeauthor{isoda-24}'s typing rules for handlers and continuations are polymorphic over the classifier, to allow for \textit{let-insertion} \citep{yallop-2019}. Let-insertion aims to reduce duplication in the generated code. Rather than generating the same AST multiple times (e.g.\ $\texttt{Plus$(n, n)$}$), let-insertion generates a let-binding, duplicating the variable rather than the AST (e.g.\ $\texttt{Do$(x_\mathbb{N}, n, \texttt{Plus$(\Var{x}{\mathbb{N}}, \Var{x}{\mathbb{N}})$})$}$). This generates more compact code. Let-insertion can be easily implemented with effects. For example, in \Cref{listing:refined-environment-classifiers-let-insertion}, the \textbf{\texttt{genlet}} effect is used to generate $(\lambda z. z+z) e$, rather than $e + e$. Since \efflang{} is a call-by-value calculus (\Cref{fig:efflang-opsem}), let-insertion ensures $e$ is only evaluated once. Polymorphism helps to prove that \Cref{listing:refined-environment-classifiers-let-insertion} is safe. The continuation $k$ is resumed under a binder (which introduces a classifier). Thus, the continuation $k$ should be polymorphic over classifiers. For similar reasons, \citeauthor{isoda-24}'s type system demands that handlers are polymorphic over classifiers. For example, a more faithful transcription of \citeauthor{isoda-24}'s handler type would have the form:
\[\forall \gamma. \compiletimetype{(\handlerType{\effectType[\Delta_1]{\compiletimetype{(\textsf{Code}(\effectType[\xi_1]{S})^{\gamma})}}}{\effectType[\Delta_2]{\compiletimetype{(\textsf{Code}(\effectType[\xi_2]{T})^{\gamma})}}})}\]

Reasoning about the correctness of polymorphic typing rules, however, is complex. It is even more complex in \recLang{}. Like \sourceLang{}, \recLang{} does not have an operational semantics, but is elaborated into \recCoreLang{} terms. Thus, it is difficult to reason directly about the \recLang{} type system via progress and preservation. One has to appeal to alternative techniques, like Tait-style logical relations \citep{tait-67}, increasing the complexity of reasoning.

This evaluation focuses on extending \calculusName{}, not on refined environment classifiers. Thus, I choose to simplify the type system, and minimise the complexity of reasoning. 

It is unclear whether \citeauthor{isoda-24}'s system allows for non-termination. Once again, to simplify reasoning, I force effect signatures to be well-founded and, in particular, not recursive. Thus, all well-typed programs must thus terminate \citep{kammar-2013}. 

Proof of correctness relies on a weakening lemma. As types are stratified into two levels, and into value, computation, and handler types, there are various sub-lemmas, for example:

\newcommand{\rcqtypejudge}[4][\Gamma]{{#1} \vdash_{\compilemode \mid \quotemode}^{#2} {#3} : {#4}}
\newcommand{\rctypejudge}[4][\Gamma]{{#1} \vdash_{\compilemode}^{#2} {#3} : {#4}}
\newcommand{\rqtypejudge}[4][\Gamma]{{#1} \vdash_{\quotemode}^{#2} {#3}: {#4}}
\newcommand{\rstypejudge}[3][\Gamma]{{#1} \vdash_{\splicemode} {#2} : {#3}}

\begin{lemma}[Weakening for Level 0 Values]{recHighlight}
  If $\rcqtypejudge{\gamma}{e}{T^0}$ then
  \begin{enumerate}
    \item $\rcqtypejudge[\Gamma, (x:S^0)^{\gamma'}]{\gamma}{e}{T^0}$, for arbitrary $\gamma' \in \Gamma$
    \item $\rcqtypejudge[\Gamma, (x:S^{-1})]{\gamma}{e}{T^0}$, where $S$ only refers to classifiers $\gamma \in \Gamma$
    \item $\rcqtypejudge[\Gamma, \gamma']{\gamma}{e}{T^0}$, for arbitrary $\gamma' \notin \Gamma$
    \item $\rcqtypejudge[\Gamma, \gamma' \sqsubseteq \gamma'']{\gamma}{e}{T^0}$, for arbitrary $\gamma', \gamma'' \in \Gamma$
  \end{enumerate}
  The side conditions ensure weakening produces a well-formed context
\end{lemma}
% \vspace{-\baselineskip}
% \begin{lemma}[Weakening for Level $-1$ Values]{recHighlight}
%   If $\stypejudge{e}{T^{-1}}$ then
%   \begin{enumerate}
%     \item $\stypejudge[\Gamma, (x:S^0)^{\gamma'}]{e}{T^0}$ for arbitrary $\gamma' \in \Gamma$
%     \item $\stypejudge[\Gamma, (x:S^{-1})]{e}{T^{-1}}$ 
%     \item $\stypejudge[\Gamma, \gamma']{e}{T^{-1}}$, for arbitrary $\gamma' \notin \Gamma$
%     \item $\stypejudge[\Gamma, \gamma' \sqsubseteq \gamma'']{e}{T^{-1}}$, for arbitrary $\gamma', \gamma'' \in \Gamma$
%   \end{enumerate}
% \end{lemma}
The proof of the weakening lemma is by induction on the typing derivation.

\recLang{} elaborates into \recCoreLang{}. Elaboration is similar to \Cref{section:elaboration}, with the following changes:
\begin{enumerate}
  \item Elaboration of types erases classifiers. For example,  $\elaborate{\mathbb{N}^0(\gamma)} = \textsf{AST}(\mathbb{N})$.
  \item Elaboration of context entries is extended to carry proof-theoretic terms e.g. $\gamma$ and $\gamma \sqsubseteq \gamma'$.
  \item Elaboration of terms assumes binders have been annotated with an extended source type, and does \textit{not} erase classifiers. \\
  For example, $\elaborate{\lambda x: {\mathbb{N}^0({\gamma})}. \; e}_{\compilemode{}} = \bind{x}{\gensym{\mathbb{N}^{\gamma}}}{\ldots}$
  \item Elaboration of top-level splice $\elaborate{\splice}_{\compilemode{}}$ does not insert \textbf{\texttt{tls}}.
\end{enumerate}

% To the best of my knowledge, this is the first explicit presentation of refined environment classifiers in a calculus with quotation and splices rather than code combinators. 

\begin{figure}
  \begin{rec-desc}
  {\large\textbf{Refined Environment Classifiers Typing Rules}}\\
  \textit{Selected Rules}

  \begin{center}
  \begin{minipage}[t]{0.3\textwidth}
    \centering
    $\inferrule[(\compilemode{}$\mid$\quotemode{}-Var)]{(x: T^0)^\gamma \in \Gamma}{\rcqtypejudge{\gamma}{x}{\runtimecomptype{T^0}{\Delta}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.7\textwidth}
    \centering
$\inferrule[(\compilemode{}$\mid$\quotemode{}-Lambda)]{\rcqtypejudge[\Gamma, \gamma', \gamma \sqsubseteq \gamma', (x: S)^{\gamma'}]{\gamma'}{e}{\runtimecomptype{T}{\Delta;\xi}} \\
\gamma \in \Gamma \\
\gamma' \notin \Gamma
}{\rcqtypejudge{\gamma}{\lambda x.e}{\runtimecomptype{(\functionType[\xi]{S}{T})}{\Delta}}}$
\end{minipage}

\vspace{5mm}

\begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(\splicemode{}-Op)]
    {\stypejudge{v}{\compiletimetype{S}} \\ \texttt{op}: \compiletimetype{S} \rightarrow \compiletimetype{\textsf{Code}(\effectType[\xi]{T})^{\gamma}} \in \Sigma \\ \texttt{op} \in \Delta }
    {\stypejudge{\op{v}}{\effectType{\compiletimetype{\textsf{Code}(\effectType[\xi]{T})^{\gamma}}}}}$
  \end{minipage}

\vspace{5mm}

  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(\splicemode{}-Continue)]
    {\stypejudge{v_1}{\compiletimetype{\continuationType{\compiletimetype{\textsf{Code}(\effectType[\xi_1]{S})^{\gamma}}}{\compiletimetype{\textsf{Code}(\effectType[\xi_2]{T})^{\gamma'}}}}} \\ \stypejudge{v_2}{\compiletimetype{\textsf{Code}(\effectType[\xi_1]{S})^{\gamma}}}}
    {\stypejudge{\continue{v_1}{v_2}}{\effectType{\compiletimetype{\textsf{Code}(\effectType[\xi_2]{T})^{\gamma'}}}}}$
  \end{minipage}

\vspace{5mm}

\begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(\splicemode{}-Handle)]
    {\stypejudge{e}{\effectType{\compiletimetype{\textsf{Code}(\effectType[\xi]{S})^{\gamma}}}} \\ \stypejudge{h}{\compiletimetype{\handlerType{\effectType[\Delta_1]{\compiletimetype{(\textsf{Code}(\effectType[\xi_1]{S})^{\gamma})}}}{\effectType[\Delta_2]{\compiletimetype{(\textsf{Code}(\effectType[\xi_2]{T})^{\gamma})}}}}} \\ \forall \textsf{op} \in \Delta_1 \setminus \Delta_2. \, \textsf{op} \in \textsf{dom}(h)}
    {\stypejudge{\handleWith{e}{h}}{\effectType[\Delta_2]{\compiletimetype{\textsf{Code}(\effectType[\xi_2]{T})^{\gamma}}}}}$
  \end{minipage}

  \vspace{5mm}

\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\compilemode{}$\mid$\quotemode{}-Splice)]{\stypejudge[\Gamma]{e}{\effectType{\textsf{Code}(T \, ! \, \xi)^{\gamma}}}}{\rcqtypejudge{\gamma}{\splice}{\runtimecomptype{T}{\Delta ; \xi}}}$
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\splicemode{}-Quote)]{\rqtypejudge{\gamma}{e}{\runtimecomptype{T}{\Delta ; \xi}}}{\stypejudge[\Gamma]{\equote}{\textsf{Code}(T \, ! \, \xi)^{\gamma} \, ! \, \Delta}}$
\end{minipage}

  \vspace{5mm}

\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\compilemode{}$\mid$\quotemode{}-Sub)]{\rcqtypejudge{\gamma}{\splice}{\runtimecomptype{T}{\Delta ; \xi}} \\ \Gamma \vDash \gamma \sqsubseteq \gamma'}{\rcqtypejudge{\gamma'}{e}{\runtimecomptype{T}{\Delta ; \xi}}}$
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\splicemode{}-Sub)]{\stypejudge[\Gamma]{e}{\textsf{Code}(T \, ! \, \xi)^{\gamma} \, ! \, \Delta} \\ \Gamma \vDash \gamma \sqsubseteq \gamma'}{\stypejudge[\Gamma]{e}{\textsf{Code}(T \, ! \, \xi)^{\gamma'} \, ! \, \Delta}}$
\end{minipage}

\end{center}
\end{rec-desc}

\caption{Selected typing rules for refined environment classifiers. The \compilemode{}$\mid$\quotemode{}-\textsc{Lambda} rule corresponds to \textsc{C-Abs} in the refined environment classifier literature. Following \citeauthor{isoda-24}, handlers and continuations are restricted to \textsf{Code} types; However, unlike \citeauthor{isoda-24}'s system, typing rules are not polymorphic over classifiers.}
\label{fig:refined-env-classifiers-source-typing-rules}
\end{figure}

\subsection{Correctness of Refined Environment Classifiers}\label{subsection:rec-formal-correctness}
This section shows that \recLang{} can be used to formally reason about correctness, by proving that every well-typed \recLang{} term returns a well-scoped AST on termination (\Cref{thm:refined-env-classifiers-correct}). 

\begin{theorem}[Correctness of Refined Environment Classifiers]{recHighlight}\label{thm:refined-env-classifiers-correct}
If $\gamma_\bot \vdash ^{\gamma_\bot}_{\compilemode{}} e: T^0 \, ! \, \emptyset ; \emptyset $, and $\elaborate{e}_{\compilemode{}} = t$, \\
\noindent{}then for some $U$, $\langle t;[-]; \emptyset \rangle \to^{*} \langle \return{n}; [-] ; U \rangle$, and $\freevars{n} = \emptyset$
\end{theorem}

The proof of \Cref{thm:refined-env-classifiers-correct} is via a Tait-style logical relation. A logical relation is useful to show that typing guarantees are maintained by elaboration \citep{benton-09}.

\begin{figure}
\begin{rec-desc}
  {\large\textbf{The $\scoped{T}$ Logical Relation}}
  \vspace{5mm}

  $
  \begin{array}{@{}lllr}
    \textbf{Normal Forms} \\\vspace{2mm}
    n \in \scoped{\mathbb{N}^{-1}} & \triangleq & n \in \mathbb{N} \\ 
    n \in \scoped{{T}^{0}(\gamma)} & \triangleq & \cdot \vdash \elaborate{n} \in \elaborate{T^{0} (\gamma)} \text{ and } \Theta \vdash \freevars{n} \subseteq \textsf{permitted}(\gamma) \\\vspace{2mm}
    && \textit{(symmetric for $(\textsf{Code}(T^0)^{\gamma})^{-1}$, $\effectType[\xi]{T^{0}} (\gamma)$, etc) }\\\vspace{2mm}
    n \in \scoped{\underline{{T}^{0}(\gamma)}} & \triangleq & \varToAST{n} \in \scoped{\effectType{T^{0}} (\gamma)} \\ \vspace{2mm}
    n \in \scoped{(\functionType{{S}^{-1}}{{T}^{-1}})^{-1}} & \triangleq & \forall n' \in \scoped{{S}^{-1}}, n \, n' \in \scoped{\effectType{T^{-1}}} \\ \vspace{2mm}
    n \in \scoped{(\continuationType{{S}^{-1}}{{T}^{-1}})^{-1}} & \triangleq & \forall n' \in \scoped{{S}^{-1}}, \continue{n}{n'} \in \scoped{\effectType{T^{-1}}} \\\\ \vspace{2mm}
    \textbf{Handlers} \\
    h \in \scoped{(\handlerType{\effectType[\Delta_1]{{S}^{-1}}}{\effectType[\Delta_2]{{T}^{-1}}})^{-1}} & \triangleq & \text{if } h = \returnHandler{x}{t_{\text{ret}}}\\ \vspace{2mm}
    && \quad \forall n' \in \scoped{{S}^{-1}}, t_{\text{ret}}[n'/x] \in \scoped{\effectType[\Delta_2]{T^{-1}}} \\
    && \text{else } h = h'; \opHandler{x}{k}{t_{\text{op}}}, \textsf{op}: A^{-1} \to B^{-1} \\
    && \quad h' \in \scoped{(\handlerType{\effectType[\Delta_1]{{S}^{-1}}}{\effectType[\Delta_2]{{T}^{-1}}})^{-1}} \text{ and}\\ 
    && \quad \forall n \in \scoped{{A}^{-1}}, n' \in \scoped{\continuationType[\Delta_2]{{B}^{-1}}{T^{-1}}}, \\ && \quad t_{\text{op}}[n/x, n'/k] \in \scoped{\effectType[\Delta_2]{T^{-1}}}\\\\
  \end{array}
$

\textbf{Terms}\\
{\scriptsize{\textit{In the following, let $\effectType{\tau}$ be shorthand for any of $\effectType{T^{0}} (\gamma)$, $\effectType[\Delta; \xi]{T^{0}} (\gamma)$, $\effectType{(\handlerType{\effectType[\xi_1]{S^0}}{\effectType[\xi_2]{T^0}})^{0}} (\gamma)$, or $\effectType{T^{-1}}$}}}\\

$\scoped{\effectType{\tau}} \hspace{2mm} \triangleq \hspace{2mm}$ The smallest property on terms $t$ such that 
\begin{enumerate}
  \item For arbitrary $U$ consistent with $t$, exists $U'$ such that $\langle t;[-];U \rangle \to^{*} \langle \return{n}; [-]; U' \rangle$, such that $U'$ consistent with $n$, and $n \in \scoped{\tau}$ 
  \item For arbitrary $U$ consistent with $t$, exists $U'$ such that $\langle t;[-];U \rangle \to^{*} \langle \op{n}; E; U' \rangle \not\to$, $U'$ consistent with $E[\op{n}]$, and 
  \begin{enumerate}
    \item $\textsf{op}: A^{-1} \to B^{-1}$,
    \item $n \in \scoped{A^{-1}}$, and 
    \item for all $n' \in \scoped{B^{-1}}$, $E[n'] \in \scoped{\effectType{\tau}}$
  \end{enumerate}
  % \item $t = E[t']$, $E[t']$ not stuck, and for all $U$, there exists $t'', E', U'$ such that $\langle t';E;U \rangle \to \langle t'';E';U' \rangle$ 
\end{enumerate}
Where, in this context, consistent with $t$ means that for all $\Var{\alpha}{R}$ or $\Binder{\alpha}{R} \in t$, $\alpha \in U$. This side condition ensures that we use \textbf{\texttt{mkvar}} correctly.
\end{rec-desc}
\caption{The definition of the \textsf{Scoped} logical relation. Most definitions are standard. The logical relation on terms is defined as a least fixed point, following the definitions by \citet{plotkin-2025} and \citet{kuchta-2023}.}
\label{fig:logical-relation-defn}
\end{figure}

The definition of the logical relation, \textsf{Scoped}, is presented in \Cref{fig:logical-relation-defn}. \textsf{Scoped} is defined on core language (\coreLang{}) terms, and is indexed by:
\begin{enumerate}
  \item A context of proof-theoretic terms $\Theta$. Given a context $\Gamma$, one can project out only the proof theoretic terms $\pi_{\gamma}({\Gamma})$. For example, given 
  \[\Gamma = \gamma_\bot, \gamma_1, \gamma_\bot \sqsubseteq \gamma_1, \textcolor{comment}{(x:\mathbb{N}^0)^{\gamma_1}}, \gamma_2, \gamma_1 \sqsubseteq \gamma_2,  \textcolor{comment}{y:(\textsf{Code}(\mathbb{N}^0 \, ! \, \emptyset)^{\gamma_2})^{-1}}\]
  the proof theoretic part of the context is
  \[\pi_{\gamma}({\Gamma}) = \gamma_\bot, \gamma_1, \gamma_\bot \sqsubseteq \gamma_1, \gamma_2, \gamma_1 \sqsubseteq \gamma_2 \]
  which is an instance of $\Theta$.
  \item An \textbf{extended} \recLang{} type (\Cref{dfn:extended-source-type}). 
\end{enumerate}

The two important definitions are the relation on the $T^{0} (\gamma)$ value type ($\scoped{T^{0} (\gamma)}$), and the relation on terms ($\scoped{\effectType{\tau}}$). 

For a normal form $n$ to be in $\scoped{T^{0} (\gamma)}$, $n$ must be of type $\textsf{AST}(\erase{T^0})$ \textbf{and} the free variables of $n$ need to be permitted by $\gamma$ (permissibility was defined in \Cref{subsubsection:refined-environment-classifiers}, \Cpageref{subsubsection:refined-environment-classifiers}). Recall that the definition of permissibility assumes some known partial order on classifiers, e.g. $\gamma' \sqsubseteq \gamma$. The partial order is carried by the index $\Theta$. 

$\scoped{\effectType{\tau}}$ is defined as a least fixed point, following the definitions by \citet{plotkin-2025} and \citet{kuchta-2023}. Defining the logical relation as a fixed point gives rise to the principle of \textsf{Scoped}-Induction:

\begin{definition}[\textsf{Scoped}-Induction]{recHighlight}
  For some property $\Phi$ on closed terms of type $\elaborate{\effectType{\tau}}$, if
  \begin{enumerate}
    \item $\langle t; [-]; U \rangle \to^{*} \langle \return{n};[-];U' \rangle$ implies $\Phi(t)$
    \item $\langle t; [-]; U \rangle \to^{*} \langle \op{n};E;U' \rangle \not\to$, with $\textsf{op}: A^{-1} \to B^{-1}$, $n \in \scoped{A^{-1}}$, and for arbitrary $n' \in \scoped{B^{-1}}$, $\Phi(E[n'])$ implies $\Phi(t)$
    % \item For every non-stuck $E[t]$, $\Phi(E[t])$ assuming for all $U$, $\langle t;E;U \rangle \to \langle t';E';U' \rangle$ implies $\Phi(E'[t'])$
  \end{enumerate}
  Then for all $t \in \scoped{\effectType{\tau}}$, $\Phi(t)$
\end{definition}

The proof additionally relies on a closure lemma \citep{kuchta-2023}, and a notion of closed substitution $\rho \vDash \Gamma$. Care must be taken with substitution of level-$0$ variables, since these should be in the logical relation for \textsf{FParam}s rather than \textsf{AST}s (note the second clause in \Cref{dfn:closed-substitution}).

\begin{lemma}[Closure under Anti-Reduction]{recHighlight}\label[lemma]{lemma:closure-reduction}
  If $\langle t;E;U \rangle \to^{*} \langle t';E';U' \rangle$ and $E'[t'] \in \scoped{\effectType{\tau}}$ then $E[t] \in \scoped{\effectType{\tau}}$
\end{lemma}
% \vspace{-\baselineskip}
% \begin{lemma}[Weakening]{sourceHighlight}
%   If $\Theta'$ extends $\Theta$ and $t \in \scoped{\effectType{\tau}}$ then $t \in \scoped[\Theta']{\effectType{\tau}}$
% \end{lemma}
\vspace{-\baselineskip}
\begin{definition}[Closed substitution]{recHighlight}\label[definition]{dfn:closed-substitution}
  Given a context $\Gamma$, and assuming $\Theta = \pi_{\gamma}(\Gamma)$, the set of closed substitutions $\rho \vDash \Gamma$ are defined inductively as follows:
  \begin{enumerate}
    \item $() \vDash \gamma_{\bot}$
    \item If $\rho \vDash \Gamma$ and $n \in \scoped{\underline{T^{0} (\gamma)}}$ then $(\rho, n/x) \vDash \Gamma, (x:T^0)^{\gamma}$ 
    \item If $\rho \vDash \Gamma$ and $n \in \scoped{T^{-1}}$ then $(\rho, n/x) \vDash \Gamma, (x:T^{-1})$
    \item If $\rho \vDash \Gamma$ then $\rho \vDash \Gamma, \gamma$
    \item If $\rho \vDash \Gamma$ then $\rho \vDash \Gamma, \gamma \sqsubseteq \gamma'$
  \end{enumerate}
\end{definition}

Stratification of types and mode-indexing decomposes the fundamental lemma into many sub-lemmas, e.g.\ \Cref{lemma:fundamental}:

\begin{lemma}[Fundamental Lemma {[\compilemode{}, {$\effectType[\Delta; \xi]{T^0}$}]} of the \textsf{Scoped} Logical Relation]{recHighlight} \label[lemma]{lemma:fundamental}
  If $\Gamma \vdash_{\compilemode{}}^{\gamma} e: T^{0} \, ! \, \Delta ; \xi$ then for $\Theta = \pi_\gamma({\Gamma})$, and for all $\rho$ such that $\rho \vDash \Gamma$, 
  \[\elaborate{e}_{\compilemode{}}(\rho) \in \scoped[\Theta]{T^{0} \, ! \, \Delta ; \xi (\gamma)}\]
\end{lemma}

Proof of \Cref{lemma:fundamental} is by induction on the \recLang{} typing rules. I focus on the \textsc{\compilemode{}-Lambda} (\textsc{C-Abs}) case, where (handwaving the side-condition on $U$ for clarity) it suffices to show that for some arbitrary $\rho$, $\rho \vDash \Gamma$, 
\[\bind{x}{\gensym{\erase{S^0 (\gamma')}}}{\bind{\texttt{body}}{\elaborate{e}_{\compilemode}({\rho})}{\return{\Lam{x}{\texttt{body}}}}}\]
in $\scoped{\effectType{(\functionType[\xi]{S^0}{T^0})^0} (\gamma)}$. It is clear that this reduces to
\[{\bind{\texttt{body}}{\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x})}{\return{\Lam{\Binder{\alpha}{S^{\gamma'}}}{\texttt{body}}}}}\]
 By anti-reduction (\Cref{lemma:closure-reduction}) it suffices to show that this term is in the logical relation. By weakening, and the induction hypothesis (IH), $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x}) \in \scoped[\Theta']{\effectType[\Delta; \xi]{T^{0}} (\gamma')}$, where $\Theta' = , \Theta, \gamma', \gamma \sqsubseteq \gamma'$. Applying \textsf{Scoped}-Induction on $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}}})$:
\begin{enumerate}
  \item $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x}) \in \scoped[\Theta']{\effectType[\Delta; \xi]{T^{0}} (\gamma')}$ reduces to some $\return{n}$\\
   $\bind{\texttt{body}}{\return{n}}{\Lam{\Binder{\alpha}{S^{\gamma'}}}{\texttt{body}}}$ reduces to $\Lam{\Binder{\alpha}{S^{\gamma'}}}{n}$, where $\Var{\alpha}{S^{\gamma'}}$ is bound. By IH, all the free variables in $n$ are permitted by $\gamma'$. By the typing rules, only $\alpha$ is annotated with classifier $\gamma'$. Hence, under $\Theta$, the free variables of $\Lam{\Binder{\alpha}{S^{\gamma'}}}{n}$ are permitted by $\gamma$. The conclusion thus follows from anti-reduction.
  \item $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x}) \in \scoped[\Theta']{\effectType[\Delta; \xi]{T^{0}} (\gamma')}$ reduces to $E[\op{n}]$ \\
  As $\bind{\texttt{body}}{[-]}{\return{\Lam{\Binder{\alpha}{S^{\gamma'}}}{\texttt{body}}}}$ introduces no handlers, the conclusion follows immediately from IH.
\end{enumerate}
% \Cref{thm:refined-env-classifiers-correct} is an immediate corollary of \Cref{lemma:fundamental} and \Cref{dfn:well-typed-exp-rec}.

% I conjecture that this proof may be extended to support non-termination by incorporating the techniques of step-indexing and biorthogonality, as demonstrated by \citet{biernacki-2017}.

\subsection{Expressiveness of Refined Environment Classifiers}\label{subsection:rec-formal-expressiveness}
The typing rules for refined environment classifiers do not depend on the effect handler.\ \Cref{listing:refined-environment-classifiers-expressiveness} is never well-typed.

\begin{code}
\begin{rec}
$\begin{array}{l}
  \$ (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \, \return{\splice[(\, {{\textbf{\texttt{extrude}}(\equote[x])}} \, )]}} \, ] \\
  \;\;\,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {\underline{\textsf{any arbitrary program}}}\})
\end{array}$
\end{rec}
\captionof{listing}{The typing rules for refined environment classifiers forbid any program which attempts to extrude some potentially unsafe variable $x$ to a handler.}%
\label{listing:refined-environment-classifiers-expressiveness}
\end{code}

Consequently, \Cref{listing:eager-scope-extrusion-unsafe,listing:eager-scope-extrusion-unsafe-no-use,listing:eager-scope-extrusion-unsafe-continue,listing:eager-scope-extrusion-looks-unsafe} do not type check. Refined environment classifiers are less expressive than the eager dynamic check. In a well-typed \recLang{} program, the only variables that may be passed to an effect are those that never cause scope extrusion, for example, the variable $z$ in \Cref{listing:refined-environment-classifiers-safe}.

\begin{code}
\begin{rec}
$\begin{array}{l}
  \$ \lambda z. (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \, \return{\splice[( \, {{\textbf{\texttt{extrude}}(\equote[z])}} \, )]}} \,] \\
  \quad \quad \,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {\continue{k}{()}}\})
\end{array}$
\end{rec}
\captionof{listing}{Refined environment classifiers allow variables to be passed to an effects, so long as the variable can never cause a scope extrusion error (e.g. $z$).}%
\label{listing:refined-environment-classifiers-safe}
\end{code}


\section{Evaluation of \texorpdfstring{\sourceLang{}}{Lambda-Op-Quote-Splice}} \label{section:evaluation}
The results in this chapter support the idea that \sourceLang{} is an appropriate language in which to encode, and evaluate, scope extrusion checks. Formalising scope extrusion in \sourceLang{} provided clarity, aiding development of a novel best-effort dynamic check, which finds a sweet spot between the eager and dynamic checks. Additionally, unifying checks under a common language allows for comparative evaluation with reference to a bank of \sourceLang{} programs, which serve as litmus tests of expressiveness.

The cost of encoding static and dynamic checks into the same language is that reasoning about the correctness of static checks becomes more complicated, since one can no longer prove correctness via progress and preservation. It is difficult to reduce the complexity of reasoning, since dynamic checks are defined via elaboration. I hypothesise that the added complexity of reasoning is a reasonable cost to pay for a comprehensive and comparative evaluation.


% \section{Let Insertion}