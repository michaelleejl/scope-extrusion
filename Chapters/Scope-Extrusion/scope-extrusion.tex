\chapter{Scope Extrusion}\label{chapter:scope-extrusion}
This chapter uses \calculusName{} to formulate precise definitions of scope extrusion, and additionally evaluates four scope extrusion checks: 
\begin{enumerate}
  \item The lazy dynamic check, first described by \citet{kiselyov-14} (\Cref{section:lazy-dynamic-check-formal}).
  \item The eager dynamic check, which to the best of my knowledge is a faithful description of the current MetaOCaml check (\Cref{section:eager-dynamic-check-formal}).
  \item A novel best-effort dynamic check, which I argue occupies a goldilocks zone between expressiveness and efficiency (\Cref{section:best-effort-check}).
  \item Refined environment classifiers, a static approach first described by \citet{kiselyov-16} (\Cref{section:refined-environment-classifiers-formal}).
\end{enumerate}
The three dynamic checks have been implemented in MacoCaml. The implementations closely mirror the descriptions in this chapter, and were useful for building an understanding of the correctness and expressiveness of the various checks. 

\Cref{section:evaluation} evaluates \calculusName{}'s ability to facilitate comparative evaluation of different scope extrusion checks.

\section{Lazy Dynamic Check}\label{section:lazy-dynamic-check-formal}
Recall that one definition of scope extrusion relates to the \textit{result} of compile-time execution (\Cref{subsubsection:lazy-dynamic-check}, \Cpageref{subsubsection:lazy-dynamic-check}) \citep{kiselyov-14}. 

% In the words of \citet{kiselyov-14} (emphasis mine),

% \begin{quote}
%   \textit{Detection of scope extrusion may appear straightforward: traverse the \textbf{result of a generator} looking for unbound identifiers.}
% \end{quote}

I call this lazy scope extrusion, and define it as a property on \coreLang{} configurations as follows: 
\begin{definition}[Lazy Scope Extrusion]{coreHighlight}\label[definition]{def:lazy-scope-extrusion} A \coreLang{} configuration of the form 
\[\langle t;E;U;M;I\rangle\]  
exhibits lazy scope extrusion if all of the following hold:
  \begin{enumerate}
    \item $t = \return{n}$ for some $n$ of \textsf{AST} type
    \item $E = E'[\tls{[-]}]$ for some $E'$
    \item $\freevars{n} \not\subseteq \projfvs{E}$
  \end{enumerate}
\end{definition}

The second condition implies that $n$ is spliced into a larger, ambient and inert, program. 

The lazy dynamic check is defined as a modified term elaboration ${\elaborate{-}}^{\textbf{Lazy}}$. Two modifications are made to the term elaboration described in \Cref{section:elaboration}. First, \textbf{\texttt{check}}s are performed after top-level splices:
\[\elaborate{\splice[e]}_{\compilemode{}}^{\textbf{Lazy}} \triangleq {\checkfv{(\tls{\elaborate{e}_{\splicemode{}}^{\textbf{Lazy}}})}}\]
Second, \textbf{\texttt{dlet}}s are inserted to ensure variables bound outside top-level splices are declared safe (\Cref{dfn:declared-safe}), and thus do not cause the \textbf{\texttt{check}} to fail. For example, in $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$, $x$ is a binder in \compilemode{}-mode while $y$ is a binder in \quotemode{}-mode. $x$ should be declared safe (a free $x$ should not cause the \textbf{\texttt{check}} to transition to \textbf{\texttt{err}}), but $y$ should not. Thus, elaboration of binders in \compilemode{}-mode (but not \quotemode{}-mode) should insert \textbf{\texttt{dlet}}s:
{
  \footnotesize
\[\elaborate{\lambda x: T^0. \, e}_{\compilemode{}}^{\textbf{Lazy}} = \bind{x}{\gensym{\erase{T^0}}}{ \dlet{x}{\bind{\texttt{body}}{\elaborate{e}_{\compilemode{}}^\textbf{Lazy}}{\return{\Lam{x}{\texttt{body}}}}}}\]
}

For example, $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$ elaborates into (changes from the elaboration in \Cref{section:elaboration} highlighted in \textbf{\textcolor{selected}{blue}}):
{
\[\begin{array}{@{}l}
  \bind{x}{\gensym{\mathbb{N}}}{} \\
  \textcolor{selected}{\textbf{\texttt{dlet}}(}{x}, \textbf{\texttt{do}} \; {\texttt{body}_1} \leftarrow \textcolor{selected}{\textbf{\texttt{check}}(}\textbf{\texttt{tls}}({\bind{y}{\gensym{\mathbb{N}}}{}} \\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \textbf{\texttt{do}}\;{\texttt{body}_2} \leftarrow {(\bind{a}{\varToAST{x}}{}}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \bind{b}{\varToAST{y}}{}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \return{\texttt{Plus}(a, b)})\\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \return{\Lam{y}{\texttt{body}_2}})\textcolor{selected}{)}\\
  {\return{\Lam{x}{\texttt{body}_1}}}\textcolor{selected}{)}
\end{array}\]
}
% Second, I perform a check after a top-level splice:
% \[\elaborate{\splice[e]}_{\compilemode{}}^{\textbf{Lazy}} \triangleq \bind{\texttt{res}}{\tls{\elaborate{e}_{\splicemode{}}^{\textbf{Lazy}}}}{\checkfv{\texttt{res}}}\]

Due to the simplicity of the algorithm, verifying the correctness and expressiveness of the check is trivial: the check reports scope extrusion if, and only if, the program exhibits lazy scope extrusion.

\begin{theorem}[Correctness and Expressiveness of the Lazy Dynamic Check]{sourceHighlight}

Assuming $\cdot \vdash_{\compilemode{}} e: T^0 \, ! \, \emptyset;\emptyset$, and $\elaborate{e}_{\compilemode{}}^{\textbf{Lazy}} = t$, 
\[\begin{array}{c}
\langle t; [-]; \emptyset; \emptyset; \top \rangle \to^{*} \langle \err; E; U; M; I \rangle \\
\iff \\
\text{For some $E'$, }
\langle t; [-]; \emptyset; \emptyset; \top \rangle \to^{*} \langle \return{n}; E'; U; M; I \rangle\text{, and}\\
\langle \return{n}; E'; U; M; I \rangle \text{ exhibits lazy scope extrusion}
\end{array}
\]
\end{theorem}

However, due again to its simplicity, the lazy dynamic check is inefficient and uninformative, and therefore not suitable for practical use \citep{kiselyov-14} (\Cref{subsubsection:lazy-dynamic-check}, \Cpageref{subsubsection:lazy-dynamic-check}).

\section{Eager Dynamic Check}\label{section:eager-dynamic-check-formal}
Another definition of scope extrusion relates to \textit{intermediate results} during compile-time execution (\Cref{subsubsection:eager-dynamic-check}, \Cpageref{subsubsection:eager-dynamic-check}). For example, \citet{kiselyov-14} defines scope extrusion as (emphasis mine):

\begin{quote}
  \textit{At \textbf{any point during the evaluation}, an occurrence of an open-code value with a free variable whose name is not dynamically bound.}
\end{quote}

I call this eager scope extrusion, and define it as a property on \coreLang{} configurations as follows: 
\begin{definition}[Eager Scope Extrusion]{coreHighlight} A \coreLang{} configuration of the form 
\[\langle t;E;U;M;I\rangle\]  
exhibits eager scope extrusion if all of the following hold:
  \begin{enumerate}
    \item $t = \return{n}$ for some $n$ of \textsf{AST} type
    % \item $E = E' :: \tls{[-]}$ for some $E'$
    \item $\freevars{n} \not\subseteq \projfvs{E}$
  \end{enumerate}
\end{definition}

Notice that lazy scope extrusion is a special case of eager scope extrusion, where $E = E'[\tls{[-]}]$. 

It is possible to define an eager dynamic check by extending the lazy dynamic check. In addition to the top-level splice check, and the \compilemode{}-mode \textbf{\texttt{dlet}}s, the eager dynamic check adds \textbf{\texttt{check}}s for ASTs constructed in \quotemode{}-mode, for example 
\[\elaborate{v_1 v_2}_{\quotemode{}}^{\textbf{Eager}} = \bind{f}{\elaborate{v_1}_{\quotemode{}}^{\textbf{Eager}}}{\bind{a}{\elaborate{v_2}_{\quotemode{}}^{\textbf{Eager}}}{\checkfv{\App{f}{a}}}}\]
notice how $\return{\App{f}{a}}$ is replaced by $\checkfv{\App{f}{a}}$. 

Consequently, to prevent false positives, variables bound in \quotemode{}-mode must also be declared safe via \textbf{\texttt{dlet}}:
{
  \footnotesize
\[
\begin{array}{rcl}
\elaborate{\lambda x: T^0. \, e}_{\quotemode{}}^{\textbf{Eager}} = \bind{x}{\gensym{\erase{T^0}}}{\checkfv{(\dlet{x}{\bind{\texttt{body}}{\elaborate{e}_{\quotemode{}}^\textbf{Eager}}{\return{\Lam{x}{\texttt{body}}}}})}}
\end{array}\]
}

The elaboration of $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$ thus changes to (changes from the lazy dynamic check highlighted in \textbf{\textcolor{selected}{blue}}):
{
\[\begin{array}{@{}l}
  \bind{x}{\gensym{\mathbb{N}}}{} \\
  {\textbf{\texttt{dlet}}(}{x}, \textbf{\texttt{do}} \; {\texttt{body}_1} \leftarrow {\textbf{\texttt{check}}(}\textbf{\texttt{tls}}({\bind{y}{\gensym{\mathbb{N}}}{\textcolor{selected}{\textbf{\texttt{check}}(\textbf{\texttt{dlet}}(y,}}} \\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \textbf{\texttt{do}}\;{\texttt{body}_2} \leftarrow {(\bind{a}{\varToAST{x}}{}}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \bind{b}{\varToAST{y}}{}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \textbf{\texttt{\textcolor{selected}{check}}}\;{\texttt{Plus}(a, b)})\\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \return{\Lam{y}{\texttt{body}_2}}{\textcolor{selected}{))}}))\\
  {\return{\Lam{x}{\texttt{body}_1}}})
\end{array}\]
}

If \textbf{\texttt{dlet}}s were not inserted for binders in \quotemode{}-mode (e.g. $y$), then $\textbf{\texttt{check}}\; \texttt{Plus}(a, b)$ would fail, as $y$ would not be declared safe. 

Intuitively, the eager dynamic check performs a check whenever an AST is built. Hence, assume that evaluation reduces to a configuration that exhibits eager scope extrusion. Let the offending AST be $n$. The error will be detected and reported the next time $n$ is used to build a bigger AST $n'$ in an unsafe way (not all free variables in $n'$ are declared safe). 

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{do}} \, z \leftarrow (\textbf{\texttt{handle}} \; \equote[{\, \lambda x. \,\splice[({{\, \textbf{\texttt{extrude}}(\equote[x]) \,}})]\,}] \\
      \quad\quad\quad\quad\,\; \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\return{y}}\})\\
      \quad \textbf{\texttt{in}} \, \equote[{\splice[z] + 1}])
    \end{array}$
 \end{source}
 \captionof{listing}{Illustrating the eager dynamic check: eager scope extrusion is caused by the $\return{y}$ expression. Scope extrusion is not immediately detected. Rather, $y$ is bound to $z$. Scope extrusion is reported when $z$ is used to build a larger AST $\equote[{\splice[z]} + 1]$, where $y$ is not declared safe}%
 \label{listing:eager-scope-extrusion-check-eg}
\end{code}

As an example, consider \Cref{listing:eager-scope-extrusion-check-eg}. Eager scope extrusion is caused by the $\return{y}$ program fragment, where $y$ refers to the unbound variable $\Var{x}{\mathbb{N}}$\footnote{Technically, the variable should be renamed. For clarity, I do not rename the variables in this example}. Eager scope extrusion is not caught immediately. Rather, $y$ is bound to $z$, and scope extrusion is caught when $z$ is used to build a larger AST, $\equote[{\splice[z]+1}]$, where $y$ is not declared safe. 

The eager dynamic check also checks at top-level splices, like the lazy dynamic check. Conceptually, a top-level splice builds a larger, ambient and inert, AST (\Cref{listing:eager-scope-extrusion-check-eg-tls}):

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \textbf{\texttt{do}} \, z \leftarrow \$(\textbf{\texttt{handle}} \; \equote[{\, \lambda x. \,\splice[(\,{{ \textbf{\texttt{extrude}}(\equote[x])}}\,)] \,}] \\
      \quad\quad\quad\quad\,\textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\return{y}}\})\\
      \textbf{\texttt{in}} \, z + 1
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check additionally checks at top-level splices.}%
 \label{listing:eager-scope-extrusion-check-eg-tls}
\end{code}

To the best of my knowledge, the eager dynamic check is a faithful model of the MetaOCaml check, as described by \citet{kiselyov-24}. The description was verified by executing translations of \Cref{listing:eager-scope-extrusion-check-eg,listing:eager-scope-extrusion-check-eg-tls,listing:eager-scope-extrusion-unsafe-no-use,listing:eager-scope-extrusion-unsafe-continue} in BER MetaOCaml N153 (\Cref{section:metaocaml-litmustests}). 

\subsection{Correctness of the Eager Dynamic Check}\label{subsection:eager-dynamic-correctness}
The eager dynamic check is incorrect: not every case of eager scope extrusion is reported (by transitioning to \textbf{\texttt{err}}). Evaluation may result in eager scope extrusion, but the offending AST $n$ may never be used in an unsafe way. Thus, the eager dynamic check will not report that scope extrusion occurred. 

For example, recall that \sourceLang{} permits non-terminating programs. Consider the \sourceLang{} program in \Cref{listing:eager-scope-extrusion-unsafe}, where $\Omega$ is some non-terminating program that never refers to $z$. After translation, the program will reduce to a configuration that exhibits eager scope extrusion ($\return{y}$). However, the program will immediately enter into a non-terminating loop, and scope extrusion will never be reported.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{do}} \, z \leftarrow (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \,\splice[(\,{{\textbf{\texttt{extrude}}(\equote[x])}}\,)]} \,] \\
      \quad\quad\quad\quad\,\; \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\return{y}}\})\\
      \quad \textbf{\texttt{in}} \, \Omega)
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check does not report all occurrences of eager scope extrusion. The program causes eager scope extrusion ($\return{y}$), and then enters into a non-terminating loop which never refers to $z$.}%
 \label{listing:eager-scope-extrusion-unsafe}
\end{code}


Non-termination is not the only source of this behaviour. For example, the offending AST could be discarded (\Cref{listing:eager-scope-extrusion-unsafe-no-use}), and therefore, never trigger the check.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{handle}} \; \equote[\,{\lambda x. \,\splice[(\,{{\textbf{\texttt{extrude}}(\equote[x])}}\,)]}\,] \\
      \;\;\,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\equote[\texttt{0}]}; \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\return{y}}{\equote[\texttt{0}]}}\})
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check additionally will not report eager scope extrusion in the case where the offending AST is discarded.}%
 \label{listing:eager-scope-extrusion-unsafe-no-use}
\end{code}

Finally, in the most interesting example, the program may recover from scope extrusion by \textit{resuming} a continuation. As shown in \Cref{listing:eager-scope-extrusion-unsafe-continue}, by resuming the continuation, the program only uses the AST $\Var{x}{\mathbb{N}}$ in an \textit{safe} way. By resuming the continuation, the program restores the captured evaluation context, thus declaring $\Var{x}{\mathbb{N}}$ safe. Only then is $\Var{x}{\mathbb{N}}$ used to build an AST, so the checks will pass.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$ (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \,\return{\splice[( \, {{\textbf{\texttt{extrude}}(\equote[x])}} \,)]}} \,] \\
      \;\;\,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {{\continue{k}{y}}}\})
    \end{array}$
 \end{source}
 \captionof{listing}{The eager dynamic check will additionally not report cases where the offending AST is used, but only in safe ways. In this case, the continuation restores the context that permits $\Var{x}{\mathbb{N}}$ to be used.}%
 \label{listing:eager-scope-extrusion-unsafe-continue}
\end{code}

% Expanding on \Cref{listing:eager-scope-extrusion-unsafe-continue}, \textbf{\texttt{continue}} returns the AST $\Var{x}{\mathbb{N}}$ to the point where the \textbf{\texttt{extrude}} effect was performed, constructing the well-scoped AST: $\Lam{\Binder{x}{\mathbb{N}}}{\Var{x}{\mathbb{N}}}$.

\citet{kiselyov-14} acknowledges the incorrectness of the eager dynamic check, but argues that it makes the check more permissive. Permissiveness increases expressiveness, and is therefore desirable: a \textit{feature}, not a \textit{bug}. 

\subsection{Expressiveness of the Eager Dynamic Check}\label{subsection:eager-dynamic-expressiveness}
The expressiveness of the eager dynamic check, however, is not without issues. First, the eager dynamic check reports false positives (\Cref{listing:eager-scope-extrusion-looks-unsafe}), and is thus less expressive than the lazy dynamic check.
%  that the eager dynamic check is not maximally expressive, since we can use the offending AST in a way that \textit{appears} to be unsafe, but is actually not.

\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$ (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \, {\splice[(\, {{\textbf{\texttt{extrude}}(\equote[x])}} \, )]}}\,] \\
      \;\;\,\,\textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {{\continue{k}{\equote[{\splice[y]} + \texttt{0}]}}}\})
    \end{array}$
 \end{source}
 \captionof{listing}{A program which will fail the eager dynamic check. The offending AST ($\Var{x}{\mathbb{N}}$) is used to construct a larger AST in a way that appears to be unsafe $\equote[{\splice[y]+\texttt{0}}]$, but is actually not, since the unsafe AST is then only used in a safe way.}%
 \label{listing:eager-scope-extrusion-looks-unsafe}
\end{code}

In \Cref{listing:eager-scope-extrusion-looks-unsafe}, the offending AST ($\Var{x}{\mathbb{N}}$, bound to $y$) is used in a context where $\Var{x}{\mathbb{N}}$ is not declared safe ($\equote[{\splice[y]} + \texttt{0}]$), and thus the eager dynamic check will report an error. However, if evaluation had been allowed to proceed, the evaluation context binding $\Var{x}{\mathbb{N}}$ (and additionally declaring it safe) would have been restored ($\continue{k}{w}$), and all variables would have been properly scoped. The program \textit{recovers} from a state of eager scope extrusion, and will not exhibit lazy scope extrusion. The eager dynamic check is thus not as expressive as the lazy dynamic check.

More concerningly, the eager dynamic check is unpredictable: it is difficult to explain, without appealing to the operational semantics, why the check disallows some programs, but allows others. Compare the program in \Cref{listing:eager-scope-extrusion-unsafe-continue}, which passes the check, and \Cref{listing:eager-scope-extrusion-looks-unsafe}, which \textit{fails} the check. It is clear that the following inequation holds:
\[\equote[\splice[e]] \neq_{\splicemode{}} \equote[{\splice[e] + \texttt{0}}]\]
More generally, for program fragments $P$ and $P'$:
\[P[e] =_{\splicemode{}} P'[e] \centernot\implies \equote[{P[\splice[{\equote[e]}]]}] =_{\splicemode{}} \equote[{P'[\splice[{\equote[e]}]]}]\]
% where $E$ is some source-level context (not necessarily an evaluation context). 

One has to appeal to the operational behaviour of the eager dynamic check to explain why these equations do not hold. In my opinion, this exposes too much of the internal operation of the check to the user. 

One possible attempt to make the eager dynamic check more predictable is to change the \splicemode{}-mode elaboration of \textbf{\texttt{return}}, such that each \textbf{\texttt{return}} elaborates into a \textbf{\texttt{check}}:
\[\elaborate{\return{v}}_{\splicemode{}} = \checkfv{\elaborate{v}_{\splicemode{}}}\]
While this restores certain equations (for example, \Cref{listing:eager-scope-extrusion-unsafe-no-use} will now report a scope extrusion error), it will break others. For example, the following equation no longer holds:
\[\bind{\_}{\return{v}}{e} =_{\splicemode{}} e\]
since the \textbf{\texttt{return}} is elaborated into a \textbf{\texttt{check}}, which $v$ may fail.

\subsection{Efficiency of the Eager Dynamic Check}\label{subsection:eager-dynamic-efficiency}
Additionally, the eager dynamic check is not, in the worst case, more efficient than the lazy dynamic check, since there exist pathological examples (\Cref{listing:eager-scope-extrusion-check-eg-tls}). Further, the overhead of the checks cannot be bound: multi-shot continuations may be replayed an unbounded number of times. Multi-shot continuations may capture checks. Thus, the overhead of checking is unbounded. However, I conjecture that in the \textit{common case}, the eager dynamic check detects scope extrusion sufficiently early as to outweigh the checking overhead. This argument is an empirical one, and would require further research, outside the scope of the dissertation, to support. 

\section{Best-Effort Dynamic Check}\label{section:best-effort-check}
The lazy dynamic check is too inefficient, and the eager dynamic check too unpredictable. Might it be possible to find a ``goldilocks'' solution? Such a check should allow the program in \Cref{listing:eager-scope-extrusion-looks-unsafe}, and be permissive in a predictable way. For example, a check that eagerly detects programs that \textit{must} cause lazy scope extrusion. I call this best-effort scope extrusion.

\begin{definition}[Best-Effort Scope Extrusion]{coreHighlight} A \coreLang{} configuration of the form 
\[\langle t;E;U;M;I\rangle\]  
exhibits best-effort scope extrusion if there exists some $i \in \mathbb{N}$ such that 
\[ \langle t;E;U;M;I\rangle \to^{i} \langle t';E';U';M';I'\rangle\]
and $\langle t';E';U';M';I'\rangle$ exhibits lazy scope extrusion.
\end{definition}

This section describes a best-effort dynamic check that approximates best-effort scope extrusion, with occasional false positives. 

The best-effort dynamic check is simple: change all \textbf{\texttt{check}}s to $\textbf{\texttt{check}}_M$s. For example, 
{
  \footnotesize
\[
\begin{array}{rcl}
\elaborate{\lambda x: T^0. \, e}_{\quotemode{}}^{\textbf{BE}} = \bind{x}{\gensym{\erase{T^0}}}{\checkm{(\dlet{x}{\bind{\texttt{body}}{\elaborate{e}_{\quotemode{}}^\textbf{BE}}{\return{\Lam{x}{\texttt{body}}}}})}}
\end{array}\]
}
The $\lambda x:\mathbb{N}. \; \splice[{\equote[\lambda{y}: \mathbb{N}. \; x+y]}]$ program elaborates into (changes from the eager dynamic check highlighted in \textbf{\textcolor{selected}{blue}}):
{
\[\begin{array}{@{}l}
  \bind{x}{\gensym{\mathbb{N}}}{} \\
  {\textbf{\texttt{dlet}}(}{x}, \textbf{\texttt{do}} \; {\texttt{body}_1} \leftarrow {{\textcolor{selected}{\textbf{{\texttt{check}$_M$}}}}}(\textbf{\texttt{tls}}({\bind{y}{\gensym{\mathbb{N}}}{{\textcolor{selected}{\textbf{{\texttt{check}$_M$}}}(\textbf{\texttt{dlet}}(y,}}} \\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \textbf{\texttt{do}}\;{\texttt{body}_2} \leftarrow {(\bind{a}{\varToAST{x}}{}}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \bind{b}{\varToAST{y}}{}\\
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad
    \textcolor{selected}{\textbf{\texttt{check}$_M$}}\;{\texttt{Plus}(a, b)})\\
    \quad\quad\quad\quad\quad\quad\quad
    \quad\quad\quad\quad\quad\quad\,\,
    \return{\Lam{y}{\texttt{body}_2}}{{))}}))\\
  {\return{\Lam{x}{\texttt{body}_1}}})
\end{array}\]
}

To understand the best-effort dynamic check, consider the program in \Cref{listing:eager-scope-extrusion-looks-unsafe}, which is elaborated into \coreLang{}\footnote{The program has been somewhat simplified}. The failing check is \colorwave[quote]{underlined}. 
\begin{center}
  \begin{tikzpicture}
  \begin{scope}[every node/.style={font=\ttfamily\footnotesize}]
    \node[align=left] (example) {$\begin{array}{l}
      \textbf{\texttt{handle}}\\
      \quad \textbf{\texttt{do}} \, x \leftarrow \gensym{\mathbb{N}}  \, \textbf{\texttt{in}} \\ 
       \quad \textbf{\texttt{check}}(\textbf{\texttt{dlet}}({x}, \, \textbf{\texttt{do}} \, {\texttt{body}} \leftarrow \, (\bind{a}{\varToAST{x}}{\textbf{\texttt{extrude}}}(a)) \; \textbf{\texttt{in}}\\ 
       \quad\quad\quad\quad\quad\quad\quad\;\, \, {\return{\Lam{x}{\texttt{body}} }}) \\
      \textbf{\texttt{with}} \\ 
      \quad \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \\ 
      \quad\;\, \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\checkfv{\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}}\}
    \end{array}$};
    % (-8,example.south) -- (-2,example.south) -- (2,0) -- (4,0);
  \end{scope}

   \path [draw=quote,snake it, thick]
    ($(example.south) + (-0.8, 0)$) -- ($(example.south) + (2.4, 0)$);

  \begin{scope}[every node/.style={font=\scriptsize}]
    \node[anchor = north, text=quote, align = left] (check-fail) at ($(example.south) + (1, -0.2)$) {\textbf{\texttt{check}} fails, transitioning to $\err$,\\ since $y$ is bound to $\Var{x}{\mathbb{N}}$,\\ which is not declared via \textbf{\texttt{dlet}}};

    \node[anchor = west, align = left, text=comment] at ($(example.east) + (-0.5cm, -0.45cm)$) {However, $w$ is only \\ used in a context \\
    where $\Var{x}{\mathbb{N}}$ is \\declared safe};
  \end{scope}

  \draw[draw=comment, line width = 0.3mm] ($(example.south east) + (-0.6cm, 0.36cm)$) circle[radius=2mm] node (annote-1) {};

  \begin{scope}[->,>=stealth']
  \draw[line width = 0.3mm, dashed, draw=comment] ($(annote-1.north) + (0cm, 0.1cm)$) -- ($(annote-1.north) + (-2cm, 1.4cm)$);
  \end{scope}

  \end{tikzpicture}

\end{center}

The check fails because when an effect is performed, the variable $\Var{x}{\mathbb{N}}$ is no longer declared safe. Since $y$ is bound to $\Var{x}{\mathbb{N}}$, checking the AST $\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))$ reports an error. The problem is that the continuation $k$ can be used to bind $\Var{x}{\mathbb{N}}$. It is not clear, when the \texttt{Plus} AST is constructed and checked, that eager scope extrusion \textit{must} lead to lazy scope extrusion. 

To make the check more expressive, therefore, it may be useful to temporarily allow $\Var{x}{\mathbb{N}}$ to extrude its scope, delaying error reporting until one knows for certain that one must have lazy scope extrusion. 

The $\textbf{\texttt{check}}_M$ primitive allows $\Var{x}{\mathbb{N}}$ to temporarily extrude its scope. $\textbf{\texttt{check}}_M$ checks for scope extrusion, but turns a blind eye to some set of muted variables $M$. It thus suffices to mute $\Var{x}{\mathbb{N}}$, adding to $M$. The \coreLang{} operational semantics mutes and unmutes variables, like $\Var{x}{\mathbb{N}}$, at key points. 

When effects are performed, the variables which are no longer declared safe (like $\Var{x}{\mathbb{N}}$) are added to the set of muted variables (\textsc{Eff-Op}, \Cref{fig:corelang-opsem}, \Cpageref{fig:corelang-opsem}):
\[\coreConfiguration{\op{v}}{E_1[\handleWith{E_2}{h}]}{U}{M}{I} \to \coreConfiguration{c[v/x, \text{cont}/ k]}{E_1}{U}{\textcolor{coreHighlight}{M \cup \projfvs{E_2}}}{I'}\]
As an example, consider the reduction of:
\[\begin{array}{l}
  \textbf{\texttt{handle}} \\
  \quad {\dlet{\Binder{x}{\mathbb{N}}}{
  \bind{\texttt{body}}{\textbf{\texttt{extrude}}(\Var{x}{\mathbb{N}})}{\Lam{\Binder{x}{\mathbb{N}}}{\texttt{body}}}}} \\ 
  \textbf{\texttt{with}} \\ 
  \quad \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \\ 
      \quad\;\, \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\checkm{\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}}\}
\end{array}\]
which is a simplified version of \Cref{listing:eager-scope-extrusion-looks-unsafe} (elaborated into \coreLang{}). Note additionally that the \textbf{\texttt{check}} has been replaced with a $\textbf{\texttt{check}}_M$. The first reduction step performs the operation, and the configuration steps to
\[\begin{array}{l}
  \bind{w}{\checkm{\texttt{Plus}(\Var{x}{\mathbb{N}}, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}
\end{array}\]
Since the $\dlet{\Binder{x}{\mathbb{N}}}{[-]}$ frame is no longer on the stack, $\checkfv{\texttt{Plus}(\Var{x}{\mathbb{N}}, \texttt{Nat}(\texttt{0}))}$ would throw an error. However, performing the \textbf{\texttt{extrude}} operation additionally \textit{mutes} $\Var{x}{\mathbb{N}}$, and hence $\checkm{\texttt{Plus}(\Var{x}{\mathbb{N}}, \texttt{Nat}(\texttt{0}))}$  would not throw an error. 

When should a variable like $\Var{x}{\mathbb{N}}$ be \textit{unmuted}? When there \textbf{cannot be} any way to resume a continuation $k$ that could bind $\Var{x}{\mathbb{N}}$. A safe approximation is the point where there cannot be \textit{any} bound continuations $k$. This point is identified by tracking the maximal length $I$ of the stack $E$ that was never captured by the handling of an effect (\Cref{fig:unmute-variables-algo}). 

\begin{figure}
  \begin{center}
  \begin{tikzpicture}[square/.style={regular polygon,regular polygon sides=4}]
    \begin{scope}[every node/.style={draw, square, minimum size = 1cm, anchor = west}]
          \node (1) {};
          \node (2) at ($(1.east) - (0.01cm, 0cm)$) {};
          \node (3) at ($(2.east) - (0.01cm, 0cm)$) {};
          \node[fill=comment] (4) at ($(3.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (5) at ($(4.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (6) at ($(5.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (7) at ($(6.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (8) at ($(7.east) - (0.01cm, 0cm)$) {};
          \node[fill=fade] (9) at ($(8.east) - (0.01cm, 0cm)$) {};
    \end{scope}

 \begin{scope}[->,>=stealth']
  \draw[line width = 0.3mm, draw] ($(8.south) + (1cm, -0.6cm)$) -- ($(4.south) + (0cm, -0.6cm)$) -- ($(4.south) + (0cm, -0.1cm)$);

  \draw[line width = 0.3mm, draw=comment] ($(9.east) + (0.1cm, 0cm)$) -- ($(9.east) + (0.5cm, 0cm)$);
  \end{scope}

  \begin{scope}[every node/.style={font=\ttfamily\bfseries}]
  \node[anchor=west] (op) at ($(8.south) + (1cm, -0.65cm)$) {op};
  \node[anchor=west, text=comment, font=\ttfamily\bfseries\footnotesize] (comment) at ($(9.east) + (0.5cm, -0.02cm)$) {stack grows rightwards};

  % \node[anchor=south] (hdl) at ($(5.north) + (0cm, 0.3cm)$) {$E$};
  \end{scope}
  \draw [decorate,decoration={brace,amplitude=5pt,raise=1ex}]
  ($(1.north west)$) -- ($(9.north east)$) node[midway,yshift=2em]{$E$};

  \draw [decorate,decoration={brace,mirror,amplitude=5pt,raise=2ex}]
  ($(1.south west)$) -- ($(3.south east)$) node[midway,yshift=-2em]{$I = 3$};
  \end{tikzpicture}
\end{center}
\caption{An illustration of when variables are unmuted. The stack, $E$, grows rightwards. Effects are caught by handlers (\textbf{\textcolor{darkgrey}{dark grey}}). This captures a portion of the stack (\textbf{\textcolor{lightgrey}{light grey}}). We track the length of the stack, in \textbf{white}, that are never captured by an operation in this fashion. Frames in \textbf{white} will never be able to resume a continuation.}
\label{fig:unmute-variables-algo}
\end{figure}

As an example, consider the following program, which builds the AST of the constant \texttt{1} function, $\lambda z. \, (\lambda x. \, x + \texttt{0}) (\texttt{1})$:
\[\begin{array}{l}
  \textbf{\texttt{check}}_M(\textbf{\texttt{dlet}}(\Binder{z}{\mathbb{N}}, \textbf{\texttt{do}} \; b \leftarrow \, \\ 
  \quad (\textbf{\texttt{do}} \; f \leftarrow \, \textcolor{comment}{\textbf{\texttt{handle}}} \\
  \textcolor{comment}{\;\;\;\,\quad \quad \quad\quad\quad {\dlet{\Binder{x}{\mathbb{N}}}{
  \bind{\texttt{body}}{\textbf{\texttt{extrude}}(\Var{x}{\mathbb{N}})}{\Lam{\Binder{x}{\mathbb{N}}}{\texttt{body}}}}}} \\ 
  \textcolor{comment}{\;\;\;\,\quad \quad\quad\quad \textbf{\texttt{with}}} \\ 
  \textcolor{comment}{\;\;\;\,\quad \quad\quad\quad \quad \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}};} \\ 
  \textcolor{comment}{\;\;\;\, \quad \quad\quad\quad \quad \;\, \textbf{\texttt{extrude}}(y, k) \mapsto {\bind{w}{\checkm{\texttt{Plus}(y, \texttt{Nat}(\texttt{0}))}}{\continue{k}{w}}}\}} \\ 
  \, \quad \textbf{\texttt{in}} \; \textbf{\texttt{do}} \; {a}\leftarrow {\return{\texttt{Nat}(\texttt{1})}}\\
  \, \quad \textbf{\texttt{in}} \, {\checkm{\texttt{App}(f, a)}})\; \\
  \textbf{\texttt{in}} \; \return{\Lam{\Var{z}{\mathbb{N}}}{b}})) 
\end{array}\]
Note that the body of $f$, coloured in \textbf{\textcolor{comment}{grey}}, is the simplified version of \Cref{listing:eager-scope-extrusion-looks-unsafe}. The \textbf{\texttt{extrude}} operation is caught by the handler (also in \textbf{\textcolor{comment}{grey}}), and the surrounding context (in \textbf{black}) is never captured by the handling of any effect. This surrounding context, which must have no references to the captured continuation $k$, is identified by $I$.

If the stack was never captured by the handling of an effect (for example, no operations were performed), then $I$ is set to $\top$, $\forall n \in \mathbb{N}, \top \geq n$. Performing an effect can thus \textit{decrease} $I$, but never increase it. This is the side condition on \textsc{Eff-Op}.
\[\begin{array}{ll}\coreConfiguration{\op{v}}{E_1[\handleWith{E_2}{h}]}{U}{M}{I} \to & \coreConfiguration{c[v/x, \text{cont}/ k]}{E_1}{U}{{M \cup \projfvs{E_2}}}{\textcolor{coreHighlight}{I'}} \\ &\textcolor{coreHighlight}{(I' = \textsf{min}(\textsf{len}(E_1), I)} \end{array}\]

During reduction, when the length of the stack is less than, or equals to, $I$, there must not be any remaining references to any continuations $k$, and thus $I$ may be reset to $\top$, and all muted variables may be unmuted. In the previous example, the program eventually reduces to 
\[\begin{array}{l}
  \textbf{\texttt{check}}_M(\textbf{\texttt{dlet}}(\Binder{z}{\mathbb{N}}, \textbf{\texttt{do}} \; b \leftarrow \, \\ 
  \quad (\textbf{\texttt{do}} \; f \leftarrow \textcolor{red}{[}\return{\Lam{\Binder{x}{\mathbb{N}}}{\texttt{Plus}(\Var{x}{\mathbb{N}}, \Nat{\texttt{0}})}}\textcolor{red}{]} \\ 
  \, \quad \textbf{\texttt{in}} \; \textbf{\texttt{do}} \; {a}\leftarrow {\return{\texttt{Nat}(\texttt{1})}}\\
  \, \quad \textbf{\texttt{in}} \, {\checkm{\texttt{App}(f, a)}})\; \\
  \textbf{\texttt{in}} \; \return{\Lam{\Var{z}{\mathbb{N}}}{b}})) 
\end{array}\]
Where $[-]$ separates the evaluation context (outside) and the term (inside). At this point, since the length of the stack is less than or equals to $I$, it is safe to unmute all muted variables. When there are no muted variables, $\textbf{\texttt{check}}_M$ and \textbf{\texttt{check}} have the same behaviour.

However, altering the semantics in such a manner means that any transition could potentially have a side effect: unmuting variables. To keep the semantics standard, and to more closely model the implementation of the check, I associate the act of unmuting with \textbf{\texttt{dlet}} and \textbf{\texttt{tls}}. A transition from \textbf{\texttt{dlet}} conditionally unmutes variables: 
\[\begin{array}{@{}ll}
  \langle \dlet{\Binder{\alpha}{T}}{\return{n}}; E; U; M; I \rangle \to \langle \return{n}; E; U; \emptyset; \top\rangle & \text{if} \; \textsf{len}(E) \leq I\\
  \langle \dlet{\Binder{\alpha}{T}}{\return{n}}; E; U; M; I \rangle \to \langle \return{n}; E; U; M; I \rangle & \text{if} \; \textsf{len}(E) > I
\end{array}\] 
In the previous example, the transition from $\dlet{\Binder{z}{\mathbb{N}}}{\return{n}}$ unmutes variables. Therefore, $\Var{x}{\mathbb{N}}$ is still muted when the \texttt{App} constructor is checked, but unmuted when we check the constructor of the outer lambda. 
This is the side-effect/side-condition in the \textsc{Sec-Dlt} rule (\Cref{fig:corelang-opsem}).

Additionally, transitions from \textbf{\texttt{tls}} \textit{unconditionally} unmute variables, since the evaluation context beyond \textbf{\texttt{tls}} must be inert, and thus can never be captured by a handler
\[\langle \tls{\return{n}}; E; U; M; I \rangle \to \langle \tls{\return{n}}; E; U; \emptyset; \top \rangle\]

Since $\textbf{\texttt{check}}_M$s are at least as permissive as \textbf{\texttt{check}}s, the best-effort dynamic check is at least as expressive as the eager dynamic check. The implementation of the best-effort scope extrusion check allows the program in \Cref{listing:eager-scope-extrusion-looks-unsafe}. 

\subsection{Correctness of the Best-Effort Dynamic Check}\label{subsection:best-effort-correct}
Correctness of the best-effort dynamic check is easy to show: if there is best-effort scope extrusion, then either one of the the $\textbf{\texttt{check}}_M$s reports an error, or none do. The latter case degenerates to the lazy dynamic check, where the top-level splice \textbf{\texttt{check}} must report an error. 

\begin{theorem}[Correctness of the Best-Effort Check]{sourceHighlight} If 
  \begin{enumerate}
    \item $\cdot \vdash_{\compilemode{}} e: T^0 \, ! \, \emptyset;\emptyset$, 
    \item $\elaborate{e}_{\compilemode{}}^{\textbf{BE}} = t$
    \item $\langle \textsf{erase-checks}(t); [-]; \emptyset; \emptyset; \top \rangle$ exhibits best-effort scope extrusion 
  \end{enumerate}
  then there exists $E$, $U$, $M$, $I$ such that \[\langle t; [-]; \emptyset; \emptyset; \top \rangle \to^{*}\langle \err{}; E; U; M; I \rangle\]
Note that in the third condition we have to erase the checks in $t$, since adding a check can transform a program that will eventually exhibit lazy scope extrusion to one that will not (instead terminating early with an error).
\end{theorem}

\subsection{Expressiveness of the Best-Effort Dynamic Check}\label{subsection:best-effort-expressive}
The best-effort dynamic check occasionally misfires, reporting false positives. It is thus less expressive than the lazy dynamic check. In particular, it does not allow the program in \Cref{listing:best-effort-imperfect}. The program in \Cref{listing:best-effort-imperfect} attempts to build the (unsafe) AST $\lambda x.\return{y}$, where $y$ has extruded its scope, but then throws it away, returning instead the AST of \texttt{1}. Critically, the constructor of the outer lambda, $\lambda x. [-]$, is never captured by any effect. Hence, the program will eventually reduce to a configuration 

\[\langle \dlet{\Binder{x}{\mathbb{N}}}{\return{\Lam{\Binder{x}{\mathbb{N}}}{\Var{y}{\mathbb{N}}}}}; E[\textbf{\texttt{check}}[-]]; U; \{\Var{y}{\mathbb{N}}\} ; I \rangle\]
where $\textsf{len}(E[\checkfv{[-]}]) < I$. The transition from this configuration will thus unmute $\Var{y}{\mathbb{N}}$, and the surrounding \textbf{\texttt{check}} will fail, as $\Var{y}{\mathbb{N}}$ is free, unmuted, and not declared safe.

\begin{code}
  \begin{source}
    $
    \begin{array}{l}
      \$(\langle \langle \lambda x. \$ (\textbf{\texttt{handle}} \, \equote[{\lambda y. \$(\textbf{\texttt{op}}(y); \return{y})}]\\
      \quad\quad\quad\quad\textbf{\texttt{with}} \, \{ \returnHandler{u}{\return{\equote[\texttt{0}]}}; \opHandler{z}{k}{\return{z}}\})\rangle\rangle;\\
      \;\, \equote[{\texttt{1}}])
    \end{array}
    $
  \end{source}
  \captionof{listing}{The best-effort scope extrusion check reports false positives. This program attempts to build the (unsafe) AST $\lambda x.\return{y}$, where $y$ has extruded its scope, but then throws it away, returning instead the AST of $\texttt{1}$. Critically, the program will eventually unmute $\Var{y}{\mathbb{N}}$, and the surrounding \textbf{\texttt{check}} will fail, as $\Var{y}{\mathbb{N}}$ is free, unmuted, and not declared safe.}%
  \label{listing:best-effort-imperfect}
\end{code}

Rather than expressiveness, the best-effort dynamic check exhibits a ``Cause for Concern'' property. Effectively, if the best-effort check reports an error, \textbf{and the offending AST $n$ appears in the final result of compile-time computation}, then there must be lazy scope extrusion. Consequently, in cases like \Cref{listing:best-effort-imperfect}, the only way to safely use $\lambda x.\return{y}$ is to throw it away. 

\begin{theorem}[Cause for Concern Property]{sourceHighlight}\label{thm:best-effort-cause-for-concern} If 
  \begin{enumerate}
    \item $\cdot \vdash_{\compilemode{}} e: T^0 \, ! \, \emptyset;\emptyset$, 
    \item $\elaborate{e}_{\compilemode{}}^{\textbf{BE}} = t$
    \item There exists $E$, $U$, $M$, $I$ such that $\langle t; [-];\emptyset; \emptyset; \top \rangle \to^{*}\langle \checkm{n}; E; U; M; I \rangle$
    and $\langle \checkm{n}; E; U; M; I \rangle \to \langle \err{}; E; U; M; I \rangle$
  \end{enumerate}
Then for all $i \in \mathbb{N}$, if 
\begin{enumerate}
  \item[4.] $\langle \return{n}; \textsf{erase-checks}(E); U; M; I \rangle \to^{i} \langle \return{m}; E'; U'; M'; I' \rangle$
  \item[5.] and $n$ a subtree of $m$,  
\end{enumerate}
then $\freevars{m} \not\subseteq \projfvs{E'}$  
\end{theorem}

The proof of \Cref{thm:best-effort-cause-for-concern} is by contradiction. By assumption (3) there must be at least one variable, call it $\Var{x}{T}$, that is free in $n$ and not declared safe in $E$. Assume for the sake of contradiction that $\freevars{m} \subseteq \projfvs{E'}$. Then, by assumption (5), the frame $\dlet{\Binder{x}{T}}{[-]}$ must be in $E'$. By assumptions (1) and (2), we only have to consider terms that are the target of elaboration. By definition of elaboration, the only way to push the frame $\dlet{\Binder{x}{T}}{[-]}$ on $E'$ is by resuming a continuation containing $\dlet{\Binder{x}{T}}{[-]}$. But then we must have had access to the resumed continuation in $E$. In turn, this implies $I < \textsf{len}(E)$, and thus $\Var{x}{T}$ would not have been unmuted. Consequently, $\checkm{n}$ would not have failed because of $\Var{x}{T}$. This contradicts assumption (3). 

Note that the eager dynamic check does not have the Cause for Concern property, with \Cref{listing:eager-scope-extrusion-looks-unsafe} being a counter-example. Hence, the best-effort dynamic check is \textbf{more} expressive, and more \textbf{predictably} expressive, than the eager dynamic check. 

\subsection{Efficiency of the Best-Effort Dynamic Check}\label{subsection:best-effort-efficient}
The best-effort dynamic check is certainly less efficient than the eager dynamic check. Like the eager dynamic check, I conjecture that the best-effort check is more efficient in the common case than the lazy check, but I leave substantiating the argument to further research.

% While I do not justify that the Eager and Best-Effort checks are more efficient than the Lazy check, the calculus \textit{does} give a mechanism for quantifying 

\section{Refined Environment Classifiers}\label{section:refined-environment-classifiers-formal}
% Recall the objective of this chapter: to evaluate \calculusName{} as a common language for encoding, and evaluating, different policies for moderating scope extrusion. I have encoded three dynamic checks into \calculusName{}, and considered their correctness, expressiveness, and efficiency. The evaluation was comparative: I was able to conclude that the best-effort check was more expressive than the eager dynamic check, but less expressive than the lazy dynamic check. The comparative evaluation was facilitated by \sourceLang{}. 
The method of refined environment classifiers (\Cref{subsubsection:refined-environment-classifiers}, \Cpageref{subsubsection:refined-environment-classifiers}) presents a static approach to preventing scope extrusion.\ \citet{isoda-24} introduce a calculus with algebraic effects and code combinators (rather than quotes and splices), whose interaction is moderated via refined environment classifiers. This section demonstrates that refined environment classifiers may be encoded, and therefore evaluated, in \sourceLang{}. 

The \sourceLang{} type system is augmented with a \textbf{simplified} version of \citeauthor{isoda-24}'s type system:

\begin{enumerate} 
  \item \sourceLang{} types are straightforwardly extended, by annotating all level $-1$ \textsf{Code} types with a classifier (\Cref{fig:rec-source-types}).
  \item Similarly, level $0$ types are associated with a classifier. However, following \citet{isoda-24}, this association is indirect: for level $0$ types, classifiers are associated with the judgement rather than annotated onto the type (\Cref{fig:refined-env-classifiers-source-typing-rules}). 
  \item Correspondingly, \coreLang{} types are extended, with all \textsf{AST} types annotated with a classifier.
\end{enumerate}

For ease of reasoning, it is helpful to define the notion of an \textbf{extended} source type.
\begin{definition}[Extended source type]{sourceHighlight}\label[definition]{dfn:extended-source-type}
An \textbf{extended} source type is either:
  \begin{enumerate}
    \item A level $-1$ type, for example, $(\textsf{Code}(\mathbb{N}^{0})^{\gamma})^{-1}$ or 
    \item A level $0$ type annotated with a classifier, for example, $\mathbb{N}^{0} (\gamma)$. 
    \item A level $0$ binder type, which is a level $0$ value type (like $\mathbb{N}^{0} (\gamma)$) annotated with an \underline{underline} to indicate that it will be elaborated into a binder type, (\underline{$\mathbb{N}^{0} (\gamma)$})
  \end{enumerate}
\end{definition}

\begin{figure}
  \begin{source-desc}
    % $\begin{array}{lllr}
    % {\textbf{\large {Effects Row}}}\\\\
    % % \textbf{Run-Time} & \xi ::= \cdot \mid \xi \cup \{ \textsf{op}_i^{0}\} \\
    % \textbf{Compile-Time} & \Delta ::= \cdot \mid \Delta \cup \{ \textsf{op}_i^{-1}\} \\\\
    % \end{array}$

% \vspace{5mm}
{\textbf{\large {Types (Refined Environment Classifiers)}}}\\

  $\begin{array}{@{}lllr}
    % \textbf{Level 0} & \text{Values} & T^0 ::= \mathbb{N}^0 & \text{\footnotesize{naturals}} \\ \vspace{0.4mm}
    % && \quad\quad\,\, \mid {(\functionType[\xi]{S^0}{T^{0}})}^{0} & \text{\footnotesize{functions}} \\ \vspace{0.4mm}
    % && \quad\quad\,\, \mid {(\continuationType[\xi]{S^0}{T^{0}})}^{0} & \text{\footnotesize{continuations}} \\\vspace{0.4mm}
    % & \text{Computations} & T^0 \, ! \, \xi \\\vspace{0.8mm}
    %  && \mid T^0 \, ! \,  \Delta;\xi & \\\vspace{0.8mm}
    % & \text{Handlers} & (\handlerType{S^{0} \, ! \, \xi}{T^{0} \, ! \, \xi'})\, !\, \Delta\\ \\

    \textbf{Level $-$1} & \text{Values} & T^{-1} ::= 
    % \mathbb{N}^{-1} & \text{\footnotesize{naturals}} \\ \vspace{0.4mm}
    % && \quad\quad\quad \mid {(\functionType{S^{-1}}{T^{-1}})}^{-1} & \text{\footnotesize{functions}} \\\vspace{0.4mm}
    % && \quad\quad\quad \mid {(\continuationType{S^{-1}}{T^{-1}})}^{-1} & \text{\footnotesize{continuations}} \\\vspace{0.4mm}
    \ldots \mid {({\textsf{Code}({T^{0} \, ! \, \xi})}^{\textbf{\textcolor{red}{$\gamma$}}})}^{-1} \\
    % \vspace{0.8mm}
    % & \text{Computations} & T^{-1} \, ! \, \Delta \\\vspace{0.8mm}
    % & \text{Handlers} & \handlerType{S^{-1} \, ! \, \Delta}{T^{-1} \, ! \, \Delta'}
  \end{array}$
  \end{source-desc}
  \caption{Extending \sourceLang{} with refined environment classifiers. The only change is that \textsf{Code} types are now annotated with an environment classifier $\gamma$, highlighted in \textbf{\textcolor{red}{red}}.}
  \label{fig:rec-source-types}
\end{figure}

Contexts $\Gamma$ must contain the least classifier $\gamma_{\bot}$ (so the empty context is no longer permitted), and the definition of closed well-typed expression is adapted to reflect this

\begin{definition}[Well-typed closed Expression, Refined Environment Classifiers]{sourceHighlight}\label[definition]{dfn:well-typed-exp-rec}
  $e$ is a well-typed expression if $\gamma_{\bot} \vdash_{\compilemode}^{\gamma_{\bot}} e : T^{0} \, ! \, \emptyset; \emptyset$
\end{definition}

Most typing rules are straightforwardly adapted, with key rules listed in \Cref{fig:refined-env-classifiers-source-typing-rules}. 


\begin{code} 
 \begin{source}
  $\begin{array}{l}
      \$(\textbf{\texttt{handle}} \, {\bind{x}{\textbf{\texttt{genlet}}(\equote[e])}{\equote[x + x]}} \\
      \quad \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {u}; \textbf{\texttt{genlet}}(y, k) \mapsto {\equote[\; (\lambda z. \, \$(\continue{k}{\equote[z]})) \; y \;]}\})
    \end{array}$
 \end{source}
 \captionof{listing}{An example of let-insertion. For the program to be well-typed, the continuation $k$ should be polymorphic over classifiers. To prove that continuations are always polymorphic in this manner, the type system demands that handlers are polymorphic over classifiers as well.}%
 \label{listing:refined-environment-classifiers-let-insertion}
\end{code}

The \compilemode{}$\mid$\quotemode{}-\textsc{Lambda} rule corresponds to \textsc{C-Abs} in the refined environment classifier literature. Following \citeauthor{isoda-24}, handlers and continuations are restricted to \textsf{Code} types; However, types and typing rules are further simplified by eliminating polymorphism. To allow for let-insertion \citep{yallop-2019}, as in \Cref{listing:refined-environment-classifiers-let-insertion}, \citeauthor{isoda-24}'s typing rules for handlers and continuations are polymorphic over the classifier. In \Cref{listing:refined-environment-classifiers-let-insertion}, the \textbf{\texttt{genlet}} effect is used to generate more efficient code: $(\lambda z. z+z) e$, where $e$ is only evaluated once, rather than $e+e$. The continuation $k$ is resumed under a binder (which introduces a classifier). Thus, for the program to be well-typed, the continuation $k$ should be polymorphic over classifiers. Similarly, the type system demands that handlers are polymorphic over classifiers as well. For example, a more faithful transcription of their handler type would have the form:
\[\forall \gamma. \compiletimetype{(\handlerType{\effectType[\Delta_1]{\compiletimetype{(\textsf{Code}(\effectType[\xi_1]{S})^{\gamma})}}}{\effectType[\Delta_2]{\compiletimetype{(\textsf{Code}(\effectType[\xi_2]{T})^{\gamma})}}})}\]
The polymorphism ($\forall \gamma$) is useful when proving that programs like the one in \Cref{listing:refined-environment-classifiers-let-insertion} will produce well-scoped ASTs. 


Reasoning about the correctness of polymorphic typing rules, however, is complex. It is even more complex in \calculusName{}. Recall that \sourceLang{} does not have an operational semantics, but rather must first be elaborated into \coreLang{} terms. Thus, it is difficult to reason directly about the \sourceLang{} type system via progress and preservation. One has to appeal to alternative techniques, like Tait-style logical relations \citep{tait-67}, increasing the complexity of reasoning.

Given that the focus of this evaluation is on \sourceLang{}, rather than refined environment classifiers, I choose to simplify the type system, and minimise the complexity of reasoning. 

It is unclear whether \citeauthor{isoda-24}'s system allows for non-termination. Once again, to simplify reasoning, I force effect signatures to be well-founded and, in particular, not recursive. As proven by \citet{kammar-2013}, all well-typed programs must thus terminate. 

Proof of correctness will rely on a weakening lemma. As types are stratified into two levels, and into value, computation, and handler types, there are 6 sub-lemmas. One is listed as an example.

\newcommand{\rcqtypejudge}[4][\Gamma]{{#1} \vdash_{\compilemode \mid \quotemode}^{#2} {#3} : {#4}}
\newcommand{\rctypejudge}[4][\Gamma]{{#1} \vdash_{\compilemode}^{#2} {#3} : {#4}}
\newcommand{\rqtypejudge}[4][\Gamma]{{#1} \vdash_{\quotemode}^{#2} {#3}: {#4}}
\newcommand{\rstypejudge}[3][\Gamma]{{#1} \vdash_{\splicemode} {#2} : {#3}}

\begin{lemma}[Weakening for Level 0 Values]{sourceHighlight}
  If $\rcqtypejudge{\gamma}{e}{T^0}$ then
  \begin{enumerate}
    \item $\rcqtypejudge[\Gamma, (x:S^0)^{\gamma'}]{\gamma}{e}{T^0}$ for arbitrary $\gamma' \in \Gamma$
    \item $\rcqtypejudge[\Gamma, (x:S^{-1})]{\gamma}{e}{T^0}$ 
    \item $\rcqtypejudge[\Gamma, \gamma']{\gamma}{e}{T^0}$, for arbitrary $\gamma' \notin \Gamma$
    \item $\rcqtypejudge[\Gamma, \gamma' \sqsubseteq \gamma'']{\gamma}{e}{T^0}$, for arbitrary $\gamma', \gamma'' \in \Gamma$
  \end{enumerate}
\end{lemma}
% \vspace{-\baselineskip}
% \begin{lemma}[Weakening for Level $-1$ Values]{sourceHighlight}
%   If $\stypejudge{e}{T^{-1}}$ then
%   \begin{enumerate}
%     \item $\stypejudge[\Gamma, (x:S^0)^{\gamma'}]{e}{T^0}$ for arbitrary $\gamma' \in \Gamma$
%     \item $\stypejudge[\Gamma, (x:S^{-1})]{e}{T^{-1}}$ 
%     \item $\stypejudge[\Gamma, \gamma']{e}{T^{-1}}$, for arbitrary $\gamma' \notin \Gamma$
%     \item $\stypejudge[\Gamma, \gamma' \sqsubseteq \gamma'']{e}{T^{-1}}$, for arbitrary $\gamma', \gamma'' \in \Gamma$
%   \end{enumerate}
% \end{lemma}
Proof of the weakening lemma is by induction on the typing derivation.

Refined environment classifiers additionally require modification of the elaboration, and the reduction of \coreLang{} terms:

\begin{enumerate}
  \item Elaboration of types is defined on \textbf{extended} source types (\Cref{dfn:extended-source-type}). This allows elaboration to carry classifiers. For example, rather than elaborationg $\mathbb{N}^0$, $\mathbb{N}^0(\gamma)$ is elaborated into $\textsf{AST}(\mathbb{N})^{\gamma}$.
  \item Elaboration of contexts is extended to carry proof-theoretic terms e.g. $\gamma$ and $\gamma \sqsubseteq \gamma'$.
  \item Elaboration of top-level splice $\elaborate{\splice}_{\compilemode{}}$ is adapted to not insert \textbf{\texttt{tls}}.
  \item For simplicity, since refined environment classifiers do not require any of the machinery for dynamic scope extrusion checks, I consider the subset of \coreLang{} without \textbf{\texttt{check}} (and $\textbf{\texttt{check}}_M$), \textbf{\texttt{dlet}}, \textbf{\texttt{tls}}, and \textbf{\texttt{err}}.\ \coreLang{} configurations can thus be shortened to $\langle t;E;U\rangle$.
\end{enumerate}

To the best of my knowledge, this is the first explicit presentation of refined environment classifiers in a calculus with quotation and splices rather than code combinators. 

\begin{figure}
  \begin{source-desc}
  {\large\textbf{Refined Environment Classifiers Typing Rules}}\\
  \textit{Selected Rules}

  \begin{center}
  \begin{minipage}[t]{0.3\textwidth}
    \centering
    $\inferrule[(\compilemode{}$\mid$\quotemode{}-Var)]{(x: T^0)^\gamma \in \Gamma}{\rcqtypejudge{\gamma}{x}{\runtimecomptype{T^0}{\Delta}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.7\textwidth}
    \centering
$\inferrule[(\compilemode{}$\mid$\quotemode{}-Lambda)]{\rcqtypejudge[\Gamma, \gamma', \gamma \sqsubseteq \gamma', (x: S)^{\gamma'}]{\gamma'}{e}{\runtimecomptype{T}{\Delta;\xi}} \\
\gamma \in \Gamma \\
\gamma' \notin \Gamma
}{\rcqtypejudge{\gamma}{\lambda x.e}{\runtimecomptype{(\functionType[\xi]{S}{T})}{\Delta}}}$
\end{minipage}

\vspace{5mm}

\begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(\splicemode{}-Op)]
    {\stypejudge{v}{\compiletimetype{S}} \\ \texttt{op}: \compiletimetype{S} \rightarrow \compiletimetype{\textsf{Code}(\effectType[\xi]{T})^{\gamma}} \in \Sigma \\ \texttt{op} \in \Delta }
    {\stypejudge{\op{v}}{\effectType{\compiletimetype{\textsf{Code}(\effectType[\xi]{T})^{\gamma}}}}}$
  \end{minipage}

\vspace{5mm}

  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(\splicemode{}-Continue)]
    {\stypejudge{v_1}{\compiletimetype{\continuationType{\compiletimetype{\textsf{Code}(\effectType[\xi_1]{S})^{\gamma}}}{\compiletimetype{\textsf{Code}(\effectType[\xi_2]{T})^{\gamma'}}}}} \\ \stypejudge{v_2}{\compiletimetype{\textsf{Code}(\effectType[\xi_1]{S})^{\gamma}}}}
    {\stypejudge{\continue{v_1}{v_2}}{\effectType{\compiletimetype{\textsf{Code}(\effectType[\xi_2]{T})^{\gamma'}}}}}$
  \end{minipage}

\vspace{5mm}

\begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(\splicemode{}-Handle)]
    {\stypejudge{e}{\effectType{\compiletimetype{\textsf{Code}(\effectType[\xi]{S})^{\gamma}}}} \\ \stypejudge{h}{\compiletimetype{\handlerType{\effectType[\Delta_1]{\compiletimetype{(\textsf{Code}(\effectType[\xi_1]{S})^{\gamma})}}}{\effectType[\Delta_2]{\compiletimetype{(\textsf{Code}(\effectType[\xi_2]{T})^{\gamma})}}}}} \\ \forall \textsf{op} \in \Delta_1 \setminus \Delta_2. \, \textsf{op} \in \textsf{dom}(h)}
    {\stypejudge{\handleWith{e}{h}}{\effectType[\Delta_2]{\compiletimetype{\textsf{Code}(\effectType[\xi_2]{T})^{\gamma}}}}}$
  \end{minipage}

  \vspace{5mm}

\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\compilemode{}$\mid$\quotemode{}-Splice)]{\stypejudge[\Gamma]{e}{(\textsf{Code}(T^0 \, ! \, \xi)^{\gamma})^{-1} \, ! \, \Delta}}{\rcqtypejudge{\gamma}{\splice}{\runtimecomptype{T^0}{\Delta ; \xi}}}$
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\splicemode{}-Quote)]{\rqtypejudge{\gamma}{e}{\runtimecomptype{T}{\Delta ; \xi}}}{\stypejudge[\Gamma]{\equote}{(\textsf{Code}(T^0 \, ! \, \xi)^{\gamma})^{-1} \, ! \, \Delta}}$
\end{minipage}

  \vspace{5mm}

\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\compilemode{}$\mid$\quotemode{}-Sub)]{\rcqtypejudge{\gamma}{\splice}{\runtimecomptype{T}{\Delta ; \xi}} \\ \Gamma \vDash \gamma \sqsubseteq \gamma'}{\rcqtypejudge{\gamma'}{e}{\runtimecomptype{T}{\Delta ; \xi}}}$
\end{minipage}%
\begin{minipage}[t]{0.5\textwidth}
  \centering
  $\inferrule[(\splicemode{}-Sub)]{\stypejudge[\Gamma]{e}{\textsf{Code}(T \, ! \, \xi)^{\gamma} \, ! \, \Delta} \\ \Gamma \vDash \gamma \sqsubseteq \gamma'}{\stypejudge[\Gamma]{e}{\textsf{Code}(T \, ! \, \xi)^{\gamma'} \, ! \, \Delta}}$
\end{minipage}

\end{center}
\end{source-desc}

\caption{Selected typing rules for refined environment classifiers. The \compilemode{}$\mid$\quotemode{}-\textsc{Lambda} rule corresponds to \textsc{C-Abs} in the refined environment classifier literature. Following \citeauthor{isoda-24}, handlers and continuations are restricted to \textsf{Code} types; However, types and typing rules are simpler than the system by \citeauthor{isoda-24}, since there is no polymorphism.}
\label{fig:refined-env-classifiers-source-typing-rules}
\end{figure}

\subsection{Correctness of Refined Environment Classifiers}\label{subsection:rec-formal-correctness}
The correctness of refined environment classifiers was previously informally justified in \Cref{subsubsection:refined-environment-classifiers} (\Cpageref{subsubsection:refined-environment-classifiers}). This section shows that \calculusName{} can be used to formally reason about correctness, by proving that every well-typed \sourceLang{} term returns a well-scoped AST on termination (\Cref{thm:refined-env-classifiers-correct}). 

\begin{theorem}[Correctness of Refined Environment Classifiers]{sourceHighlight}\label{thm:refined-env-classifiers-correct}
If $\gamma_\bot \vdash ^{\gamma_\bot}_{\compilemode{}} e: T^0 \, ! \, \emptyset ; \emptyset $, and $\elaborate{e}_{\compilemode{}} = t$, \\
\noindent{}then for some $U$, $\langle t;[-]; \emptyset \rangle \to^{*} \langle \return{n}; [-] ; U \rangle$, and $\freevars{n} = \emptyset$
\end{theorem}

The proof of \Cref{thm:refined-env-classifiers-correct} is via a Tait-style logical relation. A logical relation is useful to show that typing guarantees are maintained by elaboration \citep{benton-09}.

The definition of the logical relation, \textsf{Scoped}, is presented in \Cref{fig:logical-relation-defn}. \textsf{Scoped} is defined on core language (\coreLang{}) terms, and is indexed by:
\begin{enumerate}
  \item A context of proof-theoretic terms $\Theta$. Given a context of proof theoretic terms and variables $\Gamma$, one can project out only the proof theoretic terms $\pi_{\gamma}({\Gamma})$. For example, given 
  \[\Gamma = \gamma_\bot, \gamma_1, \gamma_\bot \sqsubseteq \gamma_1, \textcolor{comment}{(x:\mathbb{N}^0)^{\gamma_1}}, \gamma_2, \gamma_1 \sqsubseteq \gamma_2,  \textcolor{comment}{y:(\textsf{Code}(\mathbb{N}^0 \, ! \, \emptyset)^{\gamma_2})^{-1}}\]
  the proof theoretic part of the context is
  \[\pi_{\gamma}({\Gamma}) = \gamma_\bot, \gamma_1, \gamma_\bot \sqsubseteq \gamma_1, \gamma_2, \gamma_1 \sqsubseteq \gamma_2 \]
  which serves as our $\Theta$.
  \item An \textbf{extended} \textit{source}-level type (\Cref{dfn:extended-source-type}). 
\end{enumerate}

The two important definitions are the logical relation on the $T^{0} (\gamma)$ value type, and the logical relation on terms. 

For a normal form $n$ to be in the relation of the $T^{0} (\gamma)$ type, $n$ must be an AST of the right type \textbf{and} the free variables of $n$ need to be permitted by $\gamma$ (permissibility was previously defined in \Cref{subsubsection:refined-environment-classifiers}, \Cpageref{subsubsection:refined-environment-classifiers}). Recall that the definition of permissibility assumes some known partial order on classifiers, e.g. $\gamma' \sqsubseteq \gamma$. The partial order is carried by the index $\Theta$. 

The logical relation on terms is defined as a least fixed point, following the definitions by \citet{plotkin-2025} and \citet{kuchta-2023}, where the well-foundedness of the definition is additionally justified. Defining the logical relation as a fixed point gives rise to the principle of \textsf{Scoped}-Induction:

\newcommand{\scoped}[2][\Theta]{\textsf{Scoped}_{{#1}, {#2}}}

\begin{definition}[\textsf{Scoped}-Induction]{sourceHighlight}
  For some property $\Phi$ on closed terms of type $\elaborate{\effectType{\tau}}$, if
  \begin{enumerate}
    \item $\langle t; [-]; U \rangle \to^{*} \langle \return{n};[-];U' \rangle$ implies $\Phi(t)$
    \item $\langle t; [-]; U \rangle \to^{*} \langle \op{n};E;U' \rangle \not\to$, with $\textsf{op}: A^{-1} \to B^{-1}$, $n \in \scoped{A^{-1}}$, and for arbitrary $n' \in \scoped{B^{-1}}$, $\Phi(E[n'])$ implies $\Phi(t)$
    % \item For every non-stuck $E[t]$, $\Phi(E[t])$ assuming for all $U$, $\langle t;E;U \rangle \to \langle t';E';U' \rangle$ implies $\Phi(E'[t'])$
  \end{enumerate}
  Then for all $t \in \scoped{\effectType{\tau}}$, $\Phi(t)$
\end{definition}

The proof additionally relies on a closure lemma \citep{kuchta-2023}

\begin{lemma}[Closure under Anti-Reduction]{sourceHighlight}\label[lemma]{lemma:closure-reduction}
  If $\langle t;E;U \rangle \to^{*} \langle t';E';U' \rangle$ and $E'[t'] \in \scoped{\effectType{\tau}}$ then $E[t] \in \scoped{\effectType{\tau}}$
\end{lemma}
% \vspace{-\baselineskip}
% \begin{lemma}[Weakening]{sourceHighlight}
%   If $\Theta'$ extends $\Theta$ and $t \in \scoped{\effectType{\tau}}$ then $t \in \scoped[\Theta']{\effectType{\tau}}$
% \end{lemma}

Finally, the proof relies on a notion of closed substitution $\rho \vDash \Gamma$. Care must be taken with substitution of level-$0$ variables, since these should be in the logical relation for \textsf{Binder}s rather than \textsf{AST}s (note the second clause in \Cref{dfn:closed-substitution}).

\begin{definition}[Closed substitution]{sourceHighlight}\label[definition]{dfn:closed-substitution}
  Given a context $\Gamma$, and assuming $\Theta = \pi_{\gamma}(\Gamma)$, the set of closed substitutions $\rho \vDash \Gamma$ are defined inductively as follows:
  \begin{enumerate}
    \item $() \vDash \gamma_{\bot}$
    \item If $\rho \vDash \Gamma$ and $n \in \scoped{\underline{T^{0} (\gamma)}}$ then $(\rho, n/x) \vDash \Gamma, (x:T^0)^{\gamma}$ 
    \item If $\rho \vDash \Gamma$ and $n \in \scoped{T^{-1}}$ then $(\rho, n/x) \vDash \Gamma, (x:T^{-1})$
    \item If $\rho \vDash \Gamma$ then $\rho \vDash \Gamma, \gamma$
    \item If $\rho \vDash \Gamma$ then $\rho \vDash \Gamma, \gamma \sqsubseteq \gamma'$
  \end{enumerate}
\end{definition}

It is now easy to show the fundamental lemma. Once again, because types are stratified, and typing judgements are indexed by a mode, the fundamental lemma decomposes into many sub-lemmas. One such is stated in \Cref{lemma:fundamental}.

\begin{lemma}[Fundamental Lemma {[\compilemode{}, {$\effectType[\Delta; \xi]{T^0}$}]} of the \textsf{Scoped} Logical Relation]{sourceHighlight} \label[lemma]{lemma:fundamental}
  If $\Gamma \vdash_{\compilemode{}}^{\gamma} e: T^{0} \, ! \, \Delta ; \xi$ then for $\Theta = \pi_\gamma({\Gamma})$, and for all $\rho$ such that $\rho \vDash \Gamma$, 
  \[\elaborate{e}_{\compilemode{}}(\rho) \in \scoped[\Theta]{T^{0} \, ! \, \Delta ; \xi (\gamma)}\]
\end{lemma}

Proof of \Cref{lemma:fundamental} is by induction on the source \sourceLang{} typing rules. I focus on an interesting case: the \textsc{\compilemode{}-Lambda} (\textsc{C-Abs}) case, where (handwaving the side-condition on $U$ for clarity) it suffices to show that for some arbitrary $\rho$, $\rho \vDash \Gamma$, 
\[\bind{x}{\gensym{\erase{S^0 (\gamma')}}}{\bind{\texttt{body}}{\elaborate{e}_{\compilemode}({\rho})}{\return{\Lam{x}{\texttt{body}}}}}\]
in $\scoped{\effectType{(\functionType[\xi]{S^0}{T^0})^0} (\gamma)}$. It is clear that this reduces to
\[{\bind{\texttt{body}}{\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x})}{\return{\Lam{\Binder{\alpha}{S^{\gamma'}}}{\texttt{body}}}}}\]
 By anti-reduction (\Cref{lemma:closure-reduction}) it suffices to show that the term above is in the logical relation. 
 
 By weakening, and the induction hypothesis, $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x}) \in \scoped[\Theta']{\effectType[\Delta; \xi]{T^{0}} (\gamma')}$, where $\Theta' = , \Theta, \gamma', \gamma \sqsubseteq \gamma'$. Applying \textsf{Scoped}-Induction on $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}}})$:
\begin{enumerate}
  \item If $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x}) \in \scoped[\Theta']{\effectType[\Delta; \xi]{T^{0}} (\gamma')}$ reduces to some $\return{n}$, then by the inductive hypothesis it is of AST type and all its free variables are permitted by $\gamma'$. The term $\bind{\texttt{body}}{\return{n}}{\Lam{\Binder{\alpha}{S^{\gamma'}}}{\texttt{body}}}$ reduces to $\Lam{\Binder{\alpha}{S^{\gamma'}}}{n}$, where $\Var{\alpha}{S^{\gamma'}}$ is bound. By the typing rules, of the free variables, $\alpha$ is the only variable tagged with classifier $\gamma'$. So under $\Theta$, we conclude that the free variables of $\Lam{\Binder{\alpha}{S^{\gamma'}}}{n}$ are permitted by $\gamma$. The conclusion thus follows from anti-reduction.
  \item If $\elaborate{e}_{\compilemode}({\rho, \Binder{\alpha}{S^{\gamma'}} / x}) \in \scoped[\Theta']{\effectType[\Delta; \xi]{T^{0}} (\gamma')}$ reduces to $E[\op{n}]$, then because the context $\bind{\texttt{body}}{[-]}{\return{\Lam{\Binder{\alpha}{S^{\gamma'}}}{\texttt{body}}}}$ introduces no handlers, the conclusion follows immediately from the inductive hypothesis.
\end{enumerate}
% \Cref{thm:refined-env-classifiers-correct} is an immediate corollary of \Cref{lemma:fundamental} and \Cref{dfn:well-typed-exp-rec}.

\begin{figure}
\begin{source-desc}
  {\large\textbf{The $\scoped{T}$ Logical Relation}}
  \vspace{5mm}

  $
  \begin{array}{@{}lllr}
    \textbf{Normal Forms} \\\vspace{2mm}
    n \in \scoped{\mathbb{N}^{-1}} & \triangleq & n \in \mathbb{N} \\ 
    n \in \scoped{{T}^{0}(\gamma)} & \triangleq & \cdot \vdash \elaborate{n} \in \elaborate{T^{0} (\gamma)} \text{ and } \Theta \vdash \freevars{n} \subseteq \textsf{permitted}(\gamma) \\\vspace{2mm}
    && \textit{(symmetric for $(\textsf{Code}(T^0)^{\gamma})^{-1}$, $\effectType[\xi]{T^{0}} (\gamma)$, etc) }\\\vspace{2mm}
    n \in \scoped{\underline{{T}^{0}(\gamma)}} & \triangleq & \varToAST{n} \in \scoped{\effectType{T^{0}} (\gamma)} \\ \vspace{2mm}
    n \in \scoped{(\functionType{{S}^{-1}}{{T}^{-1}})^{-1}} & \triangleq & \forall n' \in \scoped{{S}^{-1}}, n \, n' \in \scoped{\effectType{T^{-1}}} \\ \vspace{2mm}
    n \in \scoped{(\continuationType{{S}^{-1}}{{T}^{-1}})^{-1}} & \triangleq & \forall n' \in \scoped{{S}^{-1}}, \continue{n}{n'} \in \scoped{\effectType{T^{-1}}} \\\\ \vspace{2mm}
    \textbf{Handlers} \\
    h \in \scoped{(\handlerType{\effectType[\Delta_1]{{S}^{-1}}}{\effectType[\Delta_2]{{T}^{-1}}})^{-1}} & \triangleq & \text{if } h = \returnHandler{x}{t_{\text{ret}}}\\ \vspace{2mm}
    && \quad \forall n' \in \scoped{{S}^{-1}}, t_{\text{ret}}[n'/x] \in \scoped{\effectType[\Delta_2]{T^{-1}}} \\
    && \text{else } h = h'; \opHandler{x}{k}{t_{\text{op}}}, \textsf{op}: A^{-1} \to B^{-1} \\
    && \quad h' \in \scoped{(\handlerType{\effectType[\Delta_1]{{S}^{-1}}}{\effectType[\Delta_2]{{T}^{-1}}})^{-1}} \text{ and}\\ 
    && \quad \forall n \in \scoped{{A}^{-1}}, n' \in \scoped{\continuationType[\Delta_2]{{B}^{-1}}{T^{-1}}}, \\ && \quad t_{\text{op}}[n/x, n'/k] \in \scoped{\effectType[\Delta_2]{T^{-1}}}\\\\
  \end{array}
$

\textbf{Terms}\\
{\scriptsize{\textit{In the following, let $\effectType{\tau}$ be shorthand for any of $\effectType{T^{0}} (\gamma)$, $\effectType[\Delta; \xi]{T^{0}} (\gamma)$, $\effectType{(\handlerType{\effectType[\xi_1]{S^0}}{\effectType[\xi_2]{T^0}})^{0}} (\gamma)$, or $\effectType{T^{-1}}$}}}\\

$\scoped{\effectType{\tau}} \hspace{2mm} \triangleq \hspace{2mm}$ The smallest property on terms $t$ such that 
\begin{enumerate}
  \item For arbitrary $U$ consistent with $t$, exists $U'$ such that $\langle t;[-];U \rangle \to^{*} \langle \return{n}; [-]; U' \rangle$, such that $U'$ consistent with $n$, and $n \in \scoped{\tau}$ 
  \item For arbitrary $U$ consistent with $t$, exists $U'$ such that $\langle t;[-];U \rangle \to^{*} \langle \op{n}; E; U' \rangle \not\to$, $U'$ consistent with $E[\op{n}]$, and 
  \begin{enumerate}
    \item $\textsf{op}: A^{-1} \to B^{-1}$,
    \item $n \in \scoped{A^{-1}}$, and 
    \item for all $n' \in \scoped{B^{-1}}$, $E[n'] \in \scoped{\effectType{\tau}}$
  \end{enumerate}
  % \item $t = E[t']$, $E[t']$ not stuck, and for all $U$, there exists $t'', E', U'$ such that $\langle t';E;U \rangle \to \langle t'';E';U' \rangle$ 
\end{enumerate}
Where, in this context, consistent with $t$ means that for all $\Var{\alpha}{T}$ or $\Binder{\alpha}{T} \in t$, $\alpha \in U$. This side condition ensures that we use \textbf{\texttt{mkvar}} correctly.
\end{source-desc}
\caption{The definition of the \textsf{Scoped} logical relation. Most definitions are standard. The logical relation on terms is defined as a least fixed point, following the definitions by \citet{plotkin-2025} and \citet{kuchta-2023}, where the well-foundedness of the definition is additionally justified.}
\label{fig:logical-relation-defn}
\end{figure}

I conjecture that this proof may be extended to support non-termination by incorporating the techniques of step-indexing and biorthogonality, as demonstrated by \citet{biernacki-2017}.

\subsection{Expressiveness of Refined Environment Classifiers}\label{subsection:rec-formal-expressiveness}
The typing rules for refined environment classifiers forbid any program which attempts to extrude some variable $x$ to a handler, \textit{no matter how the handler chooses to use} $x$ (\Cref{listing:refined-environment-classifiers-expressiveness}).

\begin{code}
\begin{source}
$\begin{array}{l}
  \$ (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \, \return{\splice[(\, {{\textbf{\texttt{extrude}}(\equote[x])}} \, )]}} \, ] \\
  \;\;\,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {\underline{\textsf{any arbitrary program}}}\})
\end{array}$
\end{source}
\captionof{listing}{The typing rules for refined environment classifiers forbid any program which attempts to extrude some variable $x$ to a handler. Even if $x$ is unused, or is resumed safely, this program will not type check.}%
\label{listing:refined-environment-classifiers-expressiveness}
\end{code}


\begin{code}
\begin{source}
$\begin{array}{l}
  \$ \lambda z. (\textbf{\texttt{handle}} \; \equote[\, {\lambda x. \, \return{\splice[( \, {{\textbf{\texttt{extrude}}(\equote[z])}} \, )]}} \,] \\
  \quad \quad \,\, \textbf{\texttt{with}} \, \{ \textbf{\texttt{return}}(u) \mapsto {\return{u}}; \textbf{\texttt{extrude}}(y, k) \mapsto {\continue{k}{()}}\})
\end{array}$
\end{source}
\captionof{listing}{Refined environment classifiers allow variables to be passed via effects, so long as the variable can never cause a scope extrusion error. In the program above, performing an effect with $z$ never causes a scope extrusion error.}%
\label{listing:refined-environment-classifiers-safe}
\end{code}

Thus, even if the handler throws $x$ away, or resumes a continuation with $x$, the program in \Cref{listing:refined-environment-classifiers-expressiveness} does not type-check. Consequently, neither do \Cref{listing:eager-scope-extrusion-unsafe,listing:eager-scope-extrusion-unsafe-no-use,listing:eager-scope-extrusion-unsafe-continue,listing:eager-scope-extrusion-looks-unsafe}. Thus, refined environment classifiers are less expressive even than the eager dynamic check. 


The only variables that refined environment classifiers permit are those that never cause scope extrusion, for example, the variable $z$ in \Cref{listing:refined-environment-classifiers-safe}.



\section{Evaluation of \texorpdfstring{\sourceLang{}}{Lambda-Op-Quote-Splice}} \label{section:evaluation}
\sourceLang{} is an appropriate language in which to encode, and evaluate, scope extrusion checks. Formalising scope extrusion in \sourceLang{} provided clarity, aiding development of a novel best-effort dynamic check, which finds a sweet spot between the eager and dynamic checks. Additionally, unifying checks under a common language allows for comparative evaluation with reference to a bank of \sourceLang{} programs, which serve as litmus tests of expressiveness.

The cost of encoding static and dynamic checks into the same language is that reasoning about the correctness of static checks becomes more complicated, since one can no longer prove correctness via progress and preservation. It is difficult to reduce the complexity of reasoning, since dynamic checks (as currently defined) are inserted by elaboration. I conjecture that the added complexity of reasoning is a reasonable cost to pay for a comprehensive and comparative evaluation.


% \section{Let Insertion}