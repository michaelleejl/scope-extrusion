\section{Effect Handlers}\label{section:effects-technical}
What is an effect handler? I will first motivate effect handlers by considering the problem of adding resumable exceptions to \texttt{OCaml} (\Cref{subsection:effect-handler-motivation}). Second, I will introduce a fine-grained call-by-value calculus for studying the operational behaviour of effect handlers, à lá \citet{pretnar-15} (\Cref{subsection:effect-handler-calculus}). This calculus will be useful both for precise description of effect handlers, and as a basis for investigating the interaction between metaprogramming and effect handlers (once the calculus has been extended with metaprogramming facilities). Finally, since different design decisions for effect handlers could affect the nature of their interaction with metaprogramming, I will consider the design space of effect handlers (\Cref{subsection:effect-handler-design}).

\subsection{Composable and Customisable Effects}\label{subsection:effect-handler-motivation}
Effects are a mechanism by which a program interacts with its environment. Examples of effects include state, (resumable) exceptions, non-determinism, and I/O. Effects are typically defined and understood separately, meaning they are not easily composable. They are also implemented by compiler engineers rather than programmers, meaning they are not customisable. Effect handlers provide a programmable, unifying framework that may be instantiated into different effects. This allows for composable and customisable treatment of effects.

To illustrate the need for effect handlers, consider the following problem, by \citet{kiselyov-2012}. Assume a binary search tree of (key, value) pairs. The following code provides two functions. The first \mintinline{ocaml}{find}s a value \mintinline{ocaml}{v} associated with key \mintinline{ocaml}{k}, raising a \mintinline{ocaml}{NotFound} exception if \mintinline{ocaml}{k} is not in the tree. The second \mintinline{ocaml}{update}s the dictionary with a fresh key value pair, overwriting old values.

\begin{ocaml}
type ('a, 'b) tree = Lf | Br of 'a * 'b * tree * tree 

let rec find (t: tree) (k: 'a) = match t with 
 | Lf -> raise NotFound()
 | Br(k', v, l, r) -> if k == k' then v 
                      else if k < k' then find l k
                           else find r k

let rec update (t: tree) (k: 'a) (v: 'b) = match t with 
  | Lf -> Br(k, v, Lf, Lf)
  | Br(k', v', l, r) -> if k == k' then Br(k, v, l, r)
                       else if k < k' then Br(k', v', update l k v, r)
                            else Br(k', v', l, update r k v)
\end{ocaml}

Assume the task is to build a \mintinline{ocaml}{findOrInsert} function that either finds the value associated with a key, \textit{or} inserts a default value. A naïve approach to writing this function would be
\begin{ocaml}  
let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
  try find t k with NotFound -> insert t k default
\end{ocaml}
This function is \textbf{inefficient}. If a \mintinline{ocaml}{NotFound} exception is raised, then the \mintinline{ocaml}{find} function will have raised the exception at the point where the default value should be inserted. The function could be twice as efficient if the exception could be resumed at the point where the exception was raised, in the following style.
\begin{ocaml}
let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
  try find t k with NotFound(p) -> continue p Br(k, default, Lf, Lf)
\end{ocaml}
\mintinline{ocaml}{p} represents the suspended program to be resumed, and is known as a \textit{delimited continuation}.

The aforementioned problem motivates the need for resumable exceptions. To understand the need for effect handlers, consider how one might go about \textbf{implementing} resumable exceptions. One approach might be to fork the implementation of handlers and tweak it ever-so-slightly. This solution does not scale well. First, the solution may not be \textbf{composable}. The intended informal semantics for resumable exceptions is ``effectively equivalent to exceptions, with the additional power to resume programs''. Resumable exceptions should thus interact with other exceptions in a predictable way, but this is difficult to guarantee -- and \textit{continually} guarantee -- especially as implementations evolve, and more variants of exceptions are demanded. Second, the solution is not \textbf{customisable}. To add resumable exceptions requires a compiler engineer to modify the compiler. With the exception of raising an issue, there is nothing the programmer may do, in the moment, to meet their need.

Effect handlers resolve both composability and customisability issues. Much like how exception handlers allow users to create custom exceptions with custom semantics, effect handlers provide a general framework for creating custom effects with custom semantics. The interaction between effect handlers is described abstractly, parameterising over the exact semantics of the effect. Hence, implementing effects -- in the earlier example, resumable exceptions, but more generally, state, I/O, greenthreading, non-determinism, and more -- as effect handlers ensures composability by design. 

With effect handlers, we can re-write the previous example to obtain the behaviour of resumable exceptions, even if the \texttt{OCaml} compiler does not support it, with the guarantee that \mintinline{ocaml}{NotFound} will interact predictably with other defined effects.
\begin{ocaml}
type _ Effect.t += NotFound: unit -> tree t

let rec find (t: tree) (k: 'a) = match t with 
  | Lf -> NotFound()
  | Br(k', v, l, r) -> if k == k' then v 
                      else if k < k' then find l k
                            else find r k

let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
  match find t k with NotFound(p) with 
  | v -> v
  | effect NotFound k -> continue p Br(k, default, Lf, Lf)
\end{ocaml}
Since effect handlers may be instantiated into a range of different effects, considering the interaction of metaprogramming with effect handlers is an exercise in killing many birds with a single stone. Additionally, effect handlers were recently added to \texttt{OCaml} \citep{sivaramakrishnan-21}, making their interaction a timely problem. 
\subsection{\efflang{}: A Calculus for Effect Handlers}\label{subsection:effect-handler-calculus}
\newcommand{\print}[1]{\texttt{\textbf{print}(#1)}}
\newcommand{\readInt}[1]{\texttt{\textbf{read\_int}(#1)}}


Having motivated effect handlers, I will now describe a calculus, which I call \efflang, for reasoning about their operational behaviour.\ \efflang{} is a slight variant of the calculus described by \citet{pretnar-15}. Understanding \efflang{} will be useful for two reasons. First, a precise description of the operational behaviour of effects will aid reasoning about their interaction with metaprogramming. Second, my universal calculus will be described by extending \efflang. Throughout this section, I will use the \efflang{} program in \Cref{listing:efflang-running-example} as a running example. 

\begin{code}
  \begin{efflst}
    $\begin{array}{l}
      \textbf{\texttt{handle}} \\
      \quad \bind{x}{\print{1};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{2}}{\, x + y}}} \\
      \textbf{\texttt{with}} \\
      \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
      \quad \; \, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}\\
    \end{array}$

    \vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{(\texttt{3}, \texttt{"1;2"})}\end{array}$}

  \end{efflst}
  \captionof{listing}{An \efflang{} program that returns $(\texttt{3}, \texttt{"1;2"})$. It will be used as a running example throughout this section.}
  \label{listing:efflang-running-example}
  \end{code}

\Cref{fig:eff-lang-syntax} collates the base syntax of \efflang. In addition to this base syntax, in this section, I will assume \efflang{} is extended with the following language extensions: a unit value $()$, pairs $(\texttt{1}, \texttt{2})$ which can be destructured $\bind{(x, y)}{\return{(\texttt{1}, \texttt{2})}}{\, x+y}$, strings \texttt{"Hello"}, format strings \texttt{f"\{1\}"}, and string concatenation \texttt{\^}. For example, the following code evaluates to \texttt{"Revolution 9"}.

% \texttt{\^} \texttt{f"\{$y$\}"}}}
\begin{eff}
$\begin{array}{l}\bind{(x, y)}{\return{(\texttt{"Revolution"}, \texttt{f"\{9\}"})}}{\, x \text{ \^\ } y}\end{array}$
\vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{\texttt{"Revolution 9"}}\end{array}$}
\end{eff}
Further, I use $c_1;c_2$ as syntactic sugar for $\bind{\_}{c_1}{c_2}$. 
I will explain key language constructs in turn.
\begin{figure}[t]
  \begin{eff-desc}

  $\begin{array}{llll}
  \text{Values} & v & := & x \mid n \mid \lambda x. c \mid \kappa x.c \mid h \\

  \text{Computations} & c & := & v_1 v_2 \mid \return{v} \mid \bind{x}{c_1}{c_2} \mid \\
                             &&& \op{v} \mid \handleWith{c}{h} \mid \continue{v_1}{v_2} \\ 
  \text{Handlers} & h & := &\returnHandler{x}{c} \mid h;\opHandler{x}{k}{c}
  \end{array}$
  
  \end{eff-desc}
  \caption{The syntax of \efflang. Terms are syntactically divided into values $v$ and computations $c$ }
  \label{fig:eff-lang-syntax}
\end{figure}

\subsubsection{Sequencing computations: \texttt{do} and \texttt{return}}
Effects force us to carefully consider the order of evaluation. For example, consider the following \texttt{OCaml} programs
\begin{ocaml}
let pure      = (1+0) + (2+0)
let effectful = let l = new 0 in (l := 1; 1) + (l := 2; 2)
\end{ocaml}
The result of \mintinline{ocaml}{pure}, which has no effects, is independent of the evaluation order. In contrast, the result of \mintinline{ocaml}{effectful} \textit{is} dependent on the evaluation order. If terms are evaluated left-to-right, the value of \mintinline{ocaml}{!l} is \mintinline{ocaml}{2}, otherwise, it is \mintinline{ocaml}{1}.

In order to be precise about the order of evaluation, \efflang{} terms are stratified into two syntactic categories, ``inert values'' $v$ and ``potentially effectful computations'' $c$ \citep{pretnar-15}. $\return{v}$ lifts values into computations, and is also the result of fully evaluating a computation. $\bind{x}{c_1}{c_2}$ sequences computations, forcing programmers to be explicit the order of evaluation.  First, $c_1$ is fully evaluated to obtain some $\return{v}$. The value $v$ is then bound to $x$, and finally $c_2$ is evaluated. 

For example, extending \efflang{} with a \texttt{plus} function, what is the order of evaluation of \texttt{plus} \texttt{1} \texttt{2}? Do we evaluate both arguments before applying them, or interleave evaluation and application? The syntax forces programmers to choose explicitly. We can either fully evaluate both arguments before applying them in turn, 
\begin{eff}
$\bind{x}{\return{\texttt{1}}}{(\bind{y}{\return{\texttt{2}}}{(\bind{f}{\texttt{plus} \, x}{f y})})}$
\end{eff}
or alternatively, evaluate \texttt{1}, apply it, then evaluate \texttt{2}
\begin{eff}
$\bind{x}{\return{\texttt{1}}}{(\bind{f}{\texttt{plus} \, x}{\bind{y}{\return{\texttt{2}}}{f y}})}$
\end{eff}

Both choices are valid, but the programmer must choose. For clarity, where the ordering cannot affect the result (both of the aforementioned choices evaluate to $\return{3}$), I will abuse notation and write (for instance) $1+2$. 

\subsubsection{Performing effects: \texttt{op}, \texttt{handle}, and \texttt{continue}}
Having made explicit the order of operation, we may now add effect handlers. Recall that effect handlers allow users to register custom effects with custom semantics. I will now illustrate how this is supported by \efflang{}.

For simplicity, \efflang{} assumes that the effects have been registered in advanced, parameterising over them with the placeholder $\op{v}$. Assume that the user has declared the effects \texttt{\textbf{print}} and \texttt{\textbf{read\_int}} in advance. This would allow the user to write programs like 
\begin{eff}
$\bind{x}{\print{1};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}}$
\end{eff}

In the program fragment above, we know that \textbf{\texttt{print}} is an effect, but we do not know its semantics. Effect handlers, which comprise a \textbf{return handler} and zero or more \textbf{operation handlers}, specify how effects interact with their environment, and thus may be used to give effects meaning. I will define an effect handler that accumulates print statements in a string (some ``\texttt{stdout}'').  For example, the aforementioned program should return $(\texttt{3}, \texttt{"1; 2"})$.

We begin by considering how to handle the case where there are no calls to \textbf{\texttt{print}}. For example, in the program $\return{\texttt{3}}$. We may wish to return both the value, and the empty string (empty \texttt{stdout}) to the environment: in this case, $(\texttt{3}, \texttt{""})$. We can achieve this by specifying a \textit{return handler}.
\[\textbf{\texttt{return}}(x) \mapsto {c}\]
In this case, we set $c$ to $\return{(x, \texttt{""})}$. All effect handlers must specify a return handler. In many cases, the return handler is simply the identity ($c$ is set to $\return{x}$): for brevity and clarity, if the return handler is the identity, I may drop it. 

Next, we consider how to handle a call to \textbf{\texttt{print}}. We use an operation handler of the form 
\[\textbf{\texttt{print}}(x, k) \mapsto {c}\]
Where $c$ is the user-defined semantics for \textbf{\texttt{print}}.
Concretely, one instance of $c$ is 
\[\textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\]
In the definition of $c$, the programmer may refer to $x$ and $k$, which I will now explain. $x$ allows programs to send values (for example, values to be printed) to their environment. $k$ is a delimited continuation representing a suspended program, awaiting a value from the environment. Effects also allow programs to receive data from their environment, as in
\[1 + \textbf{\texttt{get\_int\_from\_user}}()\]
Note that the program is suspended until the value is receive. We may write the suspended program as $1 + [-]$, where $[-]$ indicates an as-yet-unknown value. This suspended program is represented by the continuation $k$. The expression 
\[\continue{k}{v}\] 
is used to resume the suspended program with value $v$. 

We are now able to interpret the concrete operation handler $c$: we resume the suspended program, supplying a unit value, since \textbf{\texttt{print}} effects do not receive values from their environment. This returns a value $v$ and some partially accumulated \texttt{stdout} $s$. We prepend the printed value, $x$, onto $s$. 
% Second, \textit{any effect can be understood in terms of send and receive operations}. Programs interact with their environment in two fundamental ways: they either \textit{receive} values from their environment (as above), or they \textit{send} values to its environment, for example via a \texttt{print}. 

% $x$, $k$, 

% where $x$ is a value sent by the program to its environment, $k$ is the program that was suspended on encountering the effect (a delimited continuation), and $c$ is a user-defined computation that specifies the semantics of \textbf{\texttt{print}}. 
% In this example, we assume that programs evaluate to tuples $(\texttt{value}, \texttt{std\_out})$. Programs may receive values from their environment: we use the syntax $\continue{k}{()}$ to give the program the unital value. Programs may also send values $x$, which are processed by the environment -- in this case, prepended to the \texttt{std\_out}. If \textbf{\texttt{print}} is given these semantics, the earlier program should return $(\texttt{3}, \texttt{"1; 2"})$.

% There is a slight complication. Our assumption is wrong: the program evalues $\return{\texttt{3}}$ -- we need to \textit{initialise} \texttt{std\_out}. This is done using a little boiler plate. Every effect handler must additionally define a \textbf{\texttt{return}} handler, which treats \textbf{\texttt{return}} as a special effect, whose semantics we may modify 
% 
Having defined the semantics for \textbf{\texttt{print}}, the user may now interpret the earlier example with their semantics, using the $\handleWith{e}{h}$ construct. Doing so results in the program in \Cref{listing:efflang-running-example}.

Notice that multiple effects may be handled by the same handler, and the same effect might be handled by multiple handlers, potentially with different semantics. 

\subsubsection{Operational Semantics}
Having described informally the desired semantics of \efflang{}, we may now make our intuitions precise, by means of an operational semantics. The operational semantics is collated in \Cref{fig:efflang-opsem}. 

\begin{figure}[ht]
  \arraycolsep=3pt
\begin{eff-desc}
  
  \renewcommand{\effconfiguration}[2]{{#1}; {#2}}
  \renewcommand{\transition}[2]{#1 & \leadsto & #2}
  \newcommand{\rulename}[2]{(\textsc{{#1}-{#2}})}
  \newcommand{\reductionRule}[1]{\rulename{Red}{#1}}
  \newcommand{\congruenceRule}[1]{\rulename{Cng}{#1}}
  \newcommand{\effectRule}[1]{\rulename{Eff}{#1}}
  \footnotesize
  \textbf{Auxiliary Definitions}
  {\scriptsize
    \[\begin{array}{lrcl}
    \text{Evaluation Frame } & F & ::= & \bind{x}{-\,}{c_2} \mid \handleWith{-}{h} \\
    \text{Evaluation Context } & E & ::= & [] \mid E::F \\ \vspace{1mm} \\
    \text{Domain of Handler} & \textsf{dom}(h) & \triangleq & \textsf{dom}(\returnHandler{x}{c}) = \emptyset, \\
    &&&\textsf{dom}(h;\opHandler{x}{k}{c}) = \textsf{dom}(h) \cup \{ \textbf{\textsf{op}} \} \\  
    \vspace{1mm} \text{Handled Effects} & \textsf{handled}(E) & \triangleq & \textsf{handled}([]) = \emptyset, \\ 
    &&& \textsf{handled}(E::\bind{x}{-\,}{c_2}) = \textsf{handled}(E), \\
    &&& \textsf{handled}(E::\handleWith{-}{h}) = \textsf{handled}(E) \cup \textsf{dom}(h),
  \end{array}
  \]}

\noindent\textbf{Operational Semantics}
  {\scriptsize
\[
  \begin{array}{rrcl}
  \reductionRule{App} & \transition{\effconfiguration{(\function{x}{c})v}{E}}{\effconfiguration{c[v/x]}{E}}\\
  \reductionRule{Seq} & \transition{\effconfiguration{\bind{x}{\return{v}}{c}}{E}}{\effconfiguration{c[v/x]}{E}}\\
  \reductionRule{Hdl} & \transition{\effconfiguration{\handleWith{\return{v}}{h}}{E}}{\effconfiguration{c[v/x]}{E}} \quad (\text{where $\returnHandler{x}{c} \in h$)}\\
  \vspace{1mm} \\ 
  \congruenceRule{Psh} & \transition{\effconfiguration{F[c]}{E}}{\effconfiguration{c}{E::F}} \\
  \congruenceRule{Pop} & \transition{\effconfiguration{\return{v}}{E::F}}{\effconfiguration{F[v]}{E}}\\
  \vspace{1mm} \\
  \effectRule{Op} & \transition{\effconfiguration{\op{v}}{E_1 @ [h] @ E_2}}\effconfiguration{c[v/x, \kappa x. \, \handleWith{E_2[\return{x}]}{h} / k]}{E_1}\\
  &&& \text{(where $\opHandler{x}{k}{c} \in h$ and $\textbf{\textsf{op}} \notin \textsf{handled}(E_2)$)}\\
  \effectRule{Cnt} & \transition{\effconfiguration{\continue{E_2}{v}}{E_1}}{\effconfiguration{\return{v}}{E_1 @ E_2}}

\end{array}
\]
  }
\end{eff-desc}
\caption{The operational semantics of \efflang. The semantics is given on configurations of the form $\langle c, E \rangle$, with the brackets dropped for clarity. Rules are divided into three classes: reduction rules $\textsc{Red-}X$, which perform computation, congruence rules $\textsc{Cng-}Y$ which manipulate the evaluation context, and effect rules $\textsc{Eff-}Z$ that are special to \efflang}
\label{fig:efflang-opsem}
\end{figure}

The operational semantics is given on configurations of the form $\effconfiguration{c}{E}$, where $c$ is a term and $E$ is an evaluation context, in the style of \citet{felleisen-87}. Evaluation contexts are represented as a stack of evaluation frames $F$, à lá \citet{kiselyov-2012}. For clarity, I will compress multiple stack frames using nesting. For example, instead of $\bind{x}{-\,}{c_2} :: \bind{y}{-\,}{c_1}$, I will write $\bind{x}{(\bind{y}{-\,}{c_1})}{c_2}$. Most of the rules are standard. We will focus on two rules: \textsc{Eff-Op}, the mechanism for giving effects custom semantics, and \textsc{Eff-Cnt}, the mechanism for resuming programs. 

To illustrate the operation of \textsc{Eff-Op} and \textsc{Eff-Cnt}, consider the evaluation of the running example in \Cref{listing:efflang-running-example}, beginning with an empty context. Let $h$ be the handler body 
\[\begin{array}{l}\{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
\; \, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}\end{array}\]
After several applications of \textsc{Cng-Pop}, we obtain the configuration
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \print{1} &;& \handleWith{-}{h} :: \\
                        && \bind{x}{-;\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}} \, \rangle
\end{array}
  \]
}

Let $E = \bind{x}{\return{u};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}}$. Applying \textsc{Eff-Op}, we can suspend the program, find the handler $h$ with the user's semantics for \textbf{\texttt{print}}, and give the \textbf{\texttt{print}} effect the desired semantics
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \bind{(v, s)}{\continue{(\continuation{u}{E})}{()}}{\return{(v, \texttt{f"\{$1$\};"} \text{ \^\ } s)}} &;& \handleWith{-}{h} \, \rangle
\end{array}
  \]
}
Applying \textsc{Cng-Pop},
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \continue{(\continuation{u}{E})}{()} &;& \handleWith{-}{h} :: \\
                              && \bind{(v, s)}{-\,}{\return{(v, \texttt{f"\{$1$\};"} \text{ \^\ } s)}} \, \rangle
\end{array}
  \]
}
Applying \textsc{Eff-Cnt}, we can resume the program that was suspended
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \return{()} &;& \handleWith{-}{h} :: \\
                              && \bind{(v, s)}{-\,}{\return{(v, \texttt{f"\{$1$\};"} \text{ \^\ } s)}} \\
                              && \bind{x}{-;\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}} \, \rangle
\end{array}
  \]
}
The side-condition on \textsc{Eff-Op} is needed because the user may define multiple handlers with different semantics for the same effect. The side-condition resolves any ambiguity by using the \textit{latest} handler. For example, the following program has a \textbf{\texttt{read}} effect that is given two definitions: it could read either \texttt{1} or \texttt{2}. The ambiguity is resolved by choosing the latest handler: in this case, \texttt{1}.
\begin{eff}
$\begin{array}{l}
  \textbf{\texttt{handle}} \\
  \quad \handleWith{\textbf{\texttt{read}()}}{\returnHandler{y}{\return{y}}; \textbf{\texttt{read}}(x, k) \mapsto {\continue{k}{1}}} \\
  \textbf{\texttt{with}} \\ 
  \quad \{ \returnHandler{y}{\return{y}}; \textbf{\texttt{read}}(x, k) \mapsto {\continue{k}{2}} \}
\end{array}$ 

\vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{\texttt{1}}\end{array}$}
\end{eff}


\subsubsection{Type-and-Effect System}
We now give a type-and-effect system to \efflang{}. \Cref{fig:efflang-type-syntax} collates the syntax of \efflang{} types, which I will now briefly describe. 

\begin{figure}
  \begin{eff-desc}
  $\begin{array}{llllr}
    \text{Effects row} & \Delta & ::= & \emptyset \mid \Delta \cup \{ \texttt{op}_i \} \\ \\
    \text{Value type} & T & ::= & \mathbb{N} & \\
                              &&& \mid \functionType{T_1}{T_2} & \text{functions}\\
                              &&& \mid \handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}} & \text{handlers} \\
                              &&& \mid \continuationType{T_1}{T_2} & \text{continuations}\\ \\
    \text{Computation type} & \effectType{T}
  \end{array}$
  \end{eff-desc}
  \caption{\efflang{} types. Notice that, just as terms are divided into values and computations, types are divided into value types ($T$) and computation types ($\effectType{T}$)}
  \label{fig:efflang-type-syntax}
\end{figure}

Syntactically, just as terms are divided into values and computations, types are divided into value types (for example, $\mathbb{N}$) and computation types (for example, $\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}$). Since computations may have effects, computation types track unhandled effects using an effects row (typically labelled $\Delta$), which in this system is simply a set. This type-and-effect system allows us to distinguish between values, computations that return values, and computations that return values and additionally have some unhandled side effects.
\[
\begin{array}{lll}
  \textbf{Term} &\hspace{8mm}& \textbf{Type} \\
  3 && \mathbb{N} \\ 
  \bind{x}{\return{1}}{\bind{y}{\return{2}}{x + y}} &&  \effectType[\emptyset]{\mathbb{N}} \\ 
  \bind{x}{\texttt{\textbf{print}($1$)}; \return{1}}{\bind{y}{\return{2}}{x + y}} &&  \effectType[\{ \texttt{\textbf{print}}\}]{\mathbb{N}} \\ 
\end{array}
\]

Functions are values, and are applied to other values, but produce computations on application. For example, the function 
\[
\function{x:\mathbb{N}}{\, \textbf{\texttt{print}}(x); \return{x}}
\]
is a value that accepts a value of type $\mathbb{N}$ and returns a computation of type $\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}$. We thus say functions have suspended effects, which we write $\functionType{T_1}{T_2}$. In this case, the function has type $\functionType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}{\mathbb{N}}$. For technical reasons, continuations and functions need to be distinguished, but in most cases they may be treated equivalently. 

Handlers transform computations of one type to computations of another type. This happens in two ways: first, by handling effects, and thus removing them from the effects row (which recall represents unhandled effects). Second, by modifying the return type of computations. To reflect both abilities, handlers are given a type of the form $\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}$. For example, a handler of the form  
\[ \begin{array}{ll}
  \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
    \quad \, \,\, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}
  \end{array}
\]
may be given type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$, reflecting both the handling of the \textbf{\texttt{print}} effect and the transformation of the return type to include the collated print statements.

I now consider the typing rules for terms, which are collated in \Cref{fig:efflang-type-system}. Most rules are standard, but a few are worth paying attention to. 

\begin{figure}[t]
  \begin{eff-desc}
    \centering 
    \begin{minipage}[t]{0.2\textwidth}
      \centering
      $\inferrule[(Nat)]
      { \\ }
      {\type{n}{\mathbb{N}}}$
      \end{minipage}% 
  \begin{minipage}[t]{0.2\textwidth}
    \centering
  $\inferrule[(Var)]
  {\Gamma(x) = T}
  {\type{x}{T}}$
  \end{minipage}% 
  \begin{minipage}[t]{0.3\textwidth}
    \centering
  $\inferrule[(Lambda)]
    {\type[, x:T_1]{c}{\effectType{T_2}}}
    {\type{\function{x}{c}}{\functionType{T_1}{T_2}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.3\textwidth}
  \centering
$\inferrule[(Continuation)]
  {\type[, x:T_1]{c}{\effectType{T_2}}}
  {\type{\continuation{x}{c}}{\continuationType{T_1}{T_2}}}$
\end{minipage}
  
  \vspace{5mm}
  
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(App)]
    {\type{v_1}{T_1 \oset{\text{\tiny{$\Delta$}}}\longrightarrow T_2} \\ \type{v_2}{T_1}}
    {\type{v_1 \, v_2}{\effectType{T_2}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Continue)]
    {\type{v_1}{\continuationType{T_1}{T_2}} \\ \type{v_2}{T_1}}
    {\type{\continue{v_1}{v_2}}{\effectType{T_2}}}$
  \end{minipage}

  \vspace{5mm}

  \begin{minipage}[t]{0.3\textwidth}
    \centering
  $\inferrule[(Return)]
    {\type{v}{T}}
    {\type{\return{v}}{\effectType{T}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.55\textwidth}
    \centering
  $\inferrule[(Do)]
    {\type{c_1}{\effectType{T_1}} \\ \type[, x: T_1]{c_2}{\effectType{T_2}}}
    {\type{\bind{x}{c_1}{c_2}}{\effectType{T_2}}}$
  \end{minipage}
  
  \vspace{5mm}
  % \begin{minipage}[t]{0.5\textwidth}
  %   \centering
  % $\inferrule[(Do)]
  %   {\type{c_1}{\effectType{T_1}} \\ \type[, x: T_1]{c_2}{\effectType{T_2}}}
  %   {\type{\bind{x}{c_1}{c_2}}{\effectType{T_2}}}$
  % \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Op)]
    {\type{v}{T_1} \\ \texttt{op}: T_1 \rightarrow T_2 \in \Sigma \\ \texttt{op} \in \Delta}
    {\type{\op{v}}{\effectType{T_2}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Handle)]
    {\type{c}{\effectType{T_1}} \\ \type{h}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}} \\ \forall \textsf{op} \in \Delta \setminus \Delta'. \textsf{op} \in \textsf{dom}(h)}
    {\type{\handleWith{c}{h}}{\effectType[\Delta']{T_2}}}$
  \end{minipage}\\

  \vspace{5mm}

  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(Ret-Handler)]
    {\type[, x:T_1]{c}{\effectType[\Delta']{T_2}}}
    {\type{\returnHandler{x}{c}}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}}$
  \end{minipage}
  
  \vspace{5mm}
  % \[\inferrule [(Lam)]
  % {\type[, x:T_1]{t}{\sEffect{T_2}}}
  % {\type{\function{x}{t}}{\sFunctionType{T_1}{T_2}}}\]
  
  % \[\inferrule[(App)]
  % {\type{n_1}{\sFunctionType{T_1}{T_2}} \\
  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(Op-Handler)]
    { \texttt{op}: A \to B \in \Sigma \\\\ 
      \type{h}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}\\
      \type[, x:A, k:{\continuationType[\Delta']{B}{T_2}} ]{c}{\effectType[\Delta']{T_2}}\\
      \Delta' \subseteq \Delta \setminus \{ \texttt{op} \} \\
             \opHandler{x'}{k'}{c'} \notin h}
    {\type{h ; \opHandler{x}{k}{c}}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}}$
  \end{minipage}
  \end{eff-desc}
  \caption{Typing rules for \efflang{} terms}
  \label{fig:efflang-type-system}
  \end{figure}

First, the \textsc{Return} and \textsc{Do} rules. In the \textsc{Return} rule, we are allowed to assign the term $\return{v}$ any set of effects. For example, we could write:
\[\inferrule{ }{\type[]{\return{\texttt{0}}}{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}}\] 
This flexibility is important, because to type $\bind{x}{c_1}{c_2}$, the \textsc{Do} rule requires both $c_1$ and $c_2$ to have the same effects. For example, without this flexibility, we would not be able to complete the following typing derivation
\[\inferrule{\vdots}{\type[]{\bind{x}{\print{0}}{\return{\texttt{0}}}}{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}}\] 
A valid alternative would be to forbid this flexibility and add explicit subtyping. However, such an approach would no longer be syntax directed. 

Second, the \textsc{Op} rule. Previously, we assumed that the user declared their effects in advance. We also assume that they declare the types of their effects in advance, and that we we store the mapping from effects to types in $\Sigma$. For example, we might assume $\Sigma = \{ \textbf{\texttt{print}}: \mathbb{N} \to 1 \}$. In \texttt{OCaml}, this would correspond to writing:
\begin{ocaml}
type _ Effect.t += Print: nat -> unit
\end{ocaml}
Note further the $\texttt{op} \in \Delta$ restriction -- flexibility allows us to over-approximate the effects in a term, but never underapproximate them. 

Third, the \textsc{Ret-Handler} and \textsc{Op-Handler} rules, which are used to type handlers, which I will explain by means of an example. Assume we are trying to type the handler 
\[ \begin{array}{ll}
  \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
    \quad \, \,\, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}
  \end{array}
\]
with the type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$. We apply the \textsc{Op-Handler} rule, which is transcribed below. Preconditions are numbered for reference. 
\[\inferrule[(Op-Handler)]
    { (1)\,  \texttt{op}: A \to B \in \Sigma \\\\
     (2)\, \type{h}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}\\
      (3)\,\type[, x:A, k:{\continuationType[\Delta']{B}{T_2}} ]{c}{\effectType[\Delta']{T_2}}\\
      (4)\,\Delta' \subseteq \Delta \setminus \{ \texttt{op} \} \\
      (5)\, \opHandler{x'}{k'}{c'} \notin h}
    {\type{h ; \opHandler{x}{k}{c}}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}}\]
The preconditions of the \textsc{Op-Handler} rule direct us to check, in turn:
\begin{enumerate}
  \item[(1)] $\textbf{\texttt{print}}: \mathbb{N} \to 1 \in \Sigma$, which is true by assumption
  \item[(2)] Recursively check the rest of the handler $h = \returnHandler{x}{\return{(x, \texttt{""})}}$, ensuring it has type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$. This follows from a trivial application of the \textsc{Ret-Handler} rule. 
  \item[(3)] Assuming $x$ has type $\mathbb{N}$ and $k$ has type $\continuationType[\emptyset]{1}{(\mathbb{N} \times \textsf{String})}$, the body \[{\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\] has type $\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}$. This is easy to show.
  \item[(4)] That the handler \textit{only} removes \textbf{\texttt{print}} from the effects row, and no other effects. This check passes, but would fail if we tried to type the handler with, for example, $\handlerType{\effectType[\{ \textbf{\texttt{print}}, \textbf{\texttt{get}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$
  \item[(5)] That there are no other handlers for \textbf{\texttt{print}} in $h$.
\end{enumerate}
A full typing derivation may be found in the appendix.

\subsection{The Design Space of Effect Handlers}\label{subsection:effect-handler-design}