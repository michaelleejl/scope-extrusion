\section{Effect Handlers}\label{section:effects-technical}
What is an effect handler? \Cref{subsection:effect-handler-motivation} first motivates effect handlers, as a way to build composable and customisable effects. \Cref{subsection:effect-handler-calculus} introduces a calculus for studying the operational behaviour of effect handlers, à la \citet{pretnar-15}. This calculus is useful both for precise description of effect handlers, and as a basis for investigating the interaction between metaprogramming and effect handlers. Finally, since different design decisions for effect handlers could affect the nature of their interaction with metaprogramming, \Cref{subsection:effect-handler-design} considers the design space of effect handlers.

\subsection{Effect Handlers: Composable and Customisable Effects}\label{subsection:effect-handler-motivation}
Effects are a mechanism by which a program interacts with its environment. Examples of effects include state, (resumable) exceptions, non-determinism, and I/O. Different effects are typically defined and understood separately from each other, meaning they are not easily composable. They are also typically implemented by compiler engineers rather than programmers, meaning they are not customisable. In contrast, effect handlers provide a unifying (composable) and programmable (customisable) framework that may be instantiated into different effects \citep{kiselyov-2012}.

% To illustrate the need for effect handlers, consider the following problem, by \citet{kiselyov-2012}. Assume a binary search tree of (key, value) pairs. The following code provides two functions. The first \mintinline{ocaml}{find}s a value \mintinline{ocaml}{v} associated with key \mintinline{ocaml}{k}, raising a \mintinline{ocaml}{NotFound} exception if \mintinline{ocaml}{k} is not in the tree. The second \mintinline{ocaml}{update}s the dictionary with a fresh key value pair, overwriting old values.

% \begin{ocaml}
% type ('a, 'b) tree = Lf | Br of 'a * 'b * tree * tree 

% let rec find (t: tree) (k: 'a) = match t with 
%  | Lf -> raise NotFound()
%  | Br(k', v, l, r) -> if k == k' then v 
%                       else if k < k' then find l k
%                            else find r k

% let rec update (t: tree) (k: 'a) (v: 'b) = match t with 
%   | Lf -> Br(k, v, Lf, Lf)
%   | Br(k', v', l, r) -> if k == k' then Br(k, v, l, r)
%                         else if k < k' then Br(k', v', update l k v, r)
%                         else Br(k', v', l, update r k v)
% \end{ocaml}

% Assume the task is to build a \mintinline{ocaml}{findOrInsert} function that either finds the value associated with a key, \textit{or} inserts a default value. A naïve approach to writing this function would be
% \begin{ocaml}  
% let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
%   try find t k with NotFound -> insert t k default
% \end{ocaml}
% This function is \textbf{inefficient}. If the \mintinline{ocaml}{find} function raises a \mintinline{ocaml}{NotFound} exception, it will do so at the point where the default value should be inserted. If computation could be resumed at the point where the exception was raised, as such:
% \begin{ocaml}
% let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
%   try find t k with NotFound(p) -> continue p Br(k, default, Lf, Lf)
% \end{ocaml}
% then the function could be twice as fast. \mintinline{ocaml}{p} represents the suspended program to be resumed, and is known as a \textit{delimited continuation}.

% The aforementioned problem motivates the need for resumable exceptions. 
% To illustrate how effect handlers may be useful, consider the problem of adding resumable exceptions to an existing language . One approach might be to fork the implementation of exception handlers. This solution does not scale well. First, the solution may not be \textbf{composable}. The intended informal semantics for resumable exceptions is ``effectively equivalent to exceptions, with the additional power to resume programs''. Resumable exceptions should thus interact with other exceptions in a predictable way, but this is difficult to guarantee, and \textit{continually} guarantee. Second, the solution is not \textbf{customisable}. Adding resumable exceptions requires a compiler engineer to modify the compiler. With the exception of raising an issue, there is nothing the programmer may do, in the moment, to meet their need.

Much like how exception handlers allow the programmer to define custom exceptions that can be handled differently, effect handlers provide a general framework for creating custom effects with custom semantics. The interaction between effect handlers is described abstractly, parameterising over the exact semantics of the effect. Hence, implementing effects as effect handlers ensures compositionality by design. 

% With effect handlers, we can re-write the previous example to obtain the behaviour of resumable exceptions, even if the \texttt{OCaml} compiler does not support it, with the guarantee that \mintinline{ocaml}{NotFound} will interact predictably with other defined effects.
% \begin{ocaml}
% type _ Effect.t += NotFound: unit -> tree t

% let rec find (t: tree) (k: 'a) = match t with 
%   | Lf -> NotFound()
%   | Br(k', v, l, r) -> if k == k' then v 
%                       else if k < k' then find l k
%                             else find r k

% let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
%   match find t k with NotFound(p) with 
%   | v -> v
%   | effect NotFound k -> continue p Br(k, default, Lf, Lf)
% \end{ocaml}

Since effect handlers may be instantiated into a range of different effects, considering the interaction of metaprogramming with effect handlers is an exercise in killing many birds with a single stone. Additionally, effect handlers were recently added to \texttt{OCaml} \citep{sivaramakrishnan-21}, making their interaction with metaprogramming a timely problem. 
\subsection{\texorpdfstring{\efflang{}}{Lambda-Op}: A Calculus for Effect Handlers}\label{subsection:effect-handler-calculus}
\newcommand{\print}[1]{\texttt{\textbf{print}}(\texttt{#1})}
\newcommand{\readInt}[1]{\texttt{\textbf{read\_int}(#1)}}


This section presents a calculus, \efflang{}, for reasoning about the operational behaviour of effect handlers.\ \efflang{} is broadly similar to the calculus described by \citet{pretnar-15}\footnote{Differences will be clarified as they arise}, and will be used in later sections to study the interaction between effect handlers and metaprogramming. 


\Cref{fig:eff-lang-syntax} collates the base syntax of \efflang{}. In this section, I additionally assume \efflang{} supports a unit value (), pairs with pattern matching, strings with concatenation and \texttt{Python}-style format strings. 

For example, treating $\bind{x}{c_1}{c_2}$ as a let-binding (and ignoring \textbf{\texttt{return}}, which is explained shortly), the following code evaluates to \texttt{"Revolution 9"}:

% \texttt{\^} \texttt{f"\{$y$\}"}}}
\begin{eff}
$\begin{array}{l}\bind{(x, y)}{\return{(\texttt{"Revolution"}, \texttt{f"\{9\}"})}}{\, x \text{ \^\ } y}\end{array}$
\vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{\texttt{"Revolution 9"}}\end{array}$}
\end{eff}
Further, I use $c_1;c_2$ as syntactic sugar for $\bind{\_}{c_1}{c_2}$. 
This section explains key language constructs in turn, with reference to a running example: the \efflang{} program in \Cref{listing:efflang-running-example}. 


\begin{code}
  \begin{efflst}
    $\begin{array}{l}
      \textbf{\texttt{handle}} \\
      \quad \bind{x}{\print{1};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}} \\
      \textbf{\texttt{with}} \\
      \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
      \quad \; \, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}\\
    \end{array}$

    \vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{(\texttt{3}, \texttt{"1;2"})}\end{array}$}

  \end{efflst}
  \captionof{listing}{A \efflang{} program that returns $(\texttt{3}, \texttt{"1;2"})$. It is used as a running example throughout this section.}
  \label{listing:efflang-running-example}
  \end{code}

\begin{figure}
  \begin{eff-desc}
    {\large{\textbf{Syntax}}}
\vspace{2mm}

  $\begin{array}{@{}llll}
  \text{Values} & v & := & x \mid m \in \mathbb{N} \mid \lambda x. c \mid \kappa x.c\\

  \text{Computations} & c & := & v_1 v_2 \mid \return{v} \mid \bind{x}{c_1}{c_2} \\
                             &&& \mid \op{v} \mid \handleWith{c}{h} \mid \continue{v_1}{v_2} \\ 
  \text{Handlers} & h & := &\returnHandler{x}{c} \mid h;\opHandler{x}{k}{c}
  \end{array}$
  
  \end{eff-desc}
  \caption{The syntax of \efflang{}. Terms are syntactically divided into values $v$, computations $c$, and handlers $h$ }
  \label{fig:eff-lang-syntax}
\end{figure}

\subsubsection{Sequencing computations: \texttt{do} and \texttt{return}}
Effects force us to carefully consider the order of evaluation. For example, consider the following \texttt{OCaml} program:
\begin{ocaml}
let pure      = (1+0) + (2+0)
let effectful = let l = ref 0 in (l := 1; 1) + (l := 2; 2)
\end{ocaml}
The result of \mintinline{ocaml}{pure}, which has no effects, is independent of the evaluation order. In contrast, the result of \mintinline{ocaml}{effectful} \textit{is} dependent on the evaluation order. If terms are evaluated left-to-right, the value of \mintinline{ocaml}{!l} is \mintinline{ocaml}{2}, otherwise, it is \mintinline{ocaml}{1}.

In order to be precise about the order of evaluation, \efflang{} follows \citeauthor{pretnar-15}'s approach of stratifying terms into distinct syntactic categories, with ``inert values'' ($v$) disjoint from ``potentially effectful computations'' ($c$). However, while \citeauthor{pretnar-15} treats handlers $h$ as values, in \efflang{}, they are a third syntactic category, disjoint from both values and computations. $\return{v}$ lifts values into computations, and is also the result of fully evaluating a computation. $\bind{x}{c_1}{c_2}$ acts like a let-binding, sequencing computations. This forces programmers to make explicit the order of evaluation.  First, $c_1$ is fully evaluated to obtain some $\return{v}$. The value $v$ is then bound to $x$, and finally $c_2$ is evaluated. 

For example, extending \efflang{} with a \texttt{plus} function, what is the order of evaluation of \texttt{plus} $c_1$ $c_2$, where $c_1$ and $c_2$ are computations that evaluate to naturals? Are both arguments evaluated before application, or are evaluation and application interleaved? The syntax forces programmers to choose explicitly. The programmer can either fully evaluate both arguments before applying them in turn: 
\begin{eff}
$\bind{x}{c_1}{(\bind{y}{c_2}{(\bind{f}{\texttt{plus} \, x}{f y})})}$
\end{eff}
or alternatively, interleave evaluation and application:
\begin{eff}
$\bind{x}{c_1}{(\bind{f}{\texttt{plus} \, x}{(\bind{y}{c_2}{f y})})}$
\end{eff}

Both choices are valid, but the programmer must choose. For clarity, where the order cannot affect the result (for example, $c_1 = \return{\texttt{1}}$, $c_2 = \return{\texttt{2}}$), I abuse notation and write $c_1+c_2$. Similarly, I implicitly cast values to computations (writing $\texttt{1}+\texttt{2}$ rather than $\return{\texttt{1}} + \return{\texttt{2}}$).

\subsubsection{Performing effects: \texttt{op}, \texttt{handle}, and \texttt{continue}}
Recall that effect handlers allow users to register custom effects with custom semantics.\ \efflang{} assumes that the effects have been registered in advanced, parameterising over them with the placeholder $\op{v}$. Assume that the user has declared the effect \texttt{\textbf{print}} in advance. They may thus write programs which refer to \texttt{\textbf{print}}:
\begin{eff}
$\bind{x}{\print{1};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}}$
\end{eff}

In the program fragment above, \textbf{\texttt{print}} is an effect, but with as-yet-unknown semantics. Effect handlers, which comprise a \textbf{return handler} and zero or more \textbf{operation handlers}, specify how effects interact with their environment, and thus may be used to give effects meaning. Consider defining an effect handler that accumulates print statements in a string (some ``\texttt{stdout}'').  For example, the aforementioned program should return $(\texttt{3}, \texttt{"1; 2"})$.

% I begin by considering how to handle the case where there are no calls to \textbf{\texttt{print}}. For example, in the program $\return{\texttt{3}}$. I wish to return both the value and an empty string: in this case, $(\texttt{3}, \texttt{""})$. I achieve this by specifying a \textit{return handler}, of the form:
First, an effect handler must handle programs that have no calls to \textbf{\texttt{print}}. For such a program, the accumulating handler should return both the value and the empty string: $(\texttt{3}, \texttt{""})$. The return handler is written as follows:
\[\textbf{\texttt{return}}(x) \mapsto {c}\]
where $c$ is set to $\return{(x, \texttt{""})}$. All effect handlers must specify a return handler. In many cases, the return handler is simply the identity. 

Next, an effect handler must handle programs that perform \textbf{\texttt{print}} effects, by specifying an operation handler of the form:
\[\textbf{\texttt{print}}(x, k) \mapsto {c}\]
where $c$ is the user-defined semantics for \textbf{\texttt{print}}.
Concretely, one instance of $c$ is 
\[{\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\]
In the definition of $c$, the programmer may refer to $x$, the argument passed to \textbf{\texttt{print}}, and $k$, a delimited continuation from the point the effect was performed to the point it was handled. The delimited continuation can be thought of as a suspended program, awaiting a value from its environment. Effects allow programs to receive data from their environments, as in:
\begin{center}
  \begin{tikzpicture}
   \node[] (example) {\textcolor{white}{$\handleWith{\textcolor{black}{\;\;\;\; \textcolor{selected}{\textbf{\texttt{get\_int\_from\_user}} \;\; () \;\;} + \texttt{1}}\;\;\;\; }{\textbf{\texttt{get\_int\_from\_user}}(x, k) \mapsto \ldots}$}};

   \begin{scope}[on background layer]
    \draw[draw=fade, fill=selectedTarget, rounded corners=1mm] ($(example.north west) + (-0.1, 0.04)$) rectangle ($(example.south west) + (1.64, 0)$);

    \draw[draw=fade, fill=selectedTarget, rounded corners=1mm] ($(example.north east) + (0.1, 0.04)$) rectangle ($(example.south east) + (-7.3, 0)$);
   \end{scope}

   \node[rotate = 90, text=comment] (brace) at ($(example.south) + (-0.7, -0.1)$) {\Large \{ };

   \node[text=comment, anchor = north, align=center] (comment) at ($(brace.south)$) {\footnotesize The delimited continuation \textcolor{black}{$\kappa y. y+\texttt{1}$},\\
   \footnotesize captured from \textcolor{selected}{\textbf{the point the effect was}} \\ 
   \footnotesize \textcolor{selected}{\textbf{performed}} to \colorbox{selectedTarget}{\textcolor{white}{\textbf{the point it was handled}}}};

   \draw[->,>=stealth'] ($(comment.east) + (-0.3, 0.6)$) -| ($(example.south) + (5.52, -0.1)$);

   \node[rotate = -90, text=comment] (brace2) at ($(example.north) + (-1.5, 0.1)$) {\Large \{ };


   \node[text=comment, anchor = south, align=center] (comment2) at ($(brace2.north)$) {\footnotesize Effect raises {unit value} \textcolor{black}{$()$}};

      
   \draw[->,>=stealth'] ($(comment2.east)$) -| ($(example.south) + (5.1, 0.8)$);


  \end{tikzpicture}
\end{center}
\noindent where the program that adds one is suspended until the value is received. I write the suspended program as $\kappa y. \; y+\texttt{1}$, where the variable $y$ represents the as-yet-unknown value. $\kappa y. \; y+\texttt{1}$ is the continuation bound to $k$. The syntax is evocative: continuations can be thought of as being \textit{like}  functions $\lambda y. \; y+\texttt{1}$ (in \citeauthor{pretnar-15}'s calculus, functions and continuations share a type). However, for technical reasons relating to scope extrusion (\Cref{section:best-effort-check,section:refined-environment-classifiers-formal}), in \efflang{}, continuations and functions are disambiguated both syntactically and at the type-level (mirroring the approach by \citet{isoda-24}). The expression 
\[\continue{k}{v}\] 
is used to resume the suspended program, substituting value $v$ for $y$. For example,  
\[\handleWith{\textbf{\texttt{get\_int\_from\_user}}() + \texttt{1}}{\textbf{\texttt{get\_int\_from\_user}}(x, k) \mapsto \continue{k}{\texttt{2}}}\]
steps to $\texttt{2} + \texttt{1}$ (and thus evaluates to \texttt{3}).

In \efflang{}, the continuation to be bound to $k$ is calculated. In contrast, in \citeauthor{pretnar-15}'s calculus, it is explicitly written by the programmer, using the syntax 
\[\op{v; y.c}\]
where $y.c$ is the continuation to be bound to $k$.\ \citeauthor{pretnar-15} acknowledges that the approach adopted by \efflang{} is an equivalent formulation.

The concrete operation handler thus resumes the suspended program, supplying a unit value, since \textbf{\texttt{print}} effects are ``write-only''. Evaluating the (now unsuspended) program eventually returns a value $v$ and some partially accumulated \texttt{stdout} $s$. The handler then prepends the printed value, $x$, onto $s$. 
% Second, \textit{any effect can be understood in terms of send and receive operations}. Programs interact with their environment in two fundamental ways: they either \textit{receive} values from their environment (as above), or they \textit{send} values to its environment, for example via a \texttt{print}. 

% $x$, $k$, 

% where $x$ is a value sent by the program to its environment, $k$ is the program that was suspended on encountering the effect (a delimited continuation), and $c$ is a user-defined computation that specifies the semantics of \textbf{\texttt{print}}. 
% In this example, we assume that programs evaluate to tuples $(\texttt{value}, \texttt{std\_out})$. Programs may receive values from their environment: we use the syntax $\continue{k}{()}$ to give the program the unital value. Programs may also send values $x$, which are processed by the environment -- in this case, prepended to the \texttt{std\_out}. If \textbf{\texttt{print}} is given these semantics, the earlier program should return $(\texttt{3}, \texttt{"1; 2"})$.

% There is a slight complication. Our assumption is wrong: the program evalues $\return{\texttt{3}}$ -- we need to \textit{initialise} \texttt{std\_out}. This is done using a little boiler plate. Every effect handler must additionally define a \textbf{\texttt{return}} handler, which treats \textbf{\texttt{return}} as a special effect, whose semantics we may modify 
% 
Having defined the semantics for \textbf{\texttt{print}}, the user may now interpret the earlier example with their semantics, using the $\handleWith{e}{h}$ construct. Doing so results in the program in \Cref{listing:efflang-running-example}.

Notice that multiple effects may be handled by the same handler, and different instances of the same effect might be handled by multiple handlers, potentially with different semantics. 

\subsubsection{Operational Semantics}
The operational semantics of \efflang{} (\Cref{fig:efflang-opsem}) is given on configurations of the form $\effconfiguration{c}{E}$, where $c$ is a term and $E$ is an evaluation context, in the style of \citet{felleisen-87}. Evaluation contexts are represented as a stack of evaluation frames $F$, à la \citet{kiselyov-2012}. The two key rules are \textsc{Eff-Op}, the mechanism for giving effects custom semantics, and \textsc{Eff-Cnt}, the mechanism for resuming programs. 

\begin{figure}[ht]
  \arraycolsep=3pt
\begin{eff-desc}
  
  {\large\textbf{Operational Semantics}}\\

  \renewcommand{\effconfiguration}[2]{\langle {#1}; {#2} \rangle}
  \renewcommand{\transition}[2]{#1 & \rightarrow & #2}
  \newcommand{\rulename}[2]{(\textsc{{#1}-{#2}})}
  \newcommand{\reductionRule}[1]{\rulename{Red}{#1}}
  \newcommand{\congruenceRule}[1]{\rulename{Cng}{#1}}
  \newcommand{\effectRule}[1]{\rulename{Eff}{#1}}
  \footnotesize
  \textbf{Auxiliary Definitions}
  {\footnotesize
    \[\begin{array}{lrcl}
    \text{Evaluation Frame } & F & ::= & \bind{x}{[-]\,}{c_2} \mid \handleWith{[-]}{h} \\
    \text{Evaluation Context } & E & ::= & [-] \mid E[F] \\ \vspace{1mm} \\
    \text{Domain of Handler} & \textsf{dom}(h) & \triangleq & \textsf{dom}(\returnHandler{x}{c}) = \emptyset, \\
    &&&\textsf{dom}(h;\opHandler{x}{k}{c}) = \textsf{dom}(h) \cup \{ \textbf{\textsf{op}} \} \\  
    \vspace{1mm} \text{Handled Effects} & \textsf{handled}(E) & \triangleq & \textsf{handled}([-]) = \emptyset, \\ 
    &&& \textsf{handled}(E[\bind{x}{[-]\,}{c_2}]) = \textsf{handled}(E), \\
    &&& \textsf{handled}(E[\handleWith{[-]}{h}]) = \textsf{handled}(E) \cup \textsf{dom}(h),
  \end{array}
  \]}

{\noindent\textbf{Operational Semantics}}
  {\footnotesize
\[
  \begin{array}{rrcl}
  \reductionRule{App} & \transition{\effconfiguration{(\function{x}{c})v}{E}}{\effconfiguration{c[v/x]}{E}}\\
  \reductionRule{Seq} & \transition{\effconfiguration{\bind{x}{\return{v}}{c}}{E}}{\effconfiguration{c[v/x]}{E}}\\
  \reductionRule{Hdl} & \transition{\effconfiguration{\handleWith{\return{v}}{h}}{E}}{\effconfiguration{c[v/x]}{E}} \quad (\text{where $\returnHandler{x}{c} \in h$)}\\
  \vspace{1mm} \\ 
  \congruenceRule{Psh} & \transition{\effconfiguration{F[c]}{E}}{\effconfiguration{c}{E[F]}} \\
  \congruenceRule{Pop} & \transition{\effconfiguration{\return{v}}{E[F]}}{\effconfiguration{F[\return{v}]}{E}}\\
  \vspace{1mm} \\
  \effectRule{Op} & \transition{\effconfiguration{\op{v}}{E_1[\handleWith{E_2}{h}]}}\effconfiguration{c[v/x, \kappa x. \, \handleWith{E_2[\return{x}]}{h} / k]}{E_1}\\
  &&& \text{(where $\textbf{\texttt{op}} \in \textsf{dom}(h)$ and $\textbf{\textsf{op}} \notin \textsf{handled}(E_2)$)}\\
  \effectRule{Cnt} & \transition{\effconfiguration{\continue{(\kappa x. E_2[\return{x}])}{v}}{E_1}}{\effconfiguration{\return{v}}{E_1[E_2]}}

\end{array}
\]
  }
\end{eff-desc}
\caption{The operational semantics of \efflang{}. The semantics is given on configurations of the form $\langle c; E \rangle$. Rules are divided into three classes: reduction rules $\textsc{Red-}X$, which perform computation, congruence rules $\textsc{Cng-}Y$ which manipulate the evaluation context, and effect rules $\textsc{Eff-}Z$ that are special to \efflang{}.}
\label{fig:efflang-opsem}
\end{figure}

% For clarity, I will compress multiple stack frames using nesting. For example, instead of $\bind{x}{-\,}{c_2} :: \bind{y}{-\,}{c_1}$, I will write $\bind{x}{(\bind{y}{-\,}{c_1})}{c_2}$. 
The evaluation of \Cref{listing:efflang-running-example}, beginning with an empty context, illustrates the operation of  \textsc{Eff-Op} and \textsc{Eff-Cnt}. Let $h$ be the handler body 
\[\begin{array}{l}\{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
\; \, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}\end{array}\]
Several applications of \textsc{Cng-Psh} produces the configuration:
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \print{1} &;& \textbf{\texttt{handle}}\\
                        && \quad \bind{x}{[-];\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}} \\
                        && \textbf{\texttt{with}} \, \{ h \}\, \rangle
\end{array}
  \]
}

Let $E = \bind{x}{\return{u};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}}$. Applying \textsc{Eff-Op} suspends the program, finds the handler $h$ with the user's semantics for \textbf{\texttt{print}}, and gives the \textbf{\texttt{print}} effect the desired semantics:
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \bind{(v, s)}{\continue{(\continuation{u}{\, \handleWith{E}{h}})}{()}}{\return{(v, \texttt{f"\{1\};"} \text{ \^\ } s)}} &;& [-] \rangle
\end{array}
  \]
}
Applying \textsc{Cng-Psh}, we obtain the configuration:
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \continue{(\continuation{u}{\, \handleWith{E}{h}})}{()} &;& \bind{(v, s)}{[-]\,}{\return{(v, \texttt{f"\{1\};"} \text{ \^\ } s)}}\, \rangle
\end{array}
  \]
}
Applying \textsc{Eff-Cnt} resumes the program that was suspended:
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \return{()} &;& \textbf{\texttt{do}} {(v, s)} \leftarrow \\
  && \quad \textbf{\texttt{handle}} \\
  && \quad \quad \textbf{\texttt{do}} \, x \leftarrow ([-];\return{\texttt{1}}) \textbf{\texttt{in}}\\
  && \quad \quad \textbf{\texttt{do}} \, y \leftarrow (\print{2};\return{\texttt{2}})\\
  && \quad\quad \textbf{\texttt{in}} \, {\, x + y}\\
  && \quad \textbf{\texttt{with}} \, \{ h \}\\
  && \textbf{\texttt{in}} \, \return{(v, \texttt{f"\{1\};"} \text{ \^\ } s)}  \, \rangle
\end{array}
  \]
}

The side-condition on \textsc{Eff-Op} is needed because the user may define multiple handlers with different semantics for a single instance of the same effect. The side-condition resolves any ambiguity by using the \textit{latest} handler. For example, the following program has a \textbf{\texttt{read}} effect that is given two definitions: it could read either \texttt{1} or \texttt{2}. The ambiguity is resolved by choosing the latest handler: in this case, the program reads \texttt{1}.
\begin{eff}
$\begin{array}{l}
  \textbf{\texttt{handle}} \\
  \quad \handleWith{\textbf{\texttt{read}}()}{\returnHandler{y}{\return{y}}; \textbf{\texttt{read}}(x, k) \mapsto {\continue{k}{\texttt{1}}}} \\
  \textbf{\texttt{with}} \\ 
  \quad \{ \returnHandler{y}{\return{y}}; \textbf{\texttt{read}}(x, k) \mapsto {\continue{k}{\texttt{2}}} \}
\end{array}$ 

\vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{\texttt{1}}\end{array}$}
\end{eff}

To be precise, the domain of a handler $h$, $\textsf{dom}(h)$, is the set of operations for which it has handlers. For example, the domain of 
\[\{ \returnHandler{x}{\return{x}}; \textbf{\texttt{read}}(\_, k) \mapsto \continue{k}{\texttt{1}}; \textbf{\texttt{shirk}}(x, k) \mapsto \textbf{\texttt{shirk}}(x)
\} \] 
is $\{ \textbf{\texttt{read}}, \textbf{\texttt{shirk}} \}$.
Given an evaluation context, $E$, the set of effects handled by the context $\textsf{handled}(E)$, is the union of all of the domains of the handler frames in $E$. That is, 
\[\textsf{handled}(\handleWith{(\handleWith{[-]+1}{h_1})}{h_2}) = \textsf{dom}(h_1) \cup \textsf{dom}(h_2)\]
The latest handler $h$ for an effect \textbf{\texttt{op}} in a context $E$ is found by decomposing $E$ into 
\[E_1[\handleWith{E_2}{h}]\]
such that $\textbf{\texttt{op}} \in \textsf{dom}(h)$ ($h$ handles $\textbf{\texttt{op}}$) and $\textbf{\texttt{op}} \not\in \textsf{handled}(E_2)$ (no handlers for \textbf{\texttt{op}} in $E_2$). If such an $h$ exists, this condition identifies it uniquely. 
\subsubsection{Type-and-Effect System}
\Cref{fig:efflang-type-syntax} collates the syntax of \efflang{} types. Types are divided into value types (for example, $\mathbb{N}$), computation types ($\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}$), and handler types ($\handlerType{\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{\mathbb{N}}}$). Since computations may have effects, computation types track unhandled effects using an effects set ($\Delta$). This type-and-effect system allows us to distinguish between values, computations that return values, and computations that return values and additionally have some unhandled side effects:


\begin{figure}
  \begin{eff-desc}
  {\large \textbf{Types}}\\

  $\begin{array}{@{}lllr}
    \text{Effects set} & \Delta ::= \emptyset \mid \Delta \cup \{ \texttt{op}_i \} \\ \\
    \text{Value type} & S, T ::= \mathbb{N} & \\
                              &\quad\quad\quad\,\mid \functionType{S}{T} & \text{functions}\\
                              &\quad\quad\quad\,\mid \continuationType{S}{T} & \text{continuations}\\ \\
    \text{Computation type} & \effectType{T} \\
    \text{Handler type} & \handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}
  \end{array}$
  \end{eff-desc}
  \caption{\efflang{} types. Notice that, just as terms are divided into values, computations, and handlers, types are divided into value types ($S, T$), computation types ($\effectType{T}$), and handler types ($\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}$)}
  \label{fig:efflang-type-syntax}
\end{figure}

\[
\begin{array}{lll}
  \textbf{Term} &\hspace{8mm}& \textbf{Type} \\
  \texttt{3} && \mathbb{N} \\ 
  \bind{x}{\return{\texttt{1}}}{\bind{y}{\return{\texttt{2}}}{x + y}} &&  \effectType[\emptyset]{\mathbb{N}} \\ 
  \bind{x}{\print{1}; \return{\texttt{2}}}{\bind{y}{\return{\texttt{2}}}{x + y}} &&  \effectType[\{ \texttt{\textbf{print}}\}]{\mathbb{N}} \\ 
\end{array}
\]

Functions are values, and are applied to other values, but produce computations on application. For example, the function 
\[
\function{x:\mathbb{N}}{\; \textbf{\texttt{print}}(x); \return{x}}
\]
is a value that accepts a value of type $\mathbb{N}$ and returns a computation of type $\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}$. Functions thus have suspended effects, which I write $\functionType{S}{T}$. In this case, the function has type $\functionType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}{\mathbb{N}}$. Recall that continuations and functions, while similar, need to be distinguished for technical reasons relating to scope extrusion. 

Handlers transform computations of one type to computations of another type. This happens in two ways: first, by handling effects, removing them from the effects set. Second, by modifying the return type of computations. To reflect both abilities, handlers are given a type of the form $\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}$. For example, a handler of the form  
\[ \begin{array}{ll}
  \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
    \quad \, \,\, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}
  \end{array}
\]
may be given type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$, reflecting both the handling of the \textbf{\texttt{print}} effect and the transformation of the return type to include the collated print statements.

\efflang{} assumes that the user declares their effects in advance. It additionally assumes that they declare the types of their effects in advance, and that this mapping is stored in $\Sigma$. That is, 
\[\texttt{op}: A \to B \in \Sigma \]
In \texttt{OCaml}, this would correspond to writing:
\begin{ocaml}
type _ Effect.t += Op: A -> B
\end{ocaml}
\efflang{} does not impose any restrictions on $A$ and $B$. In particular, they may be recursive, and refer to \texttt{op}. For example:
\[\texttt{recursive}: 1 \to (\functionType[\{ \texttt{recursive} \}]{1}{1})\]
Thus, one may write programs which do not terminate, by ``tying the knot'', for example:
\begin{eff}
  $\handleWith{(\lambda \_ . \textbf{\texttt{recursive}} ()) ()}{\textbf{\texttt{recursive}}(\_, k) \mapsto {\continue{k}{(\lambda \_. \textbf{\texttt{recursive}} ())}}}$
\end{eff}

Note that for the program to be well-typed, the program fragment $\lambda \_. \textbf{\texttt{recursive}} ()$ must refer to \textbf{\texttt{recursive}} in its type: $\functionType[\{ \texttt{recursive} \}]{1}{1}$. Thus, the declared type of the \textbf{\texttt{recursive}} effect must be recursive. 

The typing rules for terms are collated in \Cref{fig:efflang-type-system}. Since types are stratified, so are typing judgements:
\[
\begin{array}{ll}
  \text{Value Typing Judgment} & \Gamma \vdash v: T  \\
  \text{Computation Typing Judgment} & \Gamma \vdash c: \effectType{T}  \\
  \text{Handler Typing Judgement} & \Gamma \vdash h: \handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}} 
\end{array}
\]
The key rules are \textsc{Return}, \textsc{Do}, \textsc{Op}, and the handler rules (\textsc{Ret-Handler}, \textsc{Op-Handler}).

\begin{figure}
  \begin{eff-desc}
    {\large\textbf{Typing Rules}}\\
    \vspace{2mm}\\
    \fbox{$\Gamma \vdash v : T$}\\
    \begin{center}
    \begin{minipage}[t]{0.2\textwidth}
      \centering
      $\inferrule[(Nat)]
      { \\ }
      {\type{m}{\mathbb{N}}}$
      \end{minipage}% 
  \begin{minipage}[t]{0.2\textwidth}
    \centering
  $\inferrule[(Var)]
  {\Gamma(x) = T}
  {\type{x}{T}}$
  \end{minipage}% 
  \begin{minipage}[t]{0.3\textwidth}
    \centering
  $\inferrule[(Lambda)]
    {\type[, x:S]{c}{\effectType{T}}}
    {\type{\function{x}{c}}{\functionType{S}{T}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.3\textwidth}
  \centering
$\inferrule[(Continuation)]
  {\type[, x:S]{c}{\effectType{T}}}
  {\type{\continuation{x}{c}}{\continuationType{S}{T}}}$
\end{minipage}  
  \vspace{5mm}

\end{center}
  
  \fbox{$\Gamma \vdash c : \effectType{T}$}\\
  \begin{center}
    
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(App)]
    {\type{v_1}{S \oset{\text{\tiny{$\Delta$}}}\longrightarrow T} \\ \type{v_2}{S}}
    {\type{v_1 \, v_2}{\effectType{T}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Continue)]
    {\type{v_1}{\continuationType{S}{T}} \\ \type{v_2}{S}}
    {\type{\continue{v_1}{v_2}}{\effectType{T}}}$
  \end{minipage}

  \vspace{5mm}

  \begin{minipage}[t]{0.3\textwidth}
    \centering
  $\inferrule[(Return)]
    {\type{v}{T}}
    {\type{\return{v}}{\effectType{T}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.55\textwidth}
    \centering
  $\inferrule[(Do)]
    {\type{c_1}{\effectType[\Delta]{S}} \\ \type[, x: S]{c_2}{\effectType{T}}}
    {\type{\bind{x}{c_1}{c_2}}{\effectType{T}}}$
  \end{minipage}
  
  \vspace{5mm}
  % \begin{minipage}[t]{0.5\textwidth}
  %   \centering
  % $\inferrule[(Do)]
  %   {\type{c_1}{\effectType[\Delta_1]{S}} \\ \type[, x: S]{c_2}{\effectType{T}}}
  %   {\type{\bind{x}{c_1}{c_2}}{\effectType{T}}}$
  % \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Op)]
    {  \\\\ \type{v}{S} \\ \texttt{op}: S \rightarrow T \in \Sigma \\ \texttt{op} \in \Delta}
    {\type{\op{v}}{\effectType{T}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Handle)]
    {\type{c}{\effectType[\Delta_1]{S}} \\ \type{h}{\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}} \\ \forall \textsf{op} \in \Delta_1 \setminus \Delta_2. \, \textsf{op} \in \textsf{dom}(h)}
    {\type{\handleWith{c}{h}}{\effectType[\Delta_2]{T}}}$
  \end{minipage}\\

  \vspace{5mm}

\end{center}

\fbox{$\Gamma \vdash h: \handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}$}\\
\begin{center}

  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(Ret-Handler)]
    {\type[, x:S]{c}{\effectType[\Delta_2]{T}}}
    {\type{\returnHandler{x}{c}}{\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}}}$
  \end{minipage}
  
  \vspace{5mm}
  % \[\inferrule [(Lam)]
  % {\type[, x:S]{t}{\sEffect{T}}}
  % {\type{\function{x}{t}}{\sFunctionType{S}{T}}}\]
  
  % \[\inferrule[(App)]
  % {\type{n_1}{\sFunctionType{S}{T}} \\
  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(Op-Handler)]
    { \texttt{op}: A \to B \in \Sigma \\\\ 
      \type{h}{\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}}\\
      \type[, x:A, k:{\continuationType[\Delta_2]{B}{T}} ]{c}{\effectType[\Delta_2]{T}}\\
      \Delta_1 \subseteq \Delta_2 \cup \{ \texttt{op} \} \\
             \opHandler{x'}{k'}{c'} \notin h}
    {\type{h ; \opHandler{x}{k}{c}}{\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}}}$
  \end{minipage}
\end{center}
  \end{eff-desc}
  \caption{Typing rules for \efflang{} terms. Typing judgements are stratified into value, computation, and handler judgments.}
  \label{fig:efflang-type-system}
  \end{figure}

The \textsc{Return} rule permits $\return{v}$ to be typed with any set of effects. For example:
\[\inferrule{ }{\type[]{\return{\texttt{0}}}{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}}\] 
This flexibility is important, because to type $\bind{x}{c_1}{c_2}$, the \textsc{Do} rule requires $c_1$ and $c_2$ to have the same effects. For example, without this flexibility, it would not be possible to complete the following typing derivation:
\[\inferrule{\vdots}{\type[]{\bind{x}{\print{0}}{\return{\texttt{0}}}}{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}}\] 
A valid alternative would be to add explicit subtyping. However, such an approach would no longer be syntax directed. 

The \textsc{Op} rule forces the performed operation to be tracked by the effects set ($\texttt{op} \in \Delta$): flexibility allows the type system to over-approximate the effects in a computation, but not to underapproximate them. 

Following the approach by \citet{biernacki-2017}, handlers are typed clause-by-clause, using the \textsc{Ret-Handler} and \textsc{Op-Handler} rules. In contrast, \citeauthor{pretnar-15} types a handler with a single rule that checks all clauses at once. Consider typing the handler:
\[ \begin{array}{ll}
  \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
    \quad \, \,\, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}
  \end{array}
\]
with type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$. This involves applying the \textsc{Op-Handler} rule, which is transcribed below. Preconditions are numbered for reference. 
\[\inferrule[(Op-Handler)]
    { (1)\,  \texttt{op}: A \to B \in \Sigma \\\\
     (2)\, \type{h}{\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}}\\
      (3)\,\type[, x:A, k:{\continuationType[\Delta_2]{B}{T}} ]{c}{\effectType[\Delta_2]{T}}\\
      (4)\,\Delta_1 \subseteq \Delta_2 \cup \{ \texttt{op} \} \\
      (5)\, \opHandler{x'}{k'}{c'} \notin h}
    {\type{h ; \opHandler{x}{k}{c}}{\handlerType{\effectType[\Delta_1]{S}}{\effectType[\Delta_2]{T}}}}\]
It is sufficient to show that:
\begin{enumerate}
  \item[(1)] $\textbf{\texttt{print}}: \mathbb{N} \to 1 \in \Sigma$, which is true by assumption
  \item[(2)] The rest of the handler $h = \returnHandler{x}{\return{(x, \texttt{""})}}$ has type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$. This follows from a trivial application of the \textsc{Ret-Handler} rule. 
  \item[(3)] The body \[{\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\] has type $\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}$, assuming $x$ has type $\mathbb{N}$ and $k$ has type $\continuationType[\emptyset]{1}{(\mathbb{N} \times \textsf{String})}$. 
  \item[(4)] The handler removes \textit{at most} \textbf{\texttt{print}} from the effects set, and no other effects. This check passes, but would fail if we tried to type the handler with, for example, $\handlerType{\effectType[\{ \textbf{\texttt{print}}, \textbf{\texttt{get}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$.
  \item[(5)] There are no other handlers for \textbf{\texttt{print}} in $h$.
\end{enumerate}

A closed computation is well-typed if it can be typed with an empty effects set.  
\begin{definition}[Well-Typed Closed Computation]{effHighlight}
  $c$ is a closed, well-typed computation if $\cdot \vdash {c}: {T \, ! \, \emptyset}$
\end{definition}

\subsubsection{Metatheory}
Discussion around the interaction between effect handlers and metaprogramming builds on some metatheoretic properties of \efflang{}, which are proven by \citet{bauer-2014}.

\renewcommand{\effconfiguration}[2]{\langle {#1}; {#2} \rangle}
\renewcommand{\transition}[2]{#1 \rightarrow #2}

\begin{theorem}[Progress]{effHighlight}\label{thm:progress}
If $\cdot \vdash {E[c]}: {\effectType{T}}$ then either 
\begin{enumerate}
\item $c$ is of the form $\return{v}$ and $E = [-]$,
\item $c$ is of the form $\op{v}$ for some $\textsf{op} \in \Delta$, and $\texttt{op} \notin \textsf{handled}({E})$
\item $\exists \, c', E'$ such that $\transition{\effconfiguration{c}{E}}{\effconfiguration{c'}{E'}}$
\end{enumerate}
\end{theorem}
\vspace{-\baselineskip}
\begin{theorem}[Preservation]{effHighlight}\label{thm:preservation}
If $\cdot \vdash {E[c]}: {\effectType{T}}$ and $\transition{\effconfiguration{c}{E}}{\effconfiguration{c'}{E'}}$, then $\cdot \vdash {E'[c']}: {\effectType{T}}$
\end{theorem}
\vspace{-\baselineskip}
\begin{corollary}[Type Safety]{effHighlight}\label{thm:type-safety}
  If $\cdot \vdash {c}: {\effectType[\emptyset]{T}}$ then either 
\begin{enumerate}
\item $\langle c; [-] \rangle \to^{\omega}$ (non-termination)
\item $\langle c; [-] \rangle \to^{*} \langle \return{v}; [-] \rangle$
\end{enumerate}
\end{corollary}

\newcommand{\contextequiv}{\cong_{\text{\emph{ctx}}}}

% Finally, \efflang{} is a \textit{fine-grain call-by-value} \citep{levy-2003} approach. We first define a notion of contextual equivalence $\contextequiv$. Informally, two computations/values are contextually equivalent if they behave the same in all ``relevant'' contexts and at all ground (first-order) types (in this case, just $\mathbb{N}$). 

% % To define a notion of ``relevant'', we first type contexts

% % \begin{figure}
% % \begin{eff-desc}
% % $\inferrule{\\}{\Gamma \vdash_{\Gamma, \effectType{T}} [-]: \effectType{T}}$
% % \end{eff-desc}
% % \end{figure}

% \begin{definition}[Contextual Equivalence]{effHighlight}\label{dfn:ctx-equiv}
%   $c$ and $c'$ are contextually equivalent at context $\Gamma$ and type $\effectType{T}$, written $\Gamma \vdash c \contextequiv c': '\effectType{T}$ if 
%   \begin{enumerate}
%     \item $\type{c}{\effectType{T}}$ and $\type{c'}{\effectType{T}}$
%     \item For all $E$ such that $\cdot \vdash {E[c]}: {\effectType[\emptyset]{\mathbb{N}}}$  and $\cdot \vdash {E[c']}: {\effectType[\emptyset]{\mathbb{N}}}$, 
%     \[ \effconfiguration{c}{E}  \, \to^{*} \, { \effconfiguration{\return{v}}{[-]}}  \iff  \effconfiguration{c'}{E} \, \to^{*} \,  \effconfiguration{\return{v}}{[-]} \]
%   \end{enumerate}

%   When the context $\Gamma$ is empty, we write $c \contextequiv c': \effectType{T}$, and when the type is unimportant, we write $c \contextequiv c'$
% \end{definition}
% \vspace{-\baselineskip}
% \begin{definition}[Fine-Grain CBV]{effHighlight}\label{dfn:fine-grain-cbv}
%   \efflang{} is a fine-grain call-by-value language, meaning in particular that the following equations hold (notationally, I use $c$ for computations, $v$ for values, and $f$ for function values):
%   \begin{enumerate}
%     \item $\bind{x}{\return{v}}{c} \, \contextequiv \, c[v/x]$
%     \item $c \, \contextequiv \, \bind{x}{c \,}{\return{x}}$
%     \item $\bind{x}{c_1}{(\bind{y}{c_2}{c_3})} \, \contextequiv \bind{y}{(\bind{x}{c_1}{c_2})}{c_3}$
%     \item $(\lambda x. c) v \, \contextequiv \, c[v/x]$
%     \item $f \, \contextequiv \, \lambda x. f x$
%   \end{enumerate}
% In the third equation, we assume $x$ not free in $c_3$.
% \end{definition}

\subsection{The Design Space of Effect Handlers}\label{subsection:effect-handler-design}
The design space of effect handlers is large. Different design decisions could impact how effect handlers interact with metaprogramming. This thesis focuses on unnamed and deep effect handlers that permit multi-shot continuations:

\renewcommand{\effconfiguration}[2]{{#1}; {#2}}
\renewcommand{\transition}[2]{#1 & \rightarrow & #2}
\newcommand{\rulename}[2]{(\textsc{{#1}-{#2}})}
\newcommand{\reductionRule}[1]{\rulename{Red}{#1}}
\newcommand{\congruenceRule}[1]{\rulename{Cng}{#1}}
\newcommand{\effectRule}[1]{\rulename{Eff}{#1}}

\begin{enumerate} 

 \item \textbf{\textsf{Named or Unnamed Handlers}}\\
        \textit{Can an effect invoke a specific handler, rather than the latest?}
        
        In \efflang{}, when there are multiple handlers for the same effect, the latest handler for that effect is invoked. An alternative approach is \textbf{named handlers} \citep{xie-2022}, where, by associating each handler with a \textit{name}, the programmer can more easily specify which handler should be invoked. 

        While named handlers can be more ergonomic \citep{xie-2022}, like other works on scope extrusion \citep{isoda-24}, this thesis only considers unnamed handlers.

  \item \textbf{\textsf{Deep, Shallow, or Sheep Handlers}}\\
         \textit{Can multiple instances of the same effect be handled by the same handler?}

         In \efflang{}, continuations reinstate handlers $\effectRule{Op}$ and thus multiple instances of the same effect can be handled by the same handler. For example, in the following example, both instances of \textbf{\texttt{addn}} are handled by the same handler, adding one each time. These are known as \textbf{deep} handlers.
          
         \begin{minipage}[t]{\linewidth}
          \centering
         \begin{efflst}
          $\begin{array}{l}
            \textbf{\texttt{handle}} \\
            \quad \textbf{\texttt{addn}}(\texttt{1}) + \textbf{\texttt{addn}}(\texttt{2}) \\
            \textbf{\texttt{with}} \\
            \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{x}}; \, \textbf{\texttt{addn}}(y, k) \mapsto \continue{k}{(y+\texttt{1})} \}\\
          \end{array}$
          \vspace{2mm} 
          \textcolor{effComment}{\hrule height 0.2mm \relax}
          \vspace{2mm} 
          
          \textcolor{effComment}{$\begin{array}{l}\return{\texttt{5}}\end{array}$}
        \end{efflst}
        \centering
        \captionof{listing}{A \efflang{} program which contrasts deep, shallow, and sheep handlers}%
        \label{listing:eff-handler-type}
      \end{minipage}
      \par\vspace{0.6\baselineskip}
        An alternative semantics would \textit{not} reinstate the handler, in an approach known as \textbf{shallow} handlers \citep{hillestrom-2018}. \Cref{listing:eff-handler-type} would be stuck, since the second \textbf{\texttt{addn}} would not be handled.

        Another alternative would be to modify the interface for \textbf{\texttt{continue}} such that it accepts a handler:
        \[\textbf{\texttt{continue}} \, k \,  v \, h\]
        This would allow multiple effects to be handled by different handlers. That is, the programmer could add $\texttt{1}$ the first time \textbf{\texttt{addn}} is performed, and $\texttt{2}$ the second time (\Cref{listing:eff-handler-type} would return $\texttt{2}+\texttt{4}=\texttt{6}$). These handlers behave as a hybrid of shallow and deep handlers, and are thus termed \textbf{sheep} handlers \citep{phipps-costin-2023}. 
         
        In keeping with most prior work on scope extrusion, this thesis focuses on deep handlers \citep{isoda-24}. 

        \item \textbf{\textsf{One-Shot or Multi-Shot Continuations}}\\
        \textit{How many times can the same continuation be resumed?}
 
        In \efflang{}, continuations may be resumed multiple times (\Cref{listing:eff-multishot}):

        \begin{minipage}[t]{\linewidth}
          
        \begin{efflst}
          $\begin{array}{l}
            \textbf{\texttt{handle}} \\
            \quad \textbf{\texttt{performTwice}}(\texttt{1}) \\
            \textbf{\texttt{with}} \\
            \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{x}};  \, \textbf{\texttt{performTwice}}(y, k) \mapsto (\continue{k}{y}) + (\continue{k}{y}) \}\\
          \end{array}$
          \vspace{2mm} 
          \textcolor{effComment}{\hrule height 0.2mm \relax}
          \vspace{2mm} 
          
          \textcolor{effComment}{$\begin{array}{l}\return{\texttt{2}}\end{array}$}
        \end{efflst}
        \captionof{listing}{A \efflang{} program that resumes the same continuation multiple times}%
        \label{listing:eff-multishot}
      \end{minipage}
      \par\vspace{0.6\baselineskip}
        Such an effect system is said to permit \textbf{multi-shot continuations}. Multi-shot continuations are useful for simulating certain effects, like non-determinism \citep{phipps-costin-2023}. 

        In \texttt{OCaml}, multi-shot continuations are not allowed: continuations are only allowed to be resumed once. These systems permit only \textbf{one-shot continuations}. 

        Although continuations in \texttt{OCaml} are one-shot, this thesis studies effect systems with multi-shot continuations.
\end{enumerate}
