\section{Effect Handlers}\label{section:effects-technical}
What is an effect handler? I first motivate effect handlers by considering the problem of adding resumable exceptions to \texttt{OCaml} (\Cref{subsection:effect-handler-motivation}). Second, I introduce a calculus for studying the operational behaviour of effect handlers, à la \citet{pretnar-15} (\Cref{subsection:effect-handler-calculus}). This calculus is useful both for precise description of effect handlers, and as a basis for investigating the interaction between metaprogramming and effect handlers. Finally, since different design decisions for effect handlers could affect the nature of their interaction with metaprogramming, I consider the design space of effect handlers (\Cref{subsection:effect-handler-design}).

\subsection{Composable and Customisable Effects}\label{subsection:effect-handler-motivation}
Effects are a mechanism by which a program interacts with its environment. Examples of effects include state, (resumable) exceptions, non-determinism, and I/O. Effects are typically defined and understood separately, meaning they are not easily composable. They are also implemented by compiler engineers rather than programmers, meaning they are not customisable. Effect handlers provide a programmable, unifying framework that may be instantiated into different effects. This allows for composable and customisable treatment of effects.

To illustrate the need for effect handlers, consider the following problem, by \citet{kiselyov-2012}. Assume a binary search tree of (key, value) pairs. The following code provides two functions. The first \mintinline{ocaml}{find}s a value \mintinline{ocaml}{v} associated with key \mintinline{ocaml}{k}, raising a \mintinline{ocaml}{NotFound} exception if \mintinline{ocaml}{k} is not in the tree. The second \mintinline{ocaml}{update}s the dictionary with a fresh key value pair, overwriting old values.

\begin{ocaml}
type ('a, 'b) tree = Lf | Br of 'a * 'b * tree * tree 

let rec find (t: tree) (k: 'a) = match t with 
 | Lf -> raise NotFound()
 | Br(k', v, l, r) -> if k == k' then v 
                      else if k < k' then find l k
                           else find r k

let rec update (t: tree) (k: 'a) (v: 'b) = match t with 
  | Lf -> Br(k, v, Lf, Lf)
  | Br(k', v', l, r) -> if k == k' then Br(k, v, l, r)
                        else if k < k' then Br(k', v', update l k v, r)
                        else Br(k', v', l, update r k v)
\end{ocaml}

Assume the task is to build a \mintinline{ocaml}{findOrInsert} function that either finds the value associated with a key, \textit{or} inserts a default value. A naïve approach to writing this function would be
\begin{ocaml}  
let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
  try find t k with NotFound -> insert t k default
\end{ocaml}
This function is \textbf{inefficient}. If the \mintinline{ocaml}{find} function raises a \mintinline{ocaml}{NotFound} exception, it will do so at the point where the default value should be inserted. If computation could be resumed at the point where the exception was raised, as such:
\begin{ocaml}
let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
  try find t k with NotFound(p) -> continue p Br(k, default, Lf, Lf)
\end{ocaml}
then the function could be twice as fast. \mintinline{ocaml}{p} represents the suspended program to be resumed, and is known as a \textit{delimited continuation}.

The aforementioned problem motivates the need for resumable exceptions. To understand the need for effect handlers, consider how one might go about \textbf{implementing} resumable exceptions. One approach might be to fork the implementation of handlers and tweak it ever-so-slightly. This solution does not scale well. First, the solution may not be \textbf{composable}. The intended informal semantics for resumable exceptions is ``effectively equivalent to exceptions, with the additional power to resume programs''. Resumable exceptions should thus interact with other exceptions in a predictable way, but this is difficult to guarantee, and \textit{continually} guarantee. Second, the solution is not \textbf{customisable}. Adding resumable exceptions requires a compiler engineer to modify the compiler. With the exception of raising an issue, there is nothing the programmer may do, in the moment, to meet their need.

Effect handlers resolve both composability and customisability issues. Much like how exception handlers allow users to create custom exceptions with custom semantics, effect handlers provide a general framework for creating custom effects with custom semantics. The interaction between effect handlers is described abstractly, parameterising over the exact semantics of the effect. Hence, implementing effects (in the earlier example, resumable exceptions, but more generally, state, I/O, greenthreading, non-determinism, and more) as effect handlers ensures composability by design. 

With effect handlers, we can re-write the previous example to obtain the behaviour of resumable exceptions, even if the \texttt{OCaml} compiler does not support it, with the guarantee that \mintinline{ocaml}{NotFound} will interact predictably with other defined effects.
\begin{ocaml}
type _ Effect.t += NotFound: unit -> tree t

let rec find (t: tree) (k: 'a) = match t with 
  | Lf -> NotFound()
  | Br(k', v, l, r) -> if k == k' then v 
                      else if k < k' then find l k
                            else find r k

let rec findOrInsert (t: tree) (k: 'a) (default: 'b) = 
  match find t k with NotFound(p) with 
  | v -> v
  | effect NotFound k -> continue p Br(k, default, Lf, Lf)
\end{ocaml}

Since effect handlers may be instantiated into a range of different effects, considering the interaction of metaprogramming with effect handlers is an exercise in killing many birds with a single stone. Additionally, effect handlers were recently added to \texttt{OCaml} \citep{sivaramakrishnan-21}, making their interaction a timely problem. 
\subsection{\texorpdfstring{\efflang{}}{Lambda-Op}: A Calculus for Effect Handlers}\label{subsection:effect-handler-calculus}
\newcommand{\print}[1]{\texttt{\textbf{print}(#1)}}
\newcommand{\readInt}[1]{\texttt{\textbf{read\_int}(#1)}}


Having motivated effect handlers, I now describe a calculus, which I call \efflang{}, for reasoning about their operational behaviour.\ \efflang{} is a slight variant of the calculus described by \citet{pretnar-15}. Understanding \efflang{} is useful for two reasons. First, it aids reasoning about the interaction between effects and metaprogramming. Second, in \Cref{chapter:calculus}, I present my calculus by extending \efflang{}. 

\begin{code}
  \begin{efflst}
    $\begin{array}{l}
      \textbf{\texttt{handle}} \\
      \quad \bind{x}{\print{1};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{2}}{\, x + y}}} \\
      \textbf{\texttt{with}} \\
      \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
      \quad \; \, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}\\
    \end{array}$

    \vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{(\texttt{3}, \texttt{"1;2"})}\end{array}$}

  \end{efflst}
  \captionof{listing}{A \efflang{} program that returns $(\texttt{3}, \texttt{"1;2"})$. It is used as a running example throughout this section.}
  \label{listing:efflang-running-example}
  \end{code}

\Cref{fig:eff-lang-syntax} collates the base syntax of \efflang. In addition to this base syntax, in this section, I assume \efflang{} is extended with the following language extensions: 
\begin{enumerate}
  \item A unit value $()$,
  \item Pairs $(\texttt{1}, \texttt{2})$ which can be destructured $\bind{(x, y)}{\return{(\texttt{1}, \texttt{2})}}{\, x+y}$,
  \item Strings \texttt{"Hello"},
  \item Format strings \texttt{f"\{1\}"}, and
  \item String concatenation \texttt{\^}
\end{enumerate}
For example, the following code evaluates to \texttt{"Revolution 9"}.

% \texttt{\^} \texttt{f"\{$y$\}"}}}
\begin{eff}
$\begin{array}{l}\bind{(x, y)}{\return{(\texttt{"Revolution"}, \texttt{f"\{9\}"})}}{\, x \text{ \^\ } y}\end{array}$
\vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{\texttt{"Revolution 9"}}\end{array}$}
\end{eff}
Further, I use $c_1;c_2$ as syntactic sugar for $\bind{\_}{c_1}{c_2}$. 
I explain key language constructs in turn, with reference to a running example: the \efflang{} program in \Cref{listing:efflang-running-example}. 
\begin{figure}
  \begin{eff-desc}
    {\large{\textbf{Syntax}}}

  $\begin{array}{@{}llll}
  \text{Values} & v & := & x \mid n \mid \lambda x. c \mid \kappa x.c\\

  \text{Computations} & c & := & v_1 v_2 \mid \return{v} \mid \bind{x}{c_1}{c_2} \\
                             &&& \mid \op{v} \mid \handleWith{c}{h} \mid \continue{v_1}{v_2} \\ 
  \text{Handlers} & h & := &\returnHandler{x}{c} \mid h;\opHandler{x}{k}{c}
  \end{array}$
  
  \end{eff-desc}
  \caption{The syntax of \efflang. Terms are syntactically divided into values $v$, computations $c$, and handlers $h$ }
  \label{fig:eff-lang-syntax}
\end{figure}

\subsubsection{Sequencing computations: \texttt{do} and \texttt{return}}
Effects force us to carefully consider the order of evaluation. For example, consider the following \texttt{OCaml} programs:
\begin{ocaml}
let pure      = (1+0) + (2+0)
let effectful = let l = new 0 in (l := 1; 1) + (l := 2; 2)
\end{ocaml}
The result of \mintinline{ocaml}{pure}, which has no effects, is independent of the evaluation order. In contrast, the result of \mintinline{ocaml}{effectful} \textit{is} dependent on the evaluation order. If terms are evaluated left-to-right, the value of \mintinline{ocaml}{!l} is \mintinline{ocaml}{2}, otherwise, it is \mintinline{ocaml}{1}.

In order to be precise about the order of evaluation, \efflang{} terms are stratified into two syntactic categories, ``inert values'' ($v$) and ``potentially effectful computations'' ($c$) \citep{pretnar-15}. $\return{v}$ lifts values into computations, and is also the result of fully evaluating a computation. $\bind{x}{c_1}{c_2}$ sequences computations, forcing programmers to be explicit the order of evaluation.  First, $c_1$ is fully evaluated to obtain some $\return{v}$. The value $v$ is then bound to $x$, and finally $c_2$ is evaluated. 

For example, extending \efflang{} with a \texttt{plus} function, what is the order of evaluation of \texttt{plus} \texttt{1} \texttt{2}? Are both arguments evaluated before application, or are evaluation and application interleaved? The syntax forces programmers to choose explicitly. The programmer can either fully evaluate both arguments before applying them in turn, 
\begin{eff}
$\bind{x}{\return{\texttt{1}}}{(\bind{y}{\return{\texttt{2}}}{(\bind{f}{\texttt{plus} \, x}{f y})})}$
\end{eff}
or alternatively, evaluate \texttt{1}, apply it, then evaluate \texttt{2}
\begin{eff}
$\bind{x}{\return{\texttt{1}}}{(\bind{f}{\texttt{plus} \, x}{\bind{y}{\return{\texttt{2}}}{f y}})}$
\end{eff}

Both choices are valid, but the programmer must choose. For clarity, where the order cannot affect the result (both choices evaluate to $\return{3}$), I abuse notation and write (for instance) $1+2$. 

\subsubsection{Performing effects: \texttt{op}, \texttt{handle}, and \texttt{continue}}
Having made explicit the order of operation, I now consider effect handlers. Recall that effect handlers allow users to register custom effects with custom semantics.

For simplicity, \efflang{} assumes that the effects have been registered in advanced, parameterising over them with the placeholder $\op{v}$. Assume that the user has declared the effects \texttt{\textbf{print}} and \texttt{\textbf{readInt}} in advance. This would allow the user to write programs like 
\begin{eff}
$\bind{x}{\print{1};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}}$
\end{eff}

In the program fragment above, \textbf{\texttt{print}} is an effect, but with as-yet-unknown semantics. Effect handlers, which comprise a \textbf{return handler} and zero or more \textbf{operation handlers}, specify how effects interact with their environment, and thus may be used to give effects meaning. I define an effect handler that accumulates print statements in a string (some ``\texttt{stdout}'').  For example, the aforementioned program should return $(\texttt{3}, \texttt{"1; 2"})$.

I begin by considering how to handle the case where there are no calls to \textbf{\texttt{print}}. For example, in the program $\return{\texttt{3}}$. I wish to return both the value and an empty string: in this case, $(\texttt{3}, \texttt{""})$. I achieve this by specifying a \textit{return handler}, of the form:
\[\textbf{\texttt{return}}(x) \mapsto {c}\]
In this case, I set $c$ to $\return{(x, \texttt{""})}$. All effect handlers must specify a return handler. In many cases, the return handler is simply the identity. 

Next, I consider how to handle a call to \textbf{\texttt{print}}. I use an operation handler of the form 
\[\textbf{\texttt{print}}(x, k) \mapsto {c}\]
Where $c$ is the user-defined semantics for \textbf{\texttt{print}}.
Concretely, one instance of $c$ is 
\[\textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\]
In the definition of $c$, the programmer may refer to $x$ and $k$, which I now explain. $x$ allows programs to send values (for example, values to be printed) to the handler. $k$ is a delimited continuation representing a suspended program, awaiting a value from its environment. Effects also allow programs to receive data from their environments, as in
\[1 + \textbf{\texttt{get\_int\_from\_user}}()\]
Note that the program is suspended until the value is received. I write the suspended program as $1 + [-]$, where $[-]$ indicates an as-yet-unknown value. This suspended program is represented by the continuation $k$. The expression 
\[\continue{k}{v}\] 
is used to resume the suspended program with value $v$. 

I now able to interpret the concrete operation handler $c$: the handler resumes the suspended program, supplying a unit value, since \textbf{\texttt{print}} effects do not receive values. Evaluating the (now unsuspended) program eventually returns a value $v$ and some partially accumulated \texttt{stdout} $s$. The handler then prepends the printed value, $x$, onto $s$. 
% Second, \textit{any effect can be understood in terms of send and receive operations}. Programs interact with their environment in two fundamental ways: they either \textit{receive} values from their environment (as above), or they \textit{send} values to its environment, for example via a \texttt{print}. 

% $x$, $k$, 

% where $x$ is a value sent by the program to its environment, $k$ is the program that was suspended on encountering the effect (a delimited continuation), and $c$ is a user-defined computation that specifies the semantics of \textbf{\texttt{print}}. 
% In this example, we assume that programs evaluate to tuples $(\texttt{value}, \texttt{std\_out})$. Programs may receive values from their environment: we use the syntax $\continue{k}{()}$ to give the program the unital value. Programs may also send values $x$, which are processed by the environment -- in this case, prepended to the \texttt{std\_out}. If \textbf{\texttt{print}} is given these semantics, the earlier program should return $(\texttt{3}, \texttt{"1; 2"})$.

% There is a slight complication. Our assumption is wrong: the program evalues $\return{\texttt{3}}$ -- we need to \textit{initialise} \texttt{std\_out}. This is done using a little boiler plate. Every effect handler must additionally define a \textbf{\texttt{return}} handler, which treats \textbf{\texttt{return}} as a special effect, whose semantics we may modify 
% 
Having defined the semantics for \textbf{\texttt{print}}, the user may now interpret the earlier example with their semantics, using the $\handleWith{e}{h}$ construct. Doing so results in the program in \Cref{listing:efflang-running-example}.

Notice that multiple effects may be handled by the same handler, and the same effect might be handled by multiple handlers, potentially with different semantics. 

\subsubsection{Operational Semantics}
Having described \efflang{} informally, I now describe its semantics more precisely, via an operational semantics \Cref{fig:efflang-opsem}. 

\begin{figure}[ht]
  \arraycolsep=3pt
\begin{eff-desc}
  
  {\large\textbf{Operational Semantics}}\\

  \renewcommand{\effconfiguration}[2]{{#1}; {#2}}
  \renewcommand{\transition}[2]{#1 & \rightarrow & #2}
  \newcommand{\rulename}[2]{(\textsc{{#1}-{#2}})}
  \newcommand{\reductionRule}[1]{\rulename{Red}{#1}}
  \newcommand{\congruenceRule}[1]{\rulename{Cng}{#1}}
  \newcommand{\effectRule}[1]{\rulename{Eff}{#1}}
  \footnotesize
  \textbf{Auxiliary Definitions}
  {\scriptsize
    \[\begin{array}{lrcl}
    \text{Evaluation Frame } & F & ::= & \bind{x}{[-]\,}{c_2} \mid \handleWith{[-]}{h} \\
    \text{Evaluation Context } & E & ::= & [-] \mid E[F] \\ \vspace{1mm} \\
    \text{Domain of Handler} & \textsf{dom}(h) & \triangleq & \textsf{dom}(\returnHandler{x}{c}) = \emptyset, \\
    &&&\textsf{dom}(h;\opHandler{x}{k}{c}) = \textsf{dom}(h) \cup \{ \textbf{\textsf{op}} \} \\  
    \vspace{1mm} \text{Handled Effects} & \textsf{handled}(E) & \triangleq & \textsf{handled}([-]) = \emptyset, \\ 
    &&& \textsf{handled}(E[\bind{x}{[-]\,}{c_2}]) = \textsf{handled}(E), \\
    &&& \textsf{handled}(E[\handleWith{[-]}{h}]) = \textsf{handled}(E) \cup \textsf{dom}(h),
  \end{array}
  \]}

{\noindent\textbf{Operational Semantics}}
  {\scriptsize
\[
  \begin{array}{rrcl}
  \reductionRule{App} & \transition{\effconfiguration{(\function{x}{c})v}{E}}{\effconfiguration{c[v/x]}{E}}\\
  \reductionRule{Seq} & \transition{\effconfiguration{\bind{x}{\return{v}}{c}}{E}}{\effconfiguration{c[v/x]}{E}}\\
  \reductionRule{Hdl} & \transition{\effconfiguration{\handleWith{\return{v}}{h}}{E}}{\effconfiguration{c[v/x]}{E}} \quad (\text{where $\returnHandler{x}{c} \in h$)}\\
  \vspace{1mm} \\ 
  \congruenceRule{Psh} & \transition{\effconfiguration{F[c]}{E}}{\effconfiguration{c}{E[F]}} \\
  \congruenceRule{Pop} & \transition{\effconfiguration{\return{v}}{E[F]}}{\effconfiguration{F[\return{v}]}{E}}\\
  \vspace{1mm} \\
  \effectRule{Op} & \transition{\effconfiguration{\op{v}}{E_1[\handleWith{E_2}{h}]}}\effconfiguration{c[v/x, \kappa x. \, \handleWith{E_2[\return{x}]}{h} / k]}{E_1}\\
  &&& \text{(where $\opHandler{x}{k}{c} \in h$ and $\textbf{\textsf{op}} \notin \textsf{handled}(E_2)$)}\\
  \effectRule{Cnt} & \transition{\effconfiguration{\continue{E_2}{v}}{E_1}}{\effconfiguration{\return{v}}{E_1[E_2]}}

\end{array}
\]
  }
\end{eff-desc}
\caption{The operational semantics of \efflang. The semantics is given on configurations of the form $\langle c, E \rangle$, with the brackets dropped for clarity. Rules are divided into three classes: reduction rules $\textsc{Red-}X$, which perform computation, congruence rules $\textsc{Cng-}Y$ which manipulate the evaluation context, and effect rules $\textsc{Eff-}Z$ that are special to \efflang}
\label{fig:efflang-opsem}
\end{figure}

The operational semantics is given on configurations of the form $\effconfiguration{c}{E}$, where $c$ is a term and $E$ is an evaluation context, in the style of \citet{felleisen-87}. Evaluation contexts are represented as a stack of evaluation frames $F$, à la \citet{kiselyov-2012}. Most of the rules are standard. I focus on two rules: \textsc{Eff-Op}, the mechanism for giving effects custom semantics, and \textsc{Eff-Cnt}, the mechanism for resuming programs. 
% For clarity, I will compress multiple stack frames using nesting. For example, instead of $\bind{x}{-\,}{c_2} :: \bind{y}{-\,}{c_1}$, I will write $\bind{x}{(\bind{y}{-\,}{c_1})}{c_2}$. 

To illustrate the operation of \textsc{Eff-Op} and \textsc{Eff-Cnt}, consider the evaluation of \Cref{listing:efflang-running-example}, beginning with an empty context. Let $h$ be the handler body 
\[\begin{array}{l}\{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
\; \, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}\end{array}\]
After several applications of \textsc{Cng-Psh}, we obtain the configuration
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \print{1} &;& \textbf{\texttt{handle}}\\
                        && \quad \bind{x}{[-];\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}} \\
                        && \textbf{\texttt{with}} \, \{ h \}\, \rangle
\end{array}
  \]
}

Let $E = \bind{x}{\return{u};\return{\texttt{1}}}{{\bind{y}{\print{2};\return{\texttt{2}}}{\, x + y}}}$. Applying \textsc{Eff-Op}, we can suspend the program, find the handler $h$ with the user's semantics for \textbf{\texttt{print}}, and give the \textbf{\texttt{print}} effect the desired semantics
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \bind{(v, s)}{\continue{(\continuation{u}{\, \handleWith{E}{h}})}{()}}{\return{(v, \texttt{f"\{$1$\};"} \text{ \^\ } s)}} &;& [-] \rangle
\end{array}
  \]
}
Applying \textsc{Cng-Psh},
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \continue{(\continuation{u}{\, \handleWith{E}{h}})}{()} &;& \bind{(v, s)}{[-]\,}{\return{(v, \texttt{f"\{$1$\};"} \text{ \^\ } s)}}\, \rangle
\end{array}
  \]
}
Applying \textsc{Eff-Cnt}, we can resume the program that was suspended
{  \arraycolsep=3pt
\small
\[\begin{array}{rcl}
  \langle \, \return{()} &;& \textbf{\texttt{do}} {(v, s)} \leftarrow \\
  && \quad \textbf{\texttt{handle}} \\
  && \quad \quad \textbf{\texttt{do}} \, x \leftarrow ([-];\return{\texttt{1}}) \textbf{\texttt{in}}\\
  && \quad \quad \textbf{\texttt{do}} \, y \leftarrow (\print{2};\return{\texttt{2}})\\
  && \quad\quad \textbf{\texttt{in}} \, {\, x + y}\\
  && \quad \textbf{\texttt{with}} \, \{ h \}\\
  && \textbf{\texttt{in}} \, \return{(v, \texttt{f"\{$1$\};"} \text{ \^\ } s)}  \, \rangle
\end{array}
  \]
}
The side-condition on \textsc{Eff-Op} is needed because the user may define multiple handlers with different semantics for the same effect. The side-condition resolves any ambiguity by using the \textit{latest} handler. For example, the following program has a \textbf{\texttt{read}} effect that is given two definitions: it could read either \texttt{1} or \texttt{2}. The ambiguity is resolved by choosing the latest handler: in this case, the program reads \texttt{1}.
\begin{eff}
$\begin{array}{l}
  \textbf{\texttt{handle}} \\
  \quad \handleWith{\textbf{\texttt{read}()}}{\returnHandler{y}{\return{y}}; \textbf{\texttt{read}}(x, k) \mapsto {\continue{k}{1}}} \\
  \textbf{\texttt{with}} \\ 
  \quad \{ \returnHandler{y}{\return{y}}; \textbf{\texttt{read}}(x, k) \mapsto {\continue{k}{2}} \}
\end{array}$ 

\vspace{2mm} 
\textcolor{effComment}{\hrule height 0.2mm \relax}
\vspace{2mm} 

\textcolor{effComment}{$\begin{array}{l}\return{\texttt{1}}\end{array}$}
\end{eff}


\subsubsection{Type-and-Effect System}
I now give a type-and-effect system to \efflang{}. \Cref{fig:efflang-type-syntax} collates the syntax of \efflang{} types, which I now briefly describe. 

\begin{figure}
  \begin{eff-desc}
  {\large \textbf{Types}}\\

  $\begin{array}{@{}lllr}
    \text{Effects row} & \Delta ::= \emptyset \mid \Delta \cup \{ \texttt{op}_i \} \\ \\
    \text{Value type} & T ::= \mathbb{N} & \\
                              &\quad\quad\,\,\, \mid \functionType{T_1}{T_2} & \text{functions}\\
                              &\quad\quad\,\,\, \mid \continuationType{T_1}{T_2} & \text{continuations}\\ \\
    \text{Computation type} & \effectType{T} \\
    \text{Handler type} & \handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}
  \end{array}$
  \end{eff-desc}
  \caption{\efflang{} types. Notice that, just as terms are divided into values, computations, and handlers, types are divided into value types ($T$), computation types ($\effectType{T}$), and handler types ($\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}$)}
  \label{fig:efflang-type-syntax}
\end{figure}

Previously, I assumed that the user declared their effects in advance. I additionally assume that they declare the types of their effects in advance, and that I store the mapping from effects to types in $\Sigma$. That is, 
\[\texttt{op}: A \to B \in \Sigma \]
In \texttt{OCaml}, this would correspond to writing:
\begin{ocaml}
type _ Effect.t += Op: A -> B
\end{ocaml}
I do not impose any restrictions on $A$ and $B$. In particular, they may be recursive, and refer to \texttt{op}. For example:
\[\texttt{recursive}: 1 \to (\functionType[\{ \texttt{recursive} \}]{1}{1})\]
Thus, one may write programs which do not terminate, by ``tying the knot''. 

Just like terms, types are divided into value types (for example, $\mathbb{N}$), computation types ($\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}$), and handler types ($\handlerType{\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{\mathbb{N}}}$). Since computations may have effects, computation types track unhandled effects using an effects row ($\Delta$), which in \efflang{} is simply a set. This type-and-effect system allows us to distinguish between values, computations that return values, and computations that return values and additionally have some unhandled side effects.
\[
\begin{array}{lll}
  \textbf{Term} &\hspace{8mm}& \textbf{Type} \\
  3 && \mathbb{N} \\ 
  \bind{x}{\return{1}}{\bind{y}{\return{2}}{x + y}} &&  \effectType[\emptyset]{\mathbb{N}} \\ 
  \bind{x}{\texttt{\textbf{print}($1$)}; \return{1}}{\bind{y}{\return{2}}{x + y}} &&  \effectType[\{ \texttt{\textbf{print}}\}]{\mathbb{N}} \\ 
\end{array}
\]

Functions are values, and are applied to other values, but produce computations on application. For example, the function 
\[
\function{x:\mathbb{N}}{\; \textbf{\texttt{print}}(x); \return{x}}
\]
is a value that accepts a value of type $\mathbb{N}$ and returns a computation of type $\effectType[\{\textbf{\texttt{print}} \}]{\mathbb{N}}$. Functions thus have suspended effects, which I write $\functionType{T_1}{T_2}$. In this case, the function has type $\functionType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}{\mathbb{N}}$. For technical reasons, continuations and functions need to be distinguished, but in most cases they may be treated equivalently. 

Handlers transform computations of one type to computations of another type. This happens in two ways: first, by handling effects, and thus removing them from the effects row. Second, by modifying the return type of computations. To reflect both abilities, handlers are given a type of the form $\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}$. For example, a handler of the form  
\[ \begin{array}{ll}
  \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
    \quad \, \,\, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}
  \end{array}
\]
may be given type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$, reflecting both the handling of the \textbf{\texttt{print}} effect and the transformation of the return type to include the collated print statements.

I now consider the typing rules for terms, which are collated in \Cref{fig:efflang-type-system}. Most rules are standard, but a few are worth paying attention to. 

\begin{figure}
  \begin{eff-desc}
    {\large\textbf{Typing Rules}}\\
    
    {
    \centering 
    \begin{minipage}[t]{0.2\textwidth}
      \centering
      $\inferrule[(Nat)]
      { \\ }
      {\type{n}{\mathbb{N}}}$
      \end{minipage}% 
  \begin{minipage}[t]{0.2\textwidth}
    \centering
  $\inferrule[(Var)]
  {\Gamma(x) = T}
  {\type{x}{T}}$
  \end{minipage}% 
  \begin{minipage}[t]{0.3\textwidth}
    \centering
  $\inferrule[(Lambda)]
    {\type[, x:T_1]{c}{\effectType{T_2}}}
    {\type{\function{x}{c}}{\functionType{T_1}{T_2}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.3\textwidth}
  \centering
$\inferrule[(Continuation)]
  {\type[, x:T_1]{c}{\effectType{T_2}}}
  {\type{\continuation{x}{c}}{\continuationType{T_1}{T_2}}}$
\end{minipage}
  
  \vspace{5mm}
  
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(App)]
    {\type{v_1}{T_1 \oset{\text{\tiny{$\Delta$}}}\longrightarrow T_2} \\ \type{v_2}{T_1}}
    {\type{v_1 \, v_2}{\effectType{T_2}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Continue)]
    {\type{v_1}{\continuationType{T_1}{T_2}} \\ \type{v_2}{T_1}}
    {\type{\continue{v_1}{v_2}}{\effectType{T_2}}}$
  \end{minipage}

  \vspace{5mm}

  \begin{minipage}[t]{0.3\textwidth}
    \centering
  $\inferrule[(Return)]
    {\type{v}{T}}
    {\type{\return{v}}{\effectType{T}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.55\textwidth}
    \centering
  $\inferrule[(Do)]
    {\type{c_1}{\effectType{T_1}} \\ \type[, x: T_1]{c_2}{\effectType{T_2}}}
    {\type{\bind{x}{c_1}{c_2}}{\effectType{T_2}}}$
  \end{minipage}
  
  \vspace{5mm}
  % \begin{minipage}[t]{0.5\textwidth}
  %   \centering
  % $\inferrule[(Do)]
  %   {\type{c_1}{\effectType{T_1}} \\ \type[, x: T_1]{c_2}{\effectType{T_2}}}
  %   {\type{\bind{x}{c_1}{c_2}}{\effectType{T_2}}}$
  % \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Op)]
    {  \\\\ \type{v}{T_1} \\ \texttt{op}: T_1 \rightarrow T_2 \in \Sigma \\ \texttt{op} \in \Delta}
    {\type{\op{v}}{\effectType{T_2}}}$
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}
    \centering
  $\inferrule[(Handle)]
    {\type{c}{\effectType{T_1}} \\ \type{h}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}} \\ \forall \textsf{op} \in \Delta \setminus \Delta'. \, \textsf{op} \in \textsf{dom}(h)}
    {\type{\handleWith{c}{h}}{\effectType[\Delta']{T_2}}}$
  \end{minipage}\\

  \vspace{5mm}

  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(Ret-Handler)]
    {\type[, x:T_1]{c}{\effectType[\Delta']{T_2}}}
    {\type{\returnHandler{x}{c}}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}}$
  \end{minipage}
  
  \vspace{5mm}
  % \[\inferrule [(Lam)]
  % {\type[, x:T_1]{t}{\sEffect{T_2}}}
  % {\type{\function{x}{t}}{\sFunctionType{T_1}{T_2}}}\]
  
  % \[\inferrule[(App)]
  % {\type{n_1}{\sFunctionType{T_1}{T_2}} \\
  \begin{minipage}[t]{\textwidth}
    \centering
  $\inferrule[(Op-Handler)]
    { \texttt{op}: A \to B \in \Sigma \\\\ 
      \type{h}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}\\
      \type[, x:A, k:{\continuationType[\Delta']{B}{T_2}} ]{c}{\effectType[\Delta']{T_2}}\\
      \Delta' \subseteq \Delta \setminus \{ \texttt{op} \} \\
             \opHandler{x'}{k'}{c'} \notin h}
    {\type{h ; \opHandler{x}{k}{c}}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}}$
  \end{minipage}
    }
  \end{eff-desc}
  \caption{Typing rules for \efflang{} terms}
  \label{fig:efflang-type-system}
  \end{figure}

First, the \textsc{Return} and \textsc{Do} rules. In the \textsc{Return} rule, we are allowed to assign the term $\return{v}$ any set of effects. For example, we could write:
\[\inferrule{ }{\type[]{\return{\texttt{0}}}{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}}\] 
This flexibility is important, because to type $\bind{x}{c_1}{c_2}$, the \textsc{Do} rule requires both $c_1$ and $c_2$ to have the same effects. For example, without this flexibility, we would not be able to complete the following typing derivation
\[\inferrule{\vdots}{\type[]{\bind{x}{\print{0}}{\return{\texttt{0}}}}{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}}\] 
A valid alternative would be to add explicit subtyping. However, such an approach would no longer be syntax directed. 

Second, the \textsc{Op} rule. Note the $\texttt{op} \in \Delta$ restriction: flexibility allows us to over-approximate the effects in a term, but never underapproximate them. 

Third, the \textsc{Ret-Handler} and \textsc{Op-Handler} rules, which are used to type handlers. Assume we are trying to type the handler 
\[ \begin{array}{ll}
  \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{(x, \texttt{""})}}; \\
    \quad \, \,\, \textbf{\texttt{print}}(x, k) \mapsto {\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\}
  \end{array}
\]
with the type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$. We apply the \textsc{Op-Handler} rule, which is transcribed below. Preconditions are numbered for reference. 
\[\inferrule[(Op-Handler)]
    { (1)\,  \texttt{op}: A \to B \in \Sigma \\\\
     (2)\, \type{h}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}\\
      (3)\,\type[, x:A, k:{\continuationType[\Delta']{B}{T_2}} ]{c}{\effectType[\Delta']{T_2}}\\
      (4)\,\Delta' \subseteq \Delta \setminus \{ \texttt{op} \} \\
      (5)\, \opHandler{x'}{k'}{c'} \notin h}
    {\type{h ; \opHandler{x}{k}{c}}{\handlerType{\effectType{T_1}}{\effectType[\Delta']{T_2}}}}\]
The preconditions of the \textsc{Op-Handler} rule direct us to check, in turn:
\begin{enumerate}
  \item[(1)] $\textbf{\texttt{print}}: \mathbb{N} \to 1 \in \Sigma$, which is true by assumption
  \item[(2)] Recursively check the rest of the handler $h = \returnHandler{x}{\return{(x, \texttt{""})}}$, ensuring it has type $\handlerType{\effectType[\{ \textbf{\texttt{print}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$. This follows from a trivial application of the \textsc{Ret-Handler} rule. 
  \item[(3)] Assuming $x$ has type $\mathbb{N}$ and $k$ has type $\continuationType[\emptyset]{1}{(\mathbb{N} \times \textsf{String})}$, the body \[{\bind{(v, s)}{\continue{k}{()}}{\return{(v, \texttt{f"\{$x$\};"} \text{ \^\ } s)}}}\] has type $\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}$. This is easy to show.
  \item[(4)] That the handler \textit{only} removes \textbf{\texttt{print}} from the effects row, and no other effects. This check passes, but would fail if we tried to type the handler with, for example, $\handlerType{\effectType[\{ \textbf{\texttt{print}}, \textbf{\texttt{get}} \}]{\mathbb{N}}}{\effectType[\emptyset]{(\mathbb{N} \times \textsf{String})}}$
  \item[(5)] That there are no other handlers for \textbf{\texttt{print}} in $h$.
\end{enumerate}

Finally, I define a notion of well-typed computation. 
\begin{definition}[Well-typed computation]{effHighlight}
  $c$ is well-typed if $\cdot \vdash {c}: {T \, ! \, \emptyset}$
\end{definition}

\subsubsection{Metatheory}
I build not only on \efflang{}, but on metatheoretic properties of \efflang{}, which are proven by \citet{bauer-2014}.

\renewcommand{\effconfiguration}[2]{\langle {#1}; {#2} \rangle}
\renewcommand{\transition}[2]{#1 \rightarrow #2}

\begin{theorem}[Progress]{effHighlight}\label{thm:progress}
If $\type{E[c]}{\effectType{T}}$ then either 
\begin{enumerate}
\item $c$ of the form $\return{v}$ and $E = [-]$,
\item $c$ of the form $\op{v}$ for some $\textsf{op} \in \Delta$,
\item $\exists. E', c'$ such that $\transition{\effconfiguration{c}{E}}{\effconfiguration{c'}{E'}}$
\end{enumerate}
\end{theorem}
\vspace{-\baselineskip}
\begin{theorem}[Preservation]{effHighlight}\label{thm:preservation}
If $\type{E[c]}{\effectType{T}}$ and $\transition{\effconfiguration{c}{E}}{\effconfiguration{c'}{E'}}$, then $\type{E'[c']}{\effectType{T}}$
\end{theorem}
\vspace{-\baselineskip}
\begin{corollary}[Type Safety]{effHighlight}\label{thm:type-safety}
  If $\cdot \vdash {c}: {\effectType[\emptyset]{T}}$ then either 
\begin{enumerate}
\item $\langle c; [-] \rangle \to^{\omega}$ (non-termination)
\item $\langle c; [-] \rangle \to^{*} \langle \return{v}; [-] \rangle$
\end{enumerate}
\end{corollary}

\newcommand{\contextequiv}{\cong_{\text{\emph{ctx}}}}

% Finally, \efflang{} is a \textit{fine-grain call-by-value} \citep{levy-2003} approach. We first define a notion of contextual equivalence $\contextequiv$. Informally, two computations/values are contextually equivalent if they behave the same in all ``relevant'' contexts and at all ground (first-order) types (in this case, just $\mathbb{N}$). 

% % To define a notion of ``relevant'', we first type contexts

% % \begin{figure}
% % \begin{eff-desc}
% % $\inferrule{\\}{\Gamma \vdash_{\Gamma, \effectType{T}} [-]: \effectType{T}}$
% % \end{eff-desc}
% % \end{figure}

% \begin{definition}[Contextual Equivalence]{effHighlight}\label{dfn:ctx-equiv}
%   $c$ and $c'$ are contextually equivalent at context $\Gamma$ and type $\effectType{T}$, written $\Gamma \vdash c \contextequiv c': '\effectType{T}$ if 
%   \begin{enumerate}
%     \item $\type{c}{\effectType{T}}$ and $\type{c'}{\effectType{T}}$
%     \item For all $E$ such that $\cdot \vdash {E[c]}: {\effectType[\emptyset]{\mathbb{N}}}$  and $\cdot \vdash {E[c']}: {\effectType[\emptyset]{\mathbb{N}}}$, 
%     \[ \effconfiguration{c}{E}  \, \to^{*} \, { \effconfiguration{\return{v}}{[-]}}  \iff  \effconfiguration{c'}{E} \, \to^{*} \,  \effconfiguration{\return{v}}{[-]} \]
%   \end{enumerate}

%   When the context $\Gamma$ is empty, we write $c \contextequiv c': \effectType{T}$, and when the type is unimportant, we write $c \contextequiv c'$
% \end{definition}
% \vspace{-\baselineskip}
% \begin{definition}[Fine-Grain CBV]{effHighlight}\label{dfn:fine-grain-cbv}
%   \efflang{} is a fine-grain call-by-value language, meaning in particular that the following equations hold (notationally, I use $c$ for computations, $v$ for values, and $f$ for function values):
%   \begin{enumerate}
%     \item $\bind{x}{\return{v}}{c} \, \contextequiv \, c[v/x]$
%     \item $c \, \contextequiv \, \bind{x}{c \,}{\return{x}}$
%     \item $\bind{x}{c_1}{(\bind{y}{c_2}{c_3})} \, \contextequiv \bind{y}{(\bind{x}{c_1}{c_2})}{c_3}$
%     \item $(\lambda x. c) v \, \contextequiv \, c[v/x]$
%     \item $f \, \contextequiv \, \lambda x. f x$
%   \end{enumerate}
% In the third equation, we assume $x$ not free in $c_3$.
% \end{definition}

\subsection{The Design Space of Effect Handlers}\label{subsection:effect-handler-design}
The design space of effect handlers is large. I consider three key design decisions made by different systems.

\renewcommand{\effconfiguration}[2]{{#1}; {#2}}
\renewcommand{\transition}[2]{#1 & \rightarrow & #2}
\newcommand{\rulename}[2]{(\textsc{{#1}-{#2}})}
\newcommand{\reductionRule}[1]{\rulename{Red}{#1}}
\newcommand{\congruenceRule}[1]{\rulename{Cng}{#1}}
\newcommand{\effectRule}[1]{\rulename{Eff}{#1}}

\begin{enumerate} 

 \item \textbf{\textsf{Named or Unnamed Handlers}}\\
        \textit{Can I invoke a specific handler for an operation?}
        
        In \efflang{}, when there are multiple handlers for the same effect, the ``most recent'' handler for that effect is invoked. An alternative approach is \textbf{named handlers} \citep{xie-2022}, where, by associating each handler with a \textit{name}, the programmer can more easily specify which handler should be invoked. 

        While named handlers can be more ergonomic, they do not provide greater expressiveness \citep{xie-2022}. I do not consider named handlers in this thesis.

  \item \textbf{\textsf{Deep, Shallow, or Sheep Handlers}}\\
         \textit{Are multiple instances of the same effect handled by the same handler?}

         In \efflang{}, continuations reinstate handlers $\effectRule{Cnt}$ and thus multiple instances of the same effect are handled by the same handler. For example, in the following example, the effect \textbf{\texttt{addn}} is handled by the same handler, adding one each time. These are known as \textbf{deep} handlers.

         \begin{efflst}
          $\begin{array}{l}
            \textbf{\texttt{handle}} \\
            \quad \textbf{\textsf{addn}}(1) + \textbf{\textsf{addn}}(2) \\
            \textbf{\texttt{with}} \\
            \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{x}}; \\
            \quad \; \, \textbf{\texttt{addn}}(y, k) \mapsto \continue{k}{(y+1)} \}\\
          \end{array}$
          \vspace{2mm} 
          \textcolor{effComment}{\hrule height 0.2mm \relax}
          \vspace{2mm} 
          
          \textcolor{effComment}{$\begin{array}{l}\return{5}\end{array}$}
        \end{efflst}

        I could also have chosen \textit{not} to reinstate the handler, in an approach known as \textbf{shallow} handlers \citep{hillestrom-2018}. The example above would be stuck, since the second \textbf{\texttt{addn}} would not be handled.

        Finally, I could have chosen to modify the interface for \textbf{\texttt{continue}} such that it accepts a handler
        \[\textbf{\texttt{continue}} \, k \,  \, v \, h\]
        This would allow multiple effects to be handled by different handlers. That is, the programmer could add $1$ the first time \textbf{\texttt{addn}} is performed, and $2$ the second time (the program would return $2+4=6$). These handlers behave as a hybrid of shallow and deep handlers, and are thus termed \textbf{sheep} handlers \citep{phipps-costin-2023}. 
         
        Since most prior work on scope extrusion focuses on deep handlers \citep{isoda-24}, I focus on those. 

        \item \textbf{\textsf{One-Shot or Multi-Shot Continuations}}\\
        \textit{How many times can one resume the same continuation?}
 
        In \efflang{}, continuations may be resumed multiple times. For example, the programmer can write 
        
        \begin{efflst}
          $\begin{array}{l}
            \textbf{\texttt{handle}} \\
            \quad \textbf{\textsf{performTwice}}(1) \\
            \textbf{\texttt{with}} \\
            \quad \{ \textbf{\texttt{return}}(x) \mapsto {\return{x}}; \\
            \quad \; \, \textbf{\texttt{performTwice}}(y, k) \mapsto (\continue{k}{y}) + (\continue{k}{y}) \}\\
          \end{array}$
          \vspace{2mm} 
          \textcolor{effComment}{\hrule height 0.2mm \relax}
          \vspace{2mm} 
          
          \textcolor{effComment}{$\begin{array}{l}\return{2}\end{array}$}
        \end{efflst}
        
        Such an effect system is said to permit \textbf{multi-shot continuations}. Multi-shot continuations are useful for simulating certain effects, like non-determinism \citep{phipps-costin-2023}. 

        In other systems, like \texttt{OCaml} and \texttt{WasmFX} \citep{phipps-costin-2023}, this is not allowed: continuations are only allowed to be resumed once. These systems permit \textbf{one-shot continuations}. 

        Although continuations in \texttt{OCaml} are one-shot, I believe it is worthwhile to study effect systems with multi-shot continuations.
\end{enumerate}
