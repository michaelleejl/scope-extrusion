@article{rice-53,
  issn      = {00029947, 10886850},
  url       = {http://www.jstor.org/stable/1990888},
  author    = {H. G. Rice},
  journal   = {Transactions of the American Mathematical Society},
  number    = {2},
  pages     = {358--366},
  publisher = {American Mathematical Society},
  title     = {Classes of Recursively Enumerable Sets and Their Decision Problems},
  urldate   = {2025-04-11},
  volume    = {74},
  year      = {1953}
}


@inproceedings{robinson-01,
  author    = {Robison, Arch D.},
  title     = {Impact of economics on compiler optimization},
  year      = {2001},
  isbn      = {1581133596},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/376656.376751},
  doi       = {10.1145/376656.376751},
  abstract  = {Compile-time program optimizations are similar to poetry: more are written than are actually published in commercial compilers. Hard economic reality is that many interesting optimizations have too narrow an audience to justify their cost in a general-purpose compiler, and custom compilers are too expensive to write. An alternative is to allow programmers to define their own compile-time optimizations. This has already happened accidentally for C++, albeit imperfectly, in the form of template metaprogramming. This paper surveys the problems, the accidental success, and what directions future research might take to circumvent current economic limitations of monolithic compilers.},
  booktitle = {Proceedings of the 2001 Joint ACM-ISCOPE Conference on Java Grande},
  pages     = {1–10},
  numpages  = {10},
  keywords  = {optimization, economics, compilers},
  location  = {Palo Alto, California, USA},
  series    = {JGI '01}
}

@book{abrahams-04,
  author    = {Abrahams, David and Gurtovoy, Aleksey},
  title     = {C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond (C++ in Depth Series)},
  year      = {2004},
  isbn      = {0321227255},
  publisher = {Addison-Wesley Professional},
  abstract  = {C++ Template Metaprogramming sheds light on the most powerful idioms of today's C++, at long last delivering practical metaprogramming tools and techniques into the hands of the everyday programmer.A metaprogram is a program that generates or manipulates program code. Ever since generic programming was introduced to C++, programmers have discovered myriad "template tricks" for manipulating programs as they are compiled, effectively eliminating the barrier between program and metaprogram. While excitement among C++ experts about these capabilities has reached the community at large, their practical application remains out of reach for most programmers. This book explains what metaprogramming is and how it is best used. It provides the foundation you'll need to use the template metaprogramming effectively in your own work.This book is aimed at any programmer who is comfortable with idioms of the Standard Template Library (STL). C++ power-users will gain a new insight into their existing work and a new fluency in the domain of metaprogramming. Intermediate-level programmers who have learned a few advanced template techniques will see where these tricks fit in the big picture and will gain the conceptual foundation to use them with discipline. Programmers who have caught the scent of metaprogramming, but for whom it is still mysterious, will finally gain a clear understanding of how, when, and why it works. All readers will leave with a new tool of unprecedented power at their disposal-the Boost Metaprogramming Library.The companion CD-ROM contains all Boost C++ libraries, including the Boost Metaprogramming Library and its reference documentation, along with all of the book's sample code and extensive supplementary material.}
}

@article{pretnar-15,
  title    = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
  journal  = {Electronic Notes in Theoretical Computer Science},
  volume   = {319},
  pages    = {19-35},
  year     = {2015},
  note     = {The 31st Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXI).},
  issn     = {1571-0661},
  doi      = {https://doi.org/10.1016/j.entcs.2015.12.003},
  url      = {https://www.sciencedirect.com/science/article/pii/S1571066115000705},
  author   = {Matija Pretnar},
  keywords = {algebraic effects, handlers, effect system, semantics, logic, tutorial},
  abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading.}
}

@inproceedings{sivaramakrishnan-21,
  author    = {Sivaramakrishnan, KC and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
  title     = {Retrofitting effect handlers onto OCaml},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454039},
  doi       = {10.1145/3453483.3454039},
  abstract  = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for OCaml, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing OCaml code. Retrofitting effect handlers onto OCaml is challenging since OCaml does not currently have any non-local control flow mechanisms other than exceptions. Our implementation of effect handlers for OCaml: (i)&nbsp;imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii)&nbsp;remains compatible with program analysis tools that inspect the stack; and (iii)&nbsp;is efficient for new code that makes use of effect handlers.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {206–221},
  numpages  = {16},
  keywords  = {Backtraces, Backwards compatibility, Continuations, Effect handlers, Fibers},
  location  = {Virtual, Canada},
  series    = {PLDI 2021}
}

@inproceedings{kiselyov-14,
  author    = {Kiselyov, Oleg},
  editor    = {Codish, Michael
               and Sumii, Eijiro},
  title     = {The Design and Implementation of BER MetaOCaml},
  booktitle = {Functional and Logic Programming},
  year      = {2014},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {86--102},
  abstract  = {MetaOCaml is a superset of OCaml extending it with the data type for program code and operations for constructing and executing such typed code values. It has been used for compiling domain-specific languages and automating tedious and error-prone specializations of high-performance computational kernels. By statically ensuring that the generated code compiles and letting us quickly run it, MetaOCaml makes writing generators less daunting and more productive.},
  isbn      = {978-3-319-07151-0}
}

@inproceedings{calcagno-00,
  author    = {Calcagno, Cristiano
               and Moggi, Eugenio
               and Taha, Walid},
  editor    = {Montanari, Ugo
               and Rolim, Jos{\'e} D. P.
               and Welzl, Emo},
  title     = {Closed Types as a Simple Approach to Safe Imperative Multi-stage Programming},
  booktitle = {Automata, Languages and Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {25--36},
  abstract  = {Safely adding computational effects to a multi-stage language has been an open problem. In previous work, a closed type constructor was used to provide a safe mechanism for executing dynamically generated code. This paper proposes a general notion of closed type as a simple approach to safely introducing computational effects into multi-stage languages. We demonstrate this approach formally in a core language called Mini-MLrefBN. This core language combines safely multi-stage constructs and ML-style references. In addition to incorporating state, Mini-MLrefBN also embodies a number of technical improvements over previously proposed core languages for multi-stage programming.},
  isbn      = {978-3-540-45022-1}
}

@inproceedings{kiselyov-16,
  author    = {Kiselyov, Oleg
               and Kameyama, Yukiyoshi
               and Sudo, Yuto},
  editor    = {Igarashi, Atsushi},
  title     = {Refined Environment Classifiers},
  booktitle = {Programming Languages and Systems},
  year      = {2016},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {271--291},
  abstract  = {Generating high-performance code and applying typical optimizations within the bodies of loops and functions involves moving or storing open code for later use, often in a different binding environment. There are ample opportunities for variables being left unbound or accidentally captured. It has been a tough challenge to statically ensure that by construction the generated code is nevertheless well-typed and well-scoped: all free variables in manipulated and stored code fragments shall eventually be bound, by their intended binders.},
  isbn      = {978-3-319-47958-3}
}

@inproceedings{isoda-24,
  author    = {Isoda, Kanaru and Yokoyama, Ayato and Kameyama, Yukiyoshi},
  title     = {Type-Safe Code Generation with Algebraic Effects and Handlers},
  year      = {2024},
  isbn      = {9798400712111},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3689484.3690731},
  doi       = {10.1145/3689484.3690731},
  abstract  = {Staged computation is a means to achieve maintainability and high performance simultaneously, by allowing a programmer to express domain-specific optimizations in a high-level programming language. Multi-stage programming languages such as MetaOCaml provide a static safety guarantee for generated programs by sophisticated type systems provided that program generators have no computational effects. Despite several studies, it remains a challenging problem to design a type-safe multi-stage programming language with advanced features for computational effects. This paper introduces a two-stage programming language with algebraic effects and handlers. Based on two novel principles 'handlers as future-stage binders' and 'handlers are universal', we design a type system and prove its soundness. We also show that our language is sufficiently expressive to write various effectful staged computations including multi-level let-insertion, which is a key technique to avoid code duplication in staged computation.},
  booktitle = {Proceedings of the 23rd ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences},
  pages     = {53–65},
  numpages  = {13},
  keywords  = {Algebraic effects and handlers, Code generation, Scope extrusion, Type soundness},
  location  = {Pasadena, CA, USA},
  series    = {GPCE '24}
}

@article{tratt-2008,
  title     = {Domain specific language implementation via compile-time meta-programming},
  author    = {Tratt, Laurence},
  journal   = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume    = {30},
  number    = {6},
  pages     = {1--40},
  year      = {2008},
  publisher = {ACM New York, NY, USA}
}

@article{yallop-2023,
  author     = {Yallop, Jeremy and Xie, Ningning and Krishnaswami, Neel},
  title      = {flap: A Deterministic Parser with Fused Lexing},
  year       = {2023},
  issue_date = {June 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {PLDI},
  url        = {https://doi.org/10.1145/3591269},
  doi        = {10.1145/3591269},
  abstract   = {Lexers and parsers are typically defined separately and connected by a token stream. This separate definition is important for modularity and reduces the potential for parsing ambiguity. However, materializing tokens as data structures and case-switching on tokens comes with a cost. We show how to fuse separately-defined lexers and parsers, drastically improving performance without compromising modularity or increasing ambiguity. We propose a deterministic variant of Greibach Normal Form that ensures deterministic parsing with a single token of lookahead and makes fusion strikingly simple, and prove that normalizing context free expressions into the deterministic normal form is semantics-preserving. Our staged parser combinator library, flap, provides a standard interface, but generates specialized token-free code that runs two to six times faster than ocamlyacc on a range of benchmarks.},
  journal    = {Proc. ACM Program. Lang.},
  month      = jun,
  articleno  = {155},
  numpages   = {24},
  keywords   = {parsing, optimization, multi-stage programming, lexing, fusion}
}

@inproceedings{servetto-2013,
  author    = {Servetto, Marco and Zucca, Elena},
  title     = {A meta-circular language for active libraries},
  year      = {2013},
  isbn      = {9781450318426},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2426890.2426913},
  doi       = {10.1145/2426890.2426913},
  abstract  = {We present a new Java-like language design coupling disciplined meta-programming features with a composition language. That is, programmers can write meta expressions that combine class definitions, on top of a small set of composition operators, inspired by the seminal Bracha's Jigsaw framework. Moreover, such operators are deep, that is, they allow manipulation (e.g., renaming or duplication) of a nested class at any level of depth.This provides an effective language support for active libraries: namely, a (library) class can provide a method returning a customized version of a class, depending, e.g., on the execution platform. Since a class can contain nested classes, a whole library can be generated in this way. That is, deep operators allows the programmer to better exploit meta-programming capabilities, leading to a "meta-programming in the large" style.We adopt a mixed typechecking technique, which provides a good compromise between meta-programming systems with extreme expressiveness and no static type checking, and those with strong type system and only limited meta-programming capability. In particular, our technique ensures an important property, called meta-level soundness, stating that typing errors never originate from already compiled (meta-)code, that is, programmers can safely use (active) libraries.},
  booktitle = {Proceedings of the ACM SIGPLAN 2013 Workshop on Partial Evaluation and Program Manipulation},
  pages     = {117–126},
  numpages  = {10},
  keywords  = {active libraries, java, meta-programming, nested classes},
  location  = {Rome, Italy},
  series    = {PEPM '13}
}

@book{wickham-2019,
  title     = {Advanced R},
  author    = {Wickham, Hadley},
  year      = {2019},
  publisher = {Chapman and Hall/CRC}
}

@article{vandebon-2021,
  author   = {Vandebon, Jessica and Coutinho, Jose G. F. and Luk, Wayne and Nurvitadhi, Eriko},
  journal  = {IEEE Transactions on Computers},
  title    = {Enhancing High-Level Synthesis Using a Meta-Programming Approach},
  year     = {2021},
  volume   = {70},
  number   = {12},
  pages    = {2043-2055},
  keywords = {Optimization;Field programmable gate arrays;Heterogeneous networks;Programming;Task analysis;Python;Heterogeneous computing;meta-programming;FPGA;high-level synthesis},
  doi      = {10.1109/TC.2021.3096429}
}

@misc{jax-grad-metaprogramming,
  author = {Jax-Ml},
  title  = {Using grad on vmap on map on function containing sinc results in error},
  url    = {https://github.com/jax-ml/jax/issues/10750}
}

@article{kiselyov-2012,
  title    = {Delimited control in OCaml, abstractly and concretely},
  journal  = {Theoretical Computer Science},
  volume   = {435},
  pages    = {56-76},
  year     = {2012},
  note     = {Functional and Logic Programming},
  issn     = {0304-3975},
  doi      = {https://doi.org/10.1016/j.tcs.2012.02.025},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397512001661},
  author   = {Oleg Kiselyov},
  keywords = {Delimited continuation, Exception, Semantics, Implementation, Abstract machine},
  abstract = {We describe the first implementation of multi-prompt delimited control operators in OCaml that is direct in that it captures only the needed part of the control stack. The implementation is a library that requires no changes to the OCaml compiler or run-time, so it is perfectly compatible with existing OCaml source and binary code. The library has been in fruitful practical use since 2006. We present the library as an implementation of an abstract machine derived by elaborating the definitional machine. The abstract view lets us distill a minimalistic API, scAPI, sufficient for implementing multi-prompt delimited control. We argue that a language system that supports exception and stack-overflow handling supports scAPI. With byte- and native-code OCaml systems as two examples, our library illustrates how to use scAPI to implement multi-prompt delimited control in a typed language. The approach is general and has been used to add multi-prompt delimited control to other existing language systems.}
}

@article{pretnar-2015,
  title    = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
  journal  = {Electronic Notes in Theoretical Computer Science},
  volume   = {319},
  pages    = {19-35},
  year     = {2015},
  note     = {The 31st Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXI).},
  issn     = {1571-0661},
  doi      = {https://doi.org/10.1016/j.entcs.2015.12.003},
  url      = {https://www.sciencedirect.com/science/article/pii/S1571066115000705},
  author   = {Matija Pretnar},
  keywords = {algebraic effects, handlers, effect system, semantics, logic, tutorial},
  abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading.}
}

@inproceedings{felleisen-87,
  author    = {Matthias Felleisen and
               Daniel P. Friedman},
  editor    = {Martin Wirsing},
  title     = {Control operators, the SECD-machine, and the {\(\lambda\)}-calculus},
  booktitle = {Formal Description of Programming Concepts - {III:} Proceedings of
               the {IFIP} {TC} 2/WG 2.2 Working Conference on Formal Description
               of Programming Concepts - III, Ebberup, Denmark, 25-28 August 1986},
  pages     = {193--222},
  publisher = {North-Holland},
  year      = {1987},
  timestamp = {Thu, 10 Jan 2019 14:38:20 +0100},
  biburl    = {https://dblp.org/rec/conf/ifip2/FelleisenF87.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}