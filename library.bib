
@article{rice-53,
  issn      = {00029947, 10886850},
  url       = {http://www.jstor.org/stable/1990888},
  author    = {H. G. Rice},
  journal   = {Transactions of the American Mathematical Society},
  number    = {2},
  pages     = {358--366},
  publisher = {American Mathematical Society},
  title     = {Classes of {Recursively Enumerable} Sets and Their Decision Problems},
  urldate   = {2025-04-11},
  volume    = {74},
  year      = {1953}
}


@inproceedings{robinson-01,
  author    = {Robison, Arch D.},
  title     = {Impact of economics on compiler optimization},
  year      = {2001},
  isbn      = {1581133596},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/376656.376751},
  doi       = {10.1145/376656.376751},
  abstract  = {Compile-time program optimizations are similar to poetry: more are written than are actually published in commercial compilers. Hard economic reality is that many interesting optimizations have too narrow an audience to justify their cost in a general-purpose compiler, and custom compilers are too expensive to write. An alternative is to allow programmers to define their own compile-time optimizations. This has already happened accidentally for {C++}, albeit imperfectly, in the form of template metaprogramming. This paper surveys the problems, the accidental success, and what directions future research might take to circumvent current economic limitations of monolithic compilers.},
  booktitle = {Proceedings of the 2001 Joint {ACM-ISCOPE} Conference on {Java Grande}},
  pages     = {1–10},
  numpages  = {10},
  keywords  = {optimization, economics, compilers},
  location  = {Palo Alto, California, USA},
  series    = {{JGI} '01}
}

@book{abrahams-04,
  author    = {Abrahams, David and Gurtovoy, Aleksey},
  title     = {{C++} Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond ({C++} in Depth Series)},
  year      = {2004},
  isbn      = {0321227255},
  publisher = {Addison-Wesley Professional},
  abstract  = {C++ Template Metaprogramming sheds light on the most powerful idioms of today's C++, at long last delivering practical metaprogramming tools and techniques into the hands of the everyday programmer.A metaprogram is a program that generates or manipulates program code. Ever since generic programming was introduced to C++, programmers have discovered myriad "template tricks" for manipulating programs as they are compiled, effectively eliminating the barrier between program and metaprogram. While excitement among C++ experts about these capabilities has reached the community at large, their practical application remains out of reach for most programmers. This book explains what metaprogramming is and how it is best used. It provides the foundation you'll need to use the template metaprogramming effectively in your own work.This book is aimed at any programmer who is comfortable with idioms of the Standard Template Library (STL). C++ power-users will gain a new insight into their existing work and a new fluency in the domain of metaprogramming. Intermediate-level programmers who have learned a few advanced template techniques will see where these tricks fit in the big picture and will gain the conceptual foundation to use them with discipline. Programmers who have caught the scent of metaprogramming, but for whom it is still mysterious, will finally gain a clear understanding of how, when, and why it works. All readers will leave with a new tool of unprecedented power at their disposal-the Boost Metaprogramming Library.The companion CD-ROM contains all Boost C++ libraries, including the Boost Metaprogramming Library and its reference documentation, along with all of the book's sample code and extensive supplementary material.}
}

@inproceedings{sheard-02,
  author    = {Sheard, Tim and Jones, Simon Peyton},
  title     = {Template meta-programming for {Haskell}},
  year      = {2002},
  isbn      = {1581136056},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/581690.581691},
  doi       = {10.1145/581690.581691},
  abstract  = {We propose a new extension to the purely functional programming language Haskell that supports compile-time meta-programming. The purpose of the system is to support the algorithmic construction of programs at compile-time.The ability to generate code at compile time allows the programmer to implement such features as polytypic programs, macro-like expansion, user directed optimization (such as inlining), and the generation of supporting data structures and functions from existing data structures and functions.Our design is being implemented in the Glasgow Haskell Compiler, ghc.},
  booktitle = {Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell},
  pages     = {1–16},
  numpages  = {16},
  keywords  = {meta programming, templates},
  location  = {Pittsburgh, Pennsylvania},
  series    = {Haskell '02}
}

@misc{huceke-memcpy,
  author       = {huceke},
  title        = {memcpy.c},
  howpublished = {\url{https://github.com/huceke/xine-lib-vaapi/blob/master/src/xine-utils/memcpy.c}},
  note         = {Accessed: 2025-05-26}
}

@article{lawall-94,
  author     = {Lawall, Julia L. and Danvy, Olivier},
  title      = {Continuation-based partial evaluation},
  year       = {1994},
  issue_date = {July-Sept. 1994},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {VII},
  number     = {3},
  issn       = {1045-3563},
  url        = {https://doi.org/10.1145/182590.182483},
  doi        = {10.1145/182590.182483},
  abstract   = {Binding-time improvements aim at making partial evaluation (a.k.a. program specialization) yield a better result. They have been achieved so far mostly by hand-transforming the source program. We observe that as they are better understood, these hand-transformations are progressively integrated into partial evaluators, thereby alleviating the need for source-level binding-time improvements.Control-based binding-time improvements, for example, follow this pattern: they have evolved from ad-hoc source-level rewrites to a systematic source-level transformation into continuation-passing style (CPS). Recently, Bondorf has explicitly integrated the CPS transformation into the specializer, thus partly alleviating the need for source-level CPS transformation. This CPS integration is remarkably effective but very complex and goes beyond a simple CPS transformation. We show that it can be achieved directly by using the control operators shift and reset, which provide access to the current continuation as a composable procedure.We automate, reproduce, and extend Bondorf's results, and describe how this approach scales up to hand-writing partial-evaluation compilers. The first author has used this method to bootstrap the new release of Consel's partial evaluator Schism. The control operators not only allow the partial evaluator to remain in direct style, but also can speed up partial evaluation significantly.},
  journal    = {{SIGPLAN} Lisp Pointers},
  month      = jul,
  pages      = {227–238},
  numpages   = {12}
}

@article{pretnar-15,
  title    = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
  journal  = {Electronic Notes in Theoretical Computer Science},
  volume   = {319},
  pages    = {19-35},
  year     = {2015},
  note     = {The 31st Conference on the Mathematical Foundations of Programming Semantics ({MFPS XXXI}).},
  issn     = {1571-0661},
  doi      = {https://doi.org/10.1016/j.entcs.2015.12.003},
  url      = {https://www.sciencedirect.com/science/article/pii/S1571066115000705},
  author   = {Matija Pretnar},
  keywords = {algebraic effects, handlers, effect system, semantics, logic, tutorial},
  abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading.}
}

@inproceedings{sivaramakrishnan-21,
  author    = {Sivaramakrishnan, KC and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
  title     = {Retrofitting effect handlers onto {OCaml}},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454039},
  doi       = {10.1145/3453483.3454039},
  abstract  = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for OCaml, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing OCaml code. Retrofitting effect handlers onto OCaml is challenging since OCaml does not currently have any non-local control flow mechanisms other than exceptions. Our implementation of effect handlers for OCaml: (i)&nbsp;imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii)&nbsp;remains compatible with program analysis tools that inspect the stack; and (iii)&nbsp;is efficient for new code that makes use of effect handlers.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {206–221},
  numpages  = {16},
  keywords  = {Backtraces, Backwards compatibility, Continuations, Effect handlers, Fibers},
  location  = {Virtual, Canada},
  series    = {{PLDI} 2021}
}

@inproceedings{kiselyov-14,
  author    = {Kiselyov, Oleg},
  editor    = {Codish, Michael
               and Sumii, Eijiro},
  title     = {The Design and Implementation of {BER MetaOCaml}},
  booktitle = {Functional and Logic Programming},
  year      = {2014},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {86--102},
  abstract  = {MetaOCaml is a superset of OCaml extending it with the data type for program code and operations for constructing and executing such typed code values. It has been used for compiling domain-specific languages and automating tedious and error-prone specializations of high-performance computational kernels. By statically ensuring that the generated code compiles and letting us quickly run it, MetaOCaml makes writing generators less daunting and more productive.},
  isbn      = {978-3-319-07151-0}
}

@inproceedings{calcagno-00,
  author    = {Calcagno, Cristiano
               and Moggi, Eugenio
               and Taha, Walid},
  editor    = {Montanari, Ugo
               and Rolim, Jos{\'e} D. P.
               and Welzl, Emo},
  title     = {Closed Types as a Simple Approach to Safe Imperative Multi-stage Programming},
  booktitle = {Automata, Languages and Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {25--36},
  abstract  = {Safely adding computational effects to a multi-stage language has been an open problem. In previous work, a closed type constructor was used to provide a safe mechanism for executing dynamically generated code. This paper proposes a general notion of closed type as a simple approach to safely introducing computational effects into multi-stage languages. We demonstrate this approach formally in a core language called Mini-MLrefBN. This core language combines safely multi-stage constructs and ML-style references. In addition to incorporating state, Mini-MLrefBN also embodies a number of technical improvements over previously proposed core languages for multi-stage programming.},
  isbn      = {978-3-540-45022-1}
}

@inproceedings{kiselyov-16,
  author    = {Kiselyov, Oleg
               and Kameyama, Yukiyoshi
               and Sudo, Yuto},
  editor    = {Igarashi, Atsushi},
  title     = {Refined Environment Classifiers},
  booktitle = {Programming Languages and Systems},
  year      = {2016},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {271--291},
  abstract  = {Generating high-performance code and applying typical optimizations within the bodies of loops and functions involves moving or storing open code for later use, often in a different binding environment. There are ample opportunities for variables being left unbound or accidentally captured. It has been a tough challenge to statically ensure that by construction the generated code is nevertheless well-typed and well-scoped: all free variables in manipulated and stored code fragments shall eventually be bound, by their intended binders.},
  isbn      = {978-3-319-47958-3}
}

@inproceedings{isoda-24,
  author    = {Isoda, Kanaru and Yokoyama, Ayato and Kameyama, Yukiyoshi},
  title     = {Type-Safe Code Generation with Algebraic Effects and Handlers},
  year      = {2024},
  isbn      = {9798400712111},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3689484.3690731},
  doi       = {10.1145/3689484.3690731},
  abstract  = {Staged computation is a means to achieve maintainability and high performance simultaneously, by allowing a programmer to express domain-specific optimizations in a high-level programming language. Multi-stage programming languages such as MetaOCaml provide a static safety guarantee for generated programs by sophisticated type systems provided that program generators have no computational effects. Despite several studies, it remains a challenging problem to design a type-safe multi-stage programming language with advanced features for computational effects. This paper introduces a two-stage programming language with algebraic effects and handlers. Based on two novel principles 'handlers as future-stage binders' and 'handlers are universal', we design a type system and prove its soundness. We also show that our language is sufficiently expressive to write various effectful staged computations including multi-level let-insertion, which is a key technique to avoid code duplication in staged computation.},
  booktitle = {Proceedings of the 23rd {ACM SIGPLAN} International Conference on Generative Programming: Concepts and Experiences},
  pages     = {53–65},
  numpages  = {13},
  keywords  = {Algebraic effects and handlers, Code generation, Scope extrusion, Type soundness},
  location  = {Pasadena, CA, USA},
  series    = {{GPCE} '24}
}

@article{tratt-2008,
  title     = {Domain specific language implementation via compile-time meta-programming},
  author    = {Tratt, Laurence},
  journal   = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume    = {30},
  number    = {6},
  pages     = {1--40},
  year      = {2008},
  publisher = {{ACM} New York, NY, USA}
}

@article{yallop-2023,
  author     = {Yallop, Jeremy and Xie, Ningning and Krishnaswami, Neel},
  title      = {flap: A Deterministic Parser with Fused Lexing},
  year       = {2023},
  issue_date = {June 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {PLDI},
  url        = {https://doi.org/10.1145/3591269},
  doi        = {10.1145/3591269},
  abstract   = {Lexers and parsers are typically defined separately and connected by a token stream. This separate definition is important for modularity and reduces the potential for parsing ambiguity. However, materializing tokens as data structures and case-switching on tokens comes with a cost. We show how to fuse separately-defined lexers and parsers, drastically improving performance without compromising modularity or increasing ambiguity. We propose a deterministic variant of Greibach Normal Form that ensures deterministic parsing with a single token of lookahead and makes fusion strikingly simple, and prove that normalizing context free expressions into the deterministic normal form is semantics-preserving. Our staged parser combinator library, flap, provides a standard interface, but generates specialized token-free code that runs two to six times faster than ocamlyacc on a range of benchmarks.},
  journal    = {Proc. {ACM} Program. Lang.},
  month      = jun,
  articleno  = {155},
  numpages   = {24},
  keywords   = {parsing, optimization, multi-stage programming, lexing, fusion}
}

@inproceedings{servetto-2013,
  author    = {Servetto, Marco and Zucca, Elena},
  title     = {A meta-circular language for active libraries},
  year      = {2013},
  isbn      = {9781450318426},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2426890.2426913},
  doi       = {10.1145/2426890.2426913},
  abstract  = {We present a new Java-like language design coupling disciplined meta-programming features with a composition language. That is, programmers can write meta expressions that combine class definitions, on top of a small set of composition operators, inspired by the seminal Bracha's Jigsaw framework. Moreover, such operators are deep, that is, they allow manipulation (e.g., renaming or duplication) of a nested class at any level of depth.This provides an effective language support for active libraries: namely, a (library) class can provide a method returning a customized version of a class, depending, e.g., on the execution platform. Since a class can contain nested classes, a whole library can be generated in this way. That is, deep operators allows the programmer to better exploit meta-programming capabilities, leading to a "meta-programming in the large" style.We adopt a mixed typechecking technique, which provides a good compromise between meta-programming systems with extreme expressiveness and no static type checking, and those with strong type system and only limited meta-programming capability. In particular, our technique ensures an important property, called meta-level soundness, stating that typing errors never originate from already compiled (meta-)code, that is, programmers can safely use (active) libraries.},
  booktitle = {Proceedings of the ACM SIGPLAN 2013 Workshop on Partial Evaluation and Program Manipulation},
  pages     = {117–126},
  numpages  = {10},
  keywords  = {active libraries, java, meta-programming, nested classes},
  location  = {Rome, Italy},
  series    = {{PEPM} '13}
}

@book{wickham-2019,
  title     = {Advanced {R}},
  author    = {Wickham, Hadley},
  year      = {2019},
  publisher = {Chapman and Hall/{CRC}}
}

@article{vandebon-2021,
  author   = {Vandebon, Jessica and Coutinho, Jose G. F. and Luk, Wayne and Nurvitadhi, Eriko},
  journal  = {{IEEE} Transactions on Computers},
  title    = {Enhancing High-Level Synthesis Using a Meta-Programming Approach},
  year     = {2021},
  volume   = {70},
  number   = {12},
  pages    = {2043-2055},
  keywords = {Optimization;Field programmable gate arrays;Heterogeneous networks;Programming;Task analysis;Python;Heterogeneous computing;meta-programming;FPGA;high-level synthesis},
  doi      = {10.1109/TC.2021.3096429}
}

@misc{jax-grad-metaprogramming,
  author = {Jax-Ml},
  title  = {Using grad on vmap on map on function containing sinc results in error},
  url    = {https://github.com/jax-ml/jax/issues/10750}
}

@article{kiselyov-2012,
  title    = {Delimited control in {OCaml}, abstractly and concretely},
  journal  = {Theoretical Computer Science},
  volume   = {435},
  pages    = {56-76},
  year     = {2012},
  note     = {Functional and Logic Programming},
  issn     = {0304-3975},
  doi      = {https://doi.org/10.1016/j.tcs.2012.02.025},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397512001661},
  author   = {Oleg Kiselyov},
  keywords = {Delimited continuation, Exception, Semantics, Implementation, Abstract machine},
  abstract = {We describe the first implementation of multi-prompt delimited control operators in OCaml that is direct in that it captures only the needed part of the control stack. The implementation is a library that requires no changes to the OCaml compiler or run-time, so it is perfectly compatible with existing OCaml source and binary code. The library has been in fruitful practical use since 2006. We present the library as an implementation of an abstract machine derived by elaborating the definitional machine. The abstract view lets us distill a minimalistic API, scAPI, sufficient for implementing multi-prompt delimited control. We argue that a language system that supports exception and stack-overflow handling supports scAPI. With byte- and native-code OCaml systems as two examples, our library illustrates how to use scAPI to implement multi-prompt delimited control in a typed language. The approach is general and has been used to add multi-prompt delimited control to other existing language systems.}
}

@article{pretnar-2015,
  title    = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
  journal  = {Electronic Notes in Theoretical Computer Science},
  volume   = {319},
  pages    = {19-35},
  year     = {2015},
  note     = {The 31st Conference on the Mathematical Foundations of Programming Semantics ({MFPS XXXI}).},
  issn     = {1571-0661},
  doi      = {https://doi.org/10.1016/j.entcs.2015.12.003},
  url      = {https://www.sciencedirect.com/science/article/pii/S1571066115000705},
  author   = {Matija Pretnar},
  keywords = {algebraic effects, handlers, effect system, semantics, logic, tutorial},
  abstract = {This paper is a tutorial on algebraic effects and handlers. In it, we explain what algebraic effects are, give ample examples to explain how handlers work, define an operational semantics and a type & effect system, show how one can reason about effects, and give pointers for further reading.}
}

@inproceedings{felleisen-87,
  author    = {Matthias Felleisen and
               Daniel P. Friedman},
  editor    = {Martin Wirsing},
  title     = {Control operators, the SECD-machine, and the {\(\lambda\)}-calculus},
  booktitle = {Formal Description of Programming Concepts - {III:} Proceedings of
               the {IFIP} {TC} 2/WG 2.2 Working Conference on Formal Description
               of Programming Concepts - III, Ebberup, Denmark, 25-28 August 1986},
  pages     = {193--222},
  publisher = {North-Holland},
  year      = {1987},
  timestamp = {Thu, 10 Jan 2019 14:38:20 +0100},
  biburl    = {https://dblp.org/rec/conf/ifip2/FelleisenF87.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{kiselyov-2024,
  title    = {Generating {C}: Heterogeneous metaprogramming system description},
  journal  = {Science of Computer Programming},
  volume   = {231},
  pages    = {103015},
  year     = {2024},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2023.103015},
  url      = {https://www.sciencedirect.com/science/article/pii/S0167642323000977},
  author   = {Oleg Kiselyov},
  keywords = {Heterogeneous metaprogramming, Code generation, Tagless-final},
  abstract = {Heterogeneous metaprogramming systems use a higher-level host language to generate code in a lower-level object language. Their appeal is taking advantage of the module system, higher-order functions, data types, type system and verification tools of the host language to quicker produce high-performant lower-level code with some correctness guarantees. We present two heterogeneous metaprogramming systems whose host language is OCaml and object language is C. The first relies on offshoring: treating a subset of (MetaOCaml-generated) OCaml as a different notation for (a subset of) C. The second embeds C in OCaml in tagless-final style. The systems have been used in several projects, including the generation of C supersets OpenCL and OpenMP. Generating C with some correctness guarantees is far less trivial than it may appear, with pitfalls abound: e.g., local variables may only be introduced in statement context; mutable variables are not first-class. Maintenance has challenges of its own, e.g., extensibility. On many examples, we expound the pitfalls we have come across in our experience, and describe the design and implementation to address them.}
}

@article{mainland-2012,
  author     = {Mainland, Geoffrey},
  title      = {Explicitly heterogeneous metaprogramming with {MetaHaskell}},
  year       = {2012},
  issue_date = {September 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {47},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2398856.2364572},
  doi        = {10.1145/2398856.2364572},
  abstract   = {Languages with support for metaprogramming, like MetaOCaml, offer a principled approach to code generation by guaranteeing that well-typed metaprograms produce well-typed programs. However, many problem domains where metaprogramming can fruitfully be applied require generating code in languages like C, CUDA, or assembly. Rather than resorting to add-hoc code generation techniques, these applications should be directly supported by explicitly heterogeneous metaprogramming languages.We present MetaHaskell, an extension of Haskell 98 that provides modular syntactic and type system support for type safe metaprogramming with multiple object languages. Adding a new object language to MetaHaskell requires only minor modifications to the host language to support type-level quantification over object language types and propagation of type equality constraints. We demonstrate the flexibility of our approach through three object languages: a core ML language, a linear variant of the core ML language, and a subset of C. All three languages support metaprogramming with open terms and guarantee that well-typed MetaHaskell programs will only produce closed object terms that are well-typed. The essence of MetaHaskell is captured in a type system for a simplified metalanguage. MetaHaskell, as well as all three object languages, are fully implemented in the mhc bytecode compiler.},
  journal    = {{SIGPLAN} Not.},
  month      = sep,
  pages      = {311–322},
  numpages   = {12},
  keywords   = {type systems, quasiquotation, open terms, metaprogramming, linear languages}
}

@article{xie-2023,
  author     = {Xie, Ningning and White, Leo and Nicole, Olivier and Yallop, Jeremy},
  title      = {{MacoCaml}: Staging Composable and Compilable Macros},
  year       = {2023},
  issue_date = {August 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3607851},
  doi        = {10.1145/3607851},
  abstract   = {We introduce MacoCaml, a new design and implementation of compile-time code generation for the OCaml language. MacoCaml features a novel combination of macros with phase separation and quotation-based staging, where macros are considered as compile-time bindings, expression cross evaluation phases using staging annotations, and compile-time evaluation happens inside top-level splices. We provide a theoretical foundation for MacoCaml by formalizing a typed source calculus maco that supports interleaving typing and compile-time code generation, references with explicit compile-time heaps, and modules. We study various crucial properties including soundness and phase distinction. We have implemented MacoCaml in the OCaml compiler, and ported two substantial existing libraries to validate our implementation.},
  journal    = {Proc. {ACM} Program. Lang.},
  month      = aug,
  articleno  = {209},
  numpages   = {45},
  keywords   = {Compile-time code generation, Macros, OCaml, Staging}
}

@article{chiang-2024,
  author     = {Chiang, Tsung-Ju and Yallop, Jeremy and White, Leo and Xie, Ningning},
  title      = {Staged Compilation with Module Functors},
  year       = {2024},
  issue_date = {August 2024},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {8},
  number     = {ICFP},
  url        = {https://doi.org/10.1145/3674649},
  doi        = {10.1145/3674649},
  abstract   = {Multi-stage programming has been used in a wide variety of domains to  eliminate the tension between abstraction and performance. However, the  interaction of multi-stage programming features with features for  programming-in-the-large remains understudied, hindering the full integration  of multi-stage programming support into existing languages, and limiting the  effective use of staging in large programs.    We take steps to remedy the situation by studying the extension of MacoCaml, a  recent OCaml extension that supports compile-time code generation via  macros and quotations, with module functors, the key mechanism  in OCaml for assembling program components into larger units. We discuss design  choices related to evaluation order, formalize our calculus via elaboration, and  show that the design enjoys key metatheoretical properties: syntactic type  soundness, elaboration soundness, and phase distinction. We believe that this  study lays a foundation for the continued exploration and implementation of the  OCaml macro system.},
  journal    = {Proc. {ACM} Program. Lang.},
  month      = aug,
  articleno  = {260},
  numpages   = {35},
  keywords   = {Compile-time code generation, Macros, Modules, OCaml, Staging}
}

@inproceedings{inoue-2012,
  author    = {Inoue, Jun
               and Taha, Walid},
  editor    = {Seidl, Helmut},
  title     = {Reasoning about Multi-stage Programs},
  booktitle = {Programming Languages and Systems},
  year      = {2012},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {357--376},
  abstract  = {We settle three basic questions that naturally arise when verifying multi-stage functional programs. Firstly, does adding staging to a language compromise any equalities that hold in the base language? Unfortunately it does, and more care is needed to reason about terms with free variables. Secondly, staging annotations, as the name ``annotations'' suggests, are often thought to be orthogonal to the behavior of a program, but when is this formally guaranteed to be true? We give termination conditions that characterize when this guarantee holds. Finally, do multi-stage languages satisfy useful, standard extensional facts---for example, that functions agreeing on all arguments are equivalent? We provide a sound and complete notion of applicative bisimulation, which establishes such facts or, in principle, any valid program equivalence. These results greatly improve our understanding of staging, and allow us to prove the correctness of quite complicated multi-stage programs.},
  isbn      = {978-3-642-28869-2}
}

@article{phipps-costin-2023,
  author     = {Phipps-Costin, Luna and Rossberg, Andreas and Guha, Arjun and Leijen, Daan and Hillerstr\"{o}m, Daniel and Sivaramakrishnan, KC and Pretnar, Matija and Lindley, Sam},
  title      = {Continuing {WebAssembly} with Effect Handlers},
  year       = {2023},
  issue_date = {October 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {OOPSLA2},
  url        = {https://doi.org/10.1145/3622814},
  doi        = {10.1145/3622814},
  abstract   = {WebAssembly (Wasm) is a low-level portable code format offering near  
                native performance. It is intended as a compilation target for a wide  
                variety of source languages. However, Wasm provides no direct support  
                for non-local control flow features such as async/await,  
                generators/iterators, lightweight threads, first-class continuations,  
                etc. This means that compilers for source languages with such features  
                must ceremoniously transform whole source programs in order to target  
                Wasm.  
                
                
                We present WasmFX an extension to Wasm which provides a universal  
                target for non-local control features via effect handlers, enabling  
                compilers to translate such features directly into Wasm. Our  
                extension is minimal and only adds three main instructions for  
                creating, suspending, and resuming continuations. Moreover, our  
                primitive instructions are type-safe providing typed continuations  
                which are well-aligned with the design principles of Wasm whose stacks  
                are typed. We present a formal specification of WasmFX and show that  
                the extension is sound. We have implemented WasmFX as an extension to  
                the Wasm reference interpreter and also built a prototype WasmFX  
                extension for Wasmtime, a production-grade Wasm engine, piggybacking  
                on Wasmtime's existing fibers API. The preliminary performance  
                results for our prototype are encouraging, and we outline future plans  
                to realise a native implementation.},
  journal    = {Proc. {ACM} Program. Lang.},
  month      = oct,
  articleno  = {238},
  numpages   = {26},
  keywords   = {stack switching, effect handlers, WebAssembly}
}

@inproceedings{hillestrom-2018,
  author    = {Hillerstr{\"o}m, Daniel
               and Lindley, Sam},
  editor    = {Ryu, Sukyoung},
  title     = {Shallow Effect Handlers},
  booktitle = {Programming Languages and Systems},
  year      = {2018},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {415--435},
  abstract  = {Plotkin and Pretnar's effect handlers offer a versatile abstraction for modular programming with user-defined effects. Traditional deep handlers are defined by folds over computation trees. In this paper we study shallow handlers, defined instead by case splits over computation trees. We show that deep and shallow handlers can simulate one another up to specific notions of administrative reduction. We present the first formal accounts of an abstract machine for shallow handlers and a Continuation Passing Style (CPS) translation for shallow handlers taking special care to avoid memory leaks. We provide implementations in the Links web programming language and empirically verify that neither implementation introduces unwarranted memory leaks.},
  isbn      = {978-3-030-02768-1}
}

@article{xie-2022,
  author     = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
  title      = {First-class names for effect handlers},
  year       = {2022},
  issue_date = {October 2022},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {6},
  number     = {OOPSLA2},
  url        = {https://doi.org/10.1145/3563289},
  doi        = {10.1145/3563289},
  abstract   = {Algebraic effects and handlers are a promising technique for incorporating composable computational effects into functional programming languages. Effect handlers enable concisely programming with different effects, but they do not offer a convenient way to program with different instances of the same effect. As a solution to this inconvenience, previous studies have introduced _named effect handlers_, which allow the programmer to distinguish among different effect instances. However, existing formalizations of named handlers are both involved and restrictive, as they employ non-standard mechanisms to prevent the escaping of handler names. In this paper, we propose a simple and flexible design of named handlers. Specifically, we treat handler names as first-class values, and prevent their escaping while staying within the ordinary λ-calculus. Such a design is enabled by combining named handlers with _scoped effects_, a novel variation of effects that maintain a scope via rank-2 polymorphism. We formalize two combinations of named handlers and scoped effects, and implement them in the Koka programming language. We also present practical applications of named handlers, including a neural network and a unification algorithm.},
  journal    = {Proc. {ACM} Program. Lang.},
  month      = oct,
  articleno  = {126},
  numpages   = {30},
  keywords   = {Scoping, Effect Handlers, Algebraic Effects}
}

@article{bauer-2014,
  title     = {An Effect System for Algebraic Effects and Handlers},
  volume    = {Volume 10, Issue 4},
  issn      = {1860-5974},
  url       = {http://dx.doi.org/10.2168/LMCS-10(4:9)2014},
  doi       = {10.2168/lmcs-10(4:9)2014},
  journal   = {Logical Methods in Computer Science},
  publisher = {Centre pour la Communication Scientifique Directe ({CCSD})},
  author    = {Bauer, Andrej and Pretnar, Matija},
  year      = {2014},
  month     = dec
}

@article{levy-2003,
  title    = {Modelling environments in call-by-value programming languages},
  journal  = {Information and Computation},
  volume   = {185},
  number   = {2},
  pages    = {182-210},
  year     = {2003},
  issn     = {0890-5401},
  doi      = {https://doi.org/10.1016/S0890-5401(03)00088-9},
  url      = {https://www.sciencedirect.com/science/article/pii/S0890540103000889},
  author   = {PaulBlain Levy and John Power and Hayo Thielecke},
  abstract = {In categorical semantics, there have traditionally been two approaches to modelling environments, one by use of finite products in cartesian closed categories, the other by use of the base categories of indexed categories with structure. Each requires modifications in order to account for environments in call-by-value programming languages. There have been two more general definitions along both of these lines: the first generalising from cartesian to symmetric premonoidal categories, the second generalising from indexed categories with specified structure to κ-categories. In this paper, we investigate environments in call-by-value languages by analysing a fine-grain variant of Moggi’s computational λ-calculus, giving two equivalent sound and complete classes of models: one given by closed Freyd categories, which are based on symmetric premonoidal categories, the other given by closed κ-categories.}
}

@article{10.1145/3093333.3009901,
  author     = {Scherer, Gabriel},
  title      = {Deciding equivalence with sums and the empty type},
  year       = {2017},
  issue_date = {January 2017},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {52},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3093333.3009901},
  doi        = {10.1145/3093333.3009901},
  abstract   = {The logical technique of focusing can be applied to the λ-calculus; in a simple type system with atomic types and negative type formers (functions, products, the unit type), its normal forms coincide with βη-normal forms. Introducing a saturation phase gives a notion of quasi-normal forms in presence of positive types (sum types and the empty type). This rich structure let us prove the decidability of βη-equivalence in presence of the empty type, the fact that it coincides with contextual equivalence, and with set-theoretic equality in all finite models.},
  journal    = {{SIGPLAN} Not.},
  month      = jan,
  pages      = {374–386},
  numpages   = {13},
  keywords   = {canonicity, empty type, equivalence, focusing, saturation, simply-typed lambda-calculus, sums}
}

@inproceedings{scherer-2017,
  author    = {Scherer, Gabriel},
  title     = {Deciding equivalence with sums and the empty type},
  year      = {2017},
  isbn      = {9781450346603},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3009837.3009901},
  doi       = {10.1145/3009837.3009901},
  abstract  = {The logical technique of focusing can be applied to the λ-calculus; in a simple type system with atomic types and negative type formers (functions, products, the unit type), its normal forms coincide with βη-normal forms. Introducing a saturation phase gives a notion of quasi-normal forms in presence of positive types (sum types and the empty type). This rich structure let us prove the decidability of βη-equivalence in presence of the empty type, the fact that it coincides with contextual equivalence, and with set-theoretic equality in all finite models.},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  pages     = {374–386},
  numpages  = {13},
  keywords  = {canonicity, empty type, equivalence, focusing, saturation, simply-typed lambda-calculus, sums},
  location  = {Paris, France},
  series    = {{POPL} '17}
}

@inproceedings{kiselyov-24,
  author    = {Kiselyov, Oleg},
  title     = {{MetaOCaml}: Ten Years Later: System Description},
  year      = {2024},
  isbn      = {978-981-97-2299-0},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  url       = {https://doi.org/10.1007/978-981-97-2300-3_12},
  doi       = {10.1007/978-981-97-2300-3_12},
  abstract  = {MetaOCaml is a superset of OCaml for convenient code generation with static guarantees: the generated code is well-formed, well-typed and well-scoped, by construction. Not only the completed generated code always compiles; code fragments with a variable escaping its scope are detected already during code generation. MetaOCaml has been employed for compiling domain-specific languages, generic programming, automating tedious specializations in high-performance computing, generating efficient computational kernels and embedded programming. It is used in education, and served as inspiration for several other metaprogramming systems.Most well-known in MetaOCaml are the types for values representing generated code and the template-based mechanism to produce such values, a.k.a., brackets and escapes. MetaOCaml also features cross-stage persistence, generating ordinary and mutually-recursive definitions, first-class pattern-matching and heterogeneous metaprogramming.The extant implementation of MetaOCaml, first presented at FLOPS 2014, has been continuously evolving. We describe the current design and implementation, stressing particularly notable additions. Among them is a new, efficient, the easiest to retrofit translation from typed code templates to code combinators. Scope extrusion detection unexpectedly brought let-insertion, and a conclusive solution to the 20-year–old vexing problem of cross-stage persistence.},
  booktitle = {Functional and Logic Programming: 17th International Symposium, {FLOPS} 2024, Kumamoto, Japan, May 15–17, 2024, Proceedings},
  pages     = {219–236},
  numpages  = {18},
  keywords  = {metaprogramming, staging, code generation},
  location  = {Kumamoto, Japan}
}

@article{10.1145/2544174.2500590,
  author     = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
  title      = {Handlers in action},
  year       = {2013},
  issue_date = {September 2013},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {48},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2544174.2500590},
  doi        = {10.1145/2544174.2500590},
  abstract   = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
  journal    = {{SIGPLAN} Not.},
  month      = sep,
  pages      = {145–158},
  numpages   = {14},
  keywords   = {monads, modularity, haskell, effect typing, effect handlers, continuations, algebraic effects}
}

@inproceedings{kammar-2013,
  author    = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
  title     = {Handlers in action},
  year      = {2013},
  isbn      = {9781450323260},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2500365.2500590},
  doi       = {10.1145/2500365.2500590},
  abstract  = {Plotkin and Pretnar's handlers for algebraic effects occupy a sweet spot in the design space of abstractions for effectful computation. By separating effect signatures from their implementation, algebraic effects provide a high degree of modularity, allowing programmers to express effectful programs independently of the concrete interpretation of their effects. A handler is an interpretation of the effects of an algebraic computation. The handler abstraction adapts well to multiple settings: pure or impure, strict or lazy, static types or dynamic types. This is a position paper whose main aim is to popularise the handler abstraction. We give a gentle introduction to its use, a collection of illustrative examples, and a straightforward operational semantics. We describe our Haskell implementation of handlers in detail, outline the ideas behind our OCaml, SML, and Racket implementations, and present experimental results comparing handlers with existing code.},
  booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
  pages     = {145–158},
  numpages  = {14},
  keywords  = {algebraic effects, continuations, effect handlers, effect typing, haskell, modularity, monads},
  location  = {Boston, Massachusetts, USA},
  series    = {{ICFP} '13}
}

@article{10.1145/1631687.1596567,
  author     = {Benton, Nick and Hur, Chung-Kil},
  title      = {Biorthogonality, step-indexing and compiler correctness},
  year       = {2009},
  issue_date = {September 2009},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {44},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1631687.1596567},
  doi        = {10.1145/1631687.1596567},
  abstract   = {We define logical relations between the denotational semantics of a simply typed functional language with recursion and the operational behaviour of low-level programs in a variant SECD machine. The relations, which are defined using biorthogonality and stepindexing, capture what it means for a piece of low-level code to implement a mathematical, domain-theoretic function and are used to prove correctness of a simple compiler. The results have been formalized in the Coq proof assistant.},
  journal    = {SIGPLAN Not.},
  month      = aug,
  pages      = {97–108},
  numpages   = {12},
  keywords   = {biorthogonality, compiler verification, denotational semantics, proof assistants, step-indexing}
}

@inproceedings{benton-09,
  author    = {Benton, Nick and Hur, Chung-Kil},
  title     = {Biorthogonality, step-indexing and compiler correctness},
  year      = {2009},
  isbn      = {9781605583327},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1596550.1596567},
  doi       = {10.1145/1596550.1596567},
  abstract  = {We define logical relations between the denotational semantics of a simply typed functional language with recursion and the operational behaviour of low-level programs in a variant SECD machine. The relations, which are defined using biorthogonality and stepindexing, capture what it means for a piece of low-level code to implement a mathematical, domain-theoretic function and are used to prove correctness of a simple compiler. The results have been formalized in the Coq proof assistant.},
  booktitle = {Proceedings of the 14th {ACM SIGPLAN} International Conference on Functional Programming},
  pages     = {97–108},
  numpages  = {12},
  keywords  = {biorthogonality, compiler verification, denotational semantics, proof assistants, step-indexing},
  location  = {Edinburgh, Scotland},
  series    = {{ICFP} '09}
}

@article{tait-67,
  issn      = {00224812},
  url       = {http://www.jstor.org/stable/2271658},
  author    = {W. W. Tait},
  journal   = {The Journal of Symbolic Logic},
  number    = {2},
  pages     = {198--212},
  publisher = {Association for Symbolic Logic},
  title     = {Intensional Interpretations of Functionals of Finite Type I},
  urldate   = {2025-05-21},
  volume    = {32},
  year      = {1967}
}

@inproceedings{yallop-2019,
  author    = {Yallop, Jeremy and Kiselyov, Oleg},
  title     = {Generating mutually recursive definitions},
  year      = {2019},
  isbn      = {9781450362269},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3294032.3294078},
  doi       = {10.1145/3294032.3294078},
  abstract  = {Many functional programs — state machines [Krishnamurthi 2006], top-down and bottom-up parsers [Hinze and Paterson 2003; Hutton and Meijer 1996], evaluators [Abelson et al. 1984], GUI initialization graphs [Syme 2006], &c. — are conveniently expressed as groups of mutually recursive bindings. One therefore expects program generators, such as those written in MetaOCaml, to be able to build programs with mutual recursion.  Unfortunately, currently MetaOCaml can only build recursive groups whose size is hard-coded in the generating program. The general case requires something other than quotation, and seemingly weakens static guarantees on the resulting code. We describe the challenges and propose a new language construct for assuredly generating binding groups of arbitrary size – illustrating with a collection of examples for mutual, n-ary, heterogeneous, value and polymorphic recursion.},
  booktitle = {Proceedings of the 2019 {ACM SIGPLAN} Workshop on Partial Evaluation and Program Manipulation},
  pages     = {75–81},
  numpages  = {7},
  keywords  = {Recursion, fixed points, metaprogramming, multi-stage programming},
  location  = {Cascais, Portugal},
  series    = {{PEPM} 2019}
}

@misc{plotkin-2025,
  title         = {Handling the Selection Monad (Full Version)},
  author        = {Gordon Plotkin and Ningning Xie},
  year          = {2025},
  eprint        = {2504.03890},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  url           = {https://arxiv.org/abs/2504.03890}
}

@misc{kuchta-2023,
  author = {Wiktor Kuchta},
  title  = {A proof of normalization for effect handlers},
  year   = {2023},
  month  = sep,
  note   = {Seattle, Washington, United States},
  url    = {https://icfp23.sigplan.org/details/hope-2023/4/A-proof-of-normalization-for-effect-handlers}
}

@article{biernacki-2017,
  author     = {Biernacki, Dariusz and Pir\'{o}g, Maciej and Polesiuk, Piotr and Sieczkowski, Filip},
  title      = {Handle with care: relational interpretation of algebraic effects and handlers},
  year       = {2017},
  issue_date = {January 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {2},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3158096},
  doi        = {10.1145/3158096},
  abstract   = {Algebraic effects and handlers have received a lot of attention recently, both from the theoretical point of view and in practical language design. This stems from the fact that algebraic effects give the programmer unprecedented freedom to define, combine, and interpret computational effects. This plenty-of-rope, however, demands not only a deep understanding of the underlying semantics, but also access to practical means of reasoning about effectful code, including correctness and program equivalence. In this paper we tackle this problem by constructing a step-indexed relational interpretation of a call-by-value calculus with algebraic effect handlers and a row-based polymorphic type-and-effect system. Our calculus, while striving for simplicity, enjoys desirable theoretical properties, and is close to the cores of programming languages with algebraic effects used in the wild, while the logical relation we build for it can be used to reason about non-trivial properties, such as contextual equivalence and contextual approximation of programs. Our development has been fully formalised in the Coq proof assistant.},
  journal    = {Proc. {ACM} Program. Lang.},
  month      = dec,
  articleno  = {8},
  numpages   = {30},
  keywords   = {row polymorphism, logical relation, algebraic effect}
}